# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Calculation
~~~~~~~~~~~

Creation of a Study and execution of a Case."""


import os.path as osp

from ..common import get_absolute_path, no_new_attributes, remove_path
from ..datamodel import FileAttr, History
from ..datamodel.engine import Engine, default_parameters
from ..datamodel.engine.helper import CalcWatcher


class Calculation:
    """Object to create a study in AsterStudy and to execute a calculation.

    The study is created by adding from a file or a text of commands::

        from asterstudy.api import Calculation, FileAttr, StateOptions

        calc = Calculation("/working_directory")
        calc.add_stage_from_file("/path/to/file.comm")
        calc.add_stage_from_string(text)

    The study can also start from a database (it must be the first stage)::

        calc.add_stage_from_database("/path/to/database_path")

    A data file can be added using::

        calc.add_file("/path/input_file", 20, FileAttr.In)

    and result files::

        calc.add_file("/working_directory/result.rmed", 80, FileAttr.Out)

    Directories are also supported as input::

        calc.set_input_dir("/path/repe.in")

    or for output::

        calc.set_output_dir("/path/repe.out")

    The parameters of the calculation are set by::

        calc.set("memory", 4096)
        calc.set("time", 900)
        # or
        calc.set("time", "00:15:00")

    Execute the calculation synchronously::

        calc.run()

    or start it asynchronously and follow its state::

        calc.start()
        while not calc.is_finished():
            print("Current state is", calc.state_name)

    Check the state::

        assert calc.state & StateOptions.Success
        print(calc.state_name)

    Paths of results files and log files::

        logs = calc.logfiles()
        results = calc.results_paths()
        ...

    A code_aster results database is created (unless 'no_database' parameter
    is used) and its path name is given by::

        dbpath = calc.database_path

    If the calculation is submitted with a batch scheduler it may not start
    immediately. That's why a timeout is set. By default it is 5 times the
    *time* set by the parameters. It can be defined manually::

        calc.timeout = 3600


    The available parameters are defined by
    :func:`asterstudy.datamodel.engine.engine_utils.default_parameters`:

    - 'server': server name as known by JobManager,
    - 'mode': 'Batch/Interactive',
    - 'version': version name,
    - 'memory': in MB,
    - 'time': in format 'HH:MM:SS' or 'MM:SS' or in seconds,
    - 'threads': number of threads,
    - 'mpicpu': number of MPI processes,
    - 'nodes': number of nodes for MPI executions,
    - 'no_database': not to keep the results database,
    - 'compress': compress or not the database,
    - 'language': language used by code_aster,
    - 'remote_folder': remote directory if the results database is stored on
      the server,
    - 'partition': partition name for batch submission,
    - 'qos': qos for batch submission,
    - 'args': string passed on the code_aster command line.

    Arguments:
        folder (str): Path to the directory to be used for the study.
    """

    _hist = _case = _done = _params = _watcher = None

    __setattr__ = no_new_attributes(object.__setattr__)

    def __init__(self, folder):
        """Initialization."""
        self._hist = History()
        self._hist.folder = get_absolute_path(folder)
        self._case = self._hist.current_case
        self._params = default_parameters()
        self._params['folder'] = self._hist.folder
        self._watcher = CalcWatcher(self._params)
        self._done = False

    def add_stage_from_file(self, filename, name=None):
        """Add a Stage from a file.

        Arguments:
            filename (str): Path to the commands file.
            name (str): Name of the Stage to be created.
        """
        name = name or osp.splitext(osp.basename(filename))[0]
        with open(filename) as comm:
            text = comm.read()

        self.add_stage_from_string(text, name)

    def add_stage_from_string(self, text, name=None):
        """Add a Stage from a string.

        Arguments:
            text (str): Text of the commands.
            name (str): Name of the Stage to be created.
        """
        name = name or 'Stage_1'
        stage = self._case.create_stage(name)
        stage.use_text_mode()
        stage.set_text(text)

    def add_file(self, filename, unit, inout):
        """Add a file in data or result.

        Arguments:
            filename (str): Path of the file.
            unit (int): Logical unit number used in the Stages.
            inout (FileAttr): File type cumulative value: *In*, *Out*, *Named*.
        """
        assert self._case.nb_stages > 0, "there is no stage!"
        stage = self._case[0] if inout & FileAttr.In else self._case[-1]
        if inout & FileAttr.Named or unit == 0:
            unit = osp.basename(filename)
            inout |= FileAttr.Named
        info = stage.handle2info[unit]
        info.filename = get_absolute_path(filename)
        info.attr = inout

    def add_stage_from_database(self, path):
        """Insert a stage that loads a database.

        Arguments:
            path (str): Path to the database.
        """
        from ..datamodel.usages.load_database import create_stage_from_database
        assert self._case.nb_stages == 0, "must be used before adding stages!"
        create_stage_from_database(self._case, path)

    def set_input_dir(self, path):
        """Define the input directory ('REPE_IN').

        Arguments:
            path (str): Path of the directory.
        """
        self._case.in_dir = get_absolute_path(path)

    def set_output_dir(self, path):
        """Define the output directory ('REPE_OUT').

        Arguments:
            path (str): Path of the directory.
        """
        self._case.out_dir = get_absolute_path(path)

    def set(self, parameter, value):
        """Set the value of a parameter."""
        if parameter not in self._params.keys():
            raise KeyError("unknown parameter: '{0}', should be one of {1}"
                           .format(parameter, tuple(self._params.keys())))
        self._params[parameter] = value

    @property
    def nb_stages(self):
        """Attribute that *holds* the number of Stages."""
        return self._case.nb_stages

    def delete_files(self):
        """Remove temporary files."""
        remove_path(self._hist.folder)

    def run_case_name(self): # pragma pylint: disable=no-self-use
        """Return the name to be used as RunCase name.

        Default implementation uses the default RunCase naming.

        Returns:
            str: The RunCase name to be used.
        """
        return ""

    def _assign_run_case(self):
        if not self._done:
            assert self._case.nb_stages > 0, "there is no stage!"
            self._done = True
            runc = self.run_case_name()
            self._watcher.run_case = self._hist.create_run_case(name=runc)

    def start(self):
        """Start the calculation asynchronously."""
        self._assign_run_case()
        self._watcher.start()

    # following functions are delegated to the CalcWatcher object
    @property
    def timeout(self):
        """Attribute that *holds* the timeout (in seconds)."""
        return self._watcher.timeout

    @timeout.setter
    def timeout(self, value):
        """Setter for the timeout.

        Arguments:
            value (str): Time out in seconds, MM:SS or in HH:MM:SS format.
        """
        self._watcher.timeout = value

    def set_logger(self, logfunc):
        """Register a logger function.

        Arguments:
            logfunc (function): Logger function (*logfunc(str)*).
        """
        self._watcher.set_logger(logfunc)

    @property
    def state(self):
        """Attribute that *holds* the current state of the execution.

        Note: A minimal delay is imposed between updates of the state.

        Returns:
            *StateOptions*: State of the execution encoded in a bitwise integer.
        """
        return self._watcher.state

    @property
    def state_name(self):
        """Attribute that *holds* the label of the state of the execution."""
        return self._watcher.state_name

    def is_finished(self):
        """Tell if the calculation is finished or if its time out expired.

        Returns:
            bool: *True* if the calculation ended or expired, *False* otherwise.
        """
        return self._watcher.is_finished()

    def is_successful(self):
        """Tell if the calculation ended successfully.

        Returns:
            bool: *True* if the calculation ended with *Success* state,
            *False* if it ended with *Error* (fatal error) or *Interrupted*
            ('<S>' error) states.
        """
        return self._watcher.is_successful()

    def run(self):
        """Execute the calculation and wait until its completion."""
        self._assign_run_case()
        self._watcher.run()

    def logfiles(self):
        """Returns the list of pathnames of the logfiles.

        Returns:
            list[str]: Paths of the logfiles.
        """
        return self._watcher.logfiles()

    def log(self, *args):
        """Logging function."""
        self._watcher.log(*args)

    def results_paths(self):
        """Returns the list of pathnames of the results.

        Returns:
            list[str]: List of the path names.
        """
        return self._watcher.results_paths()

    @property
    def database_path(self):
        """Attribute that holds the pathname of the database (created by the
        last stage). It may not exist if 'no_database' parameter has been used.

        Returns:
            str: Path name to the database.
        """
        return self._watcher.database_path

    def use_interactive(self):
        """Do not create a *SalomeJob* but directly execute the calculation.
        """
        self._watcher.set_engine(Engine.Direct)
