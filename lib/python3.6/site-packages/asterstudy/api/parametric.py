# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Parametric
~~~~~~~~~~

Setup of parametric studies.
"""


import hashlib
import os.path as osp
import pickle

import numpy

from ..common import (debug_message, debug_mode, get_absolute_path, make_dirs,
                      no_new_attributes, remove_path, valid_file_name)
from ..datamodel import FileAttr
from ..datamodel.engine.engine_utils import default_parameters
from ..datamodel.parametric import INPUTS, OUTPUTS
from ..datamodel.result import StateOptions as SO
from .execution import Calculation


class ParametricCalculation(Calculation):
    """Object to execute a parametric calculation.

    Arguments:
        casedir (str): Path to the directory containing the Case description.
            The Case is defined by a file named 'parametric.export' in this
            directory.
        names (list[str]): List of the names of the input variables.
        values (list[float]): List of the values of the input variables.
    """

    basedir = runcdir = names = inputs = outputs = None
    _rcname = _del = None

    __setattr__ = no_new_attributes(object.__setattr__)

    def __init__(self, casedir, names, values, keep_results=False):
        """Initialization."""
        casedir = get_absolute_path(casedir)
        super().__init__(casedir)
        self.names = names
        self.inputs = values
        self._del = not keep_results
        self.outputs = []
        self.basedir = casedir
        self.runcdir = osp.join(self.basedir, self.run_case_name())
        make_dirs(self.runcdir)

    def run(self):
        """Execute the calculation and wait until its completion."""
        self.use_interactive()
        super().run()

        self.log("Execution state: {0}".format(self.state_name))

        self.read_output_file()
        if self.state & SO.Success and self._del and not debug_mode():
            self.delete_files()

    def output_values(self):
        """Return output values."""
        return self.outputs

    def setup(self):
        """Set up the *Case* from its export file.
        """
        export = osp.join(self.basedir, 'parametric.export')
        self._case, params = self._hist.import_case(export, replace=True,
                                                    force_text=True)
        debug_message("ParametricCalculation case: {0}".format(self._case))

        self.create_input_file()
        # use different input/output files for each run
        # store results in the current runcase directory
        for stage in self._case.stages:
            for _, info in stage.handle2info.items():
                if osp.basename(info.filename) == INPUTS:
                    info.filename = osp.join(self.runcdir, INPUTS)
                if info.attr & FileAttr.Out:
                    info.filename = osp.join(self.runcdir,
                                             osp.basename(info.filename))

        # job parameters
        self._params.update(params)
        self._params['no_database'] = True

    def use(self, **kwargs):
        """Set some execution parameters.

        Relevant parameters are: *version*, *memory*, *time*, *mpicpu*, *nodes*,
        *threads*, *language*, *args*.

        Arguments:
            kwargs (dict): Execution parameters passed as keyword arguments.
        """
        for key in default_parameters().keys():
            if kwargs.get(key) is not None:
                self._params[key] = kwargs[key]

    def create_input_file(self):
        """Create the file to pass the input values."""
        self.log("Input variables: {0}".format(self.names))
        self.log("Input values: {0}".format(self.inputs))
        filename = osp.join(self.runcdir, INPUTS)
        with open(filename, 'wb') as pick:
            pickle.dump(self.names, pick)
            pickle.dump(self.inputs, pick)

    def read_output_file(self):
        """Read the output file to extract results."""
        filename = osp.join(self.runcdir, OUTPUTS)
        if not osp.exists(filename):
            self.log("ERROR: no such file '{0}'".format(filename))
            return
        results = numpy.load(filename)
        nbline, nbvar = results.shape
        self.log("Raw output values - {0} variable(s), {1} line(s):"
                 .format(nbvar, nbline))
        self.log(str(results))
        self.outputs = results.T.tolist()
        if nbline == 1:
            self.outputs = results[0].tolist()

    def delete_files(self):
        """Remove temporary files."""
        remove_path(self.runcdir)

    def run_case_name(self):
        """Return a new (inexistant and unique) RunCase name.

        Returns:
            str: Unused name for a new RunCase.
        """
        if not self._rcname:
            path = valid_file_name(".run_param_" + repr(self.inputs))
            if len(path) > 256:
                sha1 = hashlib.sha1()
                sha1.update(repr(self.inputs).encode())
                maxl = 255 - len(self.basedir) - 2 - 40
                path = path[:maxl] + '_' + sha1.hexdigest()
            self._rcname = path
        return self._rcname
