# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Execution objects
-----------------

Implementation of objects that give access to execution results.

"""



from ...common import no_new_attributes, to_list, translate
from .utils import StateOptions


class Result:
    """Implementation of the result."""

    _state = _stage = _job = _has_remote = _messages = None
    __setattr__ = no_new_attributes(object.__setattr__)

    def __init__(self, stage):
        """
        Create Result object.

        Arguments:
            stage (Stage): Parent Stage.
            name (Optional[str]): Name of Result. Defaults to *None*.
        """
        self._stage = stage
        self._state = StateOptions.Waiting
        self._job = Job()
        self._has_remote = False
        self._messages = []

    @property
    def stage(self):
        """Stage: Attribute that holds Result's parent stage."""
        return self._stage

    @stage.setter
    def stage(self, value):
        """Set Result's parent stage."""
        self._stage = value

    @property
    def state(self):
        """int: Attribute that holds Result's status (*StateOptions*)."""
        return self._state

    @state.setter
    def state(self, value):
        """Set Result's status.

        Arguments:
            value (StateOptions): new state of the Result (an intermediate
                state stays intermediate).
        """
        if self.is_intermediate():
            self._state = value | StateOptions.Intermediate
        else:
            preceding_stages = [i for i in self._stage.preceding_stages]
            for stg in reversed(preceding_stages):
                if not stg.is_intermediate():
                    break
                stg.state = value
            self._state = value

    def is_intermediate(self):
        """Tell if the stage is an intermediate one
        (means executed grouped with the following).
        """
        return bool(self._state & StateOptions.Intermediate)

    @property
    def folder(self):
        """Return the folder containing the result files.

        Returns:
            str: Path to results directory.
        """
        stage = self._stage
        if self.is_intermediate():
            stage = stage.parent_case.get_stage_by_num(stage.number + 1)
        return stage.folder

    @property
    def job(self):
        """int: Attribute that holds Result's job identifier."""
        return self._job

    @property
    def used_in_cases(self):
        """list[Case]: Attribute that holds list of Cases where this
        Result is used."""
        return self._stage.cases

    @property
    def has_remote(self):
        """bool: if result databases are kept on remote execution server."""
        return self._has_remote

    @has_remote.setter
    def has_remote(self, value):
        """To set the keep-on-remote property for result databases."""
        self._has_remote = value

    def clear(self):
        """Clear result."""
        self._state = StateOptions.Waiting

    def __str__(self):
        """Get Result's representation as string."""
        return 'Result-' + self._stage.name

    def __repr__(self):
        """Get stringified representation of the result."""
        return "{0} <{1}>".format(str(self), StateOptions.name(self.state))

    def __mul__(self, other):
        """Support native Python '*' operator protocol."""
        assert self.state == other.state \
            and self._stage.name == other.stage.name

    @property
    def messages(self):
        """Get the list of messages of this execution.

        Messages are returned in the order of creation that is supposed to be
        the raising order.
        """
        return self._messages

    def clear_messages(self):
        """Clear the list of messages of this execution.

        Useful to extract messages from a new fresh output file.
        """
        self._messages = []

    def add_messages(self, msglist):
        """Add messages to the list of messages of this execution.

        Arguments:
            msglist (list[Message]): List of messages to be added.
        """
        existing = [msg.checksum for msg in self._messages]
        for msg in to_list(msglist):
            if msg.checksum not in existing:
                msg.set_stage(self.stage)
                self._messages.append(msg)


class Job:
    """Implementation of the job informations.

    It stores informations required to refresh a job even after a save/reload
    and parameters enter the *Run dialog*.
    """
    # pragma pylint: disable=too-many-instance-attributes
    # !!! keep consistency with asterstudy.proto for serialization !!!
    Null = 0x00
    Batch = 0x01
    Interactive = 0x02
    Console = Interactive | 0x04
    BatchText = translate("Dashboard", "Batch")
    InteractiveText = translate("Dashboard", "Interactive")
    ConsoleText = translate("Dashboard", "Console")
    # for execution mode
    ExecOptimText = translate("Dashboard", "Use optimized version")
    ExecDebugText = translate("Dashboard", "Use debug version")
    ExecDebuggerText = translate("Dashboard", "Run under Debugger")
    PrepEnvText = translate("Dashboard", "Prepare the environment")

    _jobid = _name = _server = _mode = _descr = _start = _end = _studyid = None
    _assigned = _dump_string = None
    # Names of execution parameters
    # Do not add properties for these parameters: set by `set_parameters_from`
    ExecParameters = ('memory', 'time', 'version', 'mpicpu', 'nodes', 'threads',
                      'folder', 'compress', 'partition', 'queue', 'args',
                      'wckey', 'extra')
    _memory = _time = _version = _mpicpu = _nodes = _threads = _folder = None
    _compress = _partition = _queue = _args = _wckey = _extra = None
    __setattr__ = no_new_attributes(object.__setattr__)

    def __init__(self):
        # tells if the 'jobid' has just been reloaded or assigned.
        self._assigned = False
        # Default values must be consistent with type declared in '.proto'
        # These values are considered as undefined.
        # properties
        self._jobid = ''
        self._dump_string = ''
        self._name = ''
        self._server = ''
        self._mode = Job.Null
        self._start = ''
        self._end = ''
        self._descr = ''
        self._studyid = None
        # execution parameters set by `set_parameters_from`
        self._memory = 0
        self._time = ''
        self._version = ''
        self._mpicpu = 0
        self._nodes = 0
        self._threads = 0
        self._folder = ''
        self._compress = False
        self._partition = ''
        self._queue = ''
        self._args = ''
        self._wckey = ''
        self._extra = ''

    def is_defined(self, key):
        """Tell if the parameter has been defined."""
        return getattr(self, "_" + key) != getattr(Job(), "_" + key)

    # Properties that are externally set
    @property
    def jobid(self):
        """str: Attribute that holds the job's identifier."""
        return self._jobid

    @jobid.setter
    def jobid(self, value):
        """Assign the job identifier."""
        self._jobid = value
        self._assigned = True

    def reload_jobid(self, value):
        """Initialize the job identifier during reloading.

        Arguments:
            value (int|str): Value of the job identifier.
        """
        self._jobid = str(value)

    @property
    def assigned(self):
        """bool: Attribute that holds the 'assigned' property."""
        return self._assigned

    @property
    def jobid_int(self):
        """int: Return the job's identifier as int (for runners that expect
        an integer)."""
        return int(self._jobid or -1)

    @property
    def dump_string(self):
        """str: Attribute that holds the 'dump_str' property."""
        return self._dump_string

    @dump_string.setter
    def dump_string(self, value):
        self._dump_string = value

    @property
    def studyid(self):
        """str: Attribute that holds the process identifier."""
        return self._studyid

    @studyid.setter
    def studyid(self, value):
        """Assign the process identifier."""
        self._studyid = value

    @property
    def name(self):
        """str: Attribute that holds the job's name."""
        return self._name

    @name.setter
    def name(self, value):
        """Assign the jobs's name."""
        self._name = value

    @property
    def server(self):
        """str: Attribute that holds the server on which the job was
        submitted."""
        return self._server

    @server.setter
    def server(self, value):
        """Assign the submission server."""
        self._server = value

    @property
    def mode(self):
        """int: Attribute that holds the running mode."""
        return self._mode

    def _set_mode(self, value):
        """Assign the running mode.

        Used by :py:meth:`Job.set`.
        """
        if not isinstance(value, int):
            value = Job.text_to_mode(value)
        self._mode = value

    @mode.setter
    def mode(self, value):
        """Assign the running mode."""
        self._set_mode(value)

    @property
    def description(self):
        """str: Attribute that holds the job's description."""
        return self._descr

    @description.setter
    def description(self, value):
        """Assign the job description."""
        self._descr = value

    @property
    def start_time(self):
        """str: Attribute that holds the time when the job was submitted."""
        return self._start

    @start_time.setter
    def start_time(self, value):
        """Set the start time."""
        self._start = value

    @property
    def end_time(self):
        """str: Attribute that holds the time when the job was submitted."""
        return self._end

    @end_time.setter
    def end_time(self, value):
        """Set the end time."""
        self._end = value

    @property
    def full_description(self):
        """str: The job's description that is the description entered by the
        user and a summary of job's execution parameters."""
        ident = " " * 4
        lines = ["{0._descr}",
                 "",
                 translate("Dashboard", "Start time: {0._start}"),
                 translate("Dashboard", "End time: {0._end}"),
                 translate("Dashboard", "Server name: {0._server}"),
                 translate("Dashboard", "Version: {0._version}"),
                 translate("Dashboard", "Submission parameters:"),
                 ident + translate("Dashboard",
                                   "Memory limit: {0._memory} MB"),
                 ident + translate("Dashboard",
                                   "Time limit: {0._time}"),
                 ident + translate("Dashboard",
                                   "Partition: {0._partition}"),
                 ident + translate("Dashboard",
                                   "Queue: {0._queue}"),
                 ident + translate("Dashboard",
                                   "Job identifier: {0._jobid}"),
                 translate("Dashboard", "Parallel parameters:"),
                 ident + translate("Dashboard",
                                   "Number of nodes: {0._nodes}"),
                 ident + translate("Dashboard",
                                   "Number of processors: {0._mpicpu}"),
                 ident + translate("Dashboard",
                                   "Number of threads: {0._threads}"),
                 ""]
        return "\n".join(lines).format(self)

    @staticmethod
    def text_to_mode(text):
        """Return the text for a given mode."""
        return {
            "": Job.Null,
            Job.BatchText: Job.Batch,
            Job.InteractiveText: Job.Interactive,
            Job.ConsoleText: Job.Console,
        }[text]

    @staticmethod
    def mode_to_text(mode):
        """Return the mode for a given text label."""
        return {
            Job.Null: "",
            Job.Batch: Job.BatchText,
            Job.Interactive: Job.InteractiveText,
            Job.Console: Job.ConsoleText,
        }[mode]

    def set_parameters_from(self, parameters):
        """Set the value of parameters from a dict."""
        for key in Job.ExecParameters:
            if key not in parameters.keys():
                continue
            self.set(key, parameters[key])

    def copy_parameters_from(self, other):
        """Copy the value of undefined parameters from another Job object."""
        if not self._server:
            self.server = other.server
        if self._mode == Job.Null:
            self.mode = other.mode
        if not self._descr:
            self.description = other.description
        for key in Job.ExecParameters:
            if not self.is_defined(key) and other.is_defined(key):
                self.set(key, other.get(key))

    def asdict(self):
        """Return parameters as a dict."""
        params = {}
        if self.jobid:
            params['jobid'] = self.jobid
        if self.name:
            params['name'] = self.name
        if self.server:
            params['server'] = self.server
        if self.mode:
            params['mode'] = self.mode_to_text(self.mode)
        if self.description:
            params['description'] = self.description
        for key in Job.ExecParameters:
            if self.is_defined(key):
                params[key] = self.get(key)
        return params

    def is_empty(self):
        """Tell if no parameter has been defined.

        Returns:
            bool: *False* if at least one parameter is set. *True* otherwise.
        """
        return not bool(self.asdict())

    def set(self, parameter, value):
        """Set the value of a parameter."""
        setter = getattr(self, "_set_" + parameter, None)
        if not setter:
            setattr(self, "_" + parameter, value)
        else:
            setter(value)

    def get(self, parameter, default=None):
        """Return a property value by name or *default* if it is not set."""
        if not self.is_defined(parameter):
            return default
        return getattr(self, "_" + parameter)
