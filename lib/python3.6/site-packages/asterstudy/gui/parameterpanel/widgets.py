# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Additional specific widgets for Parameters Panel
------------------------------------------------

Implementation of the Parameters panel specific widgets.

"""

from PyQt5 import Qt as Q

# pylint: disable=wrong-import-order,wrong-import-position,ungrouped-imports
import matplotlib
matplotlib.use("Qt5Agg")

from .basic import ContentData, Options, parameterPanel
from .. import Panel, translate_rule
from ..variablepanel import VariablePanel
from ..widgets import ElidedButton, ElidedLabel
from ...common import (CFG, bold, debug_mode, font, image, is_subclass, italic, load_icon,
                       preformat, to_list, translate, wrap_html)
from ...datamodel import CATA
from ...datamodel.command import Variable

# workaround for confusion in matplotlib import on calibre9
try:
    from matplotlib import pyplot
    from matplotlib.backend_bases import key_press_handler
    from matplotlib.backends.backend_qt5agg import (
        FigureCanvasQTAgg as FigureCanvas,
        NavigationToolbar2QT as NavigationToolbar)
except ImportError:
    FigureCanvas = object


# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name


class ParameterLabel(Q.QWidget, ContentData):
    """Helper class to display parameter's name."""

    clicked = Q.pyqtSignal()

    def __init__(self, path, rules, parent=None):
        """
        Create widget.

        Arguments:
            path (ParameterPath): Keyword's path.
            rules (list[ParameterRuleItem]): Keyword's rules.
            parent (Optional[QWidget]): Parent widget.
        """
        super().__init__(parent)

        self._path = path
        self._rules = rules

        base = Q.QVBoxLayout(self)
        base.setSpacing(0)
        base.setContentsMargins(0, 0, 0, 0)

        self._titlelabel = ElidedLabel("", self)
        self._contentslabel = ElidedLabel("", self)
        base.addWidget(self._titlelabel)
        base.addWidget(self._contentslabel)

        self._titlelabel.setObjectName(path.name() + '_title')
        self._contentslabel.setObjectName(path.name() + '_content')

        self.updateTranslations()
        self.setSizePolicy(Q.QSizePolicy(Q.QSizePolicy.Expanding,
                                         Q.QSizePolicy.Preferred))

        contfont = self._contentslabel.font()
        contfont.setPixelSize(10)
        self._contentslabel.setFont(contfont)

        contpal = self._contentslabel.palette()
        contpal.setColor(self._contentslabel.foregroundRole(), Q.Qt.darkBlue)
        self._contentslabel.setPalette(contpal)

        self.setContents(None, "none")

    def updateTranslations(self):
        """
        Update translation.
        """
        if not self.isVisible():
            return

        path = self.path()
        name = path.name()
        command = path.command()

        # get business-oriented translation if present and set label's text
        if name.isdigit():
            self._titlelabel.setText("[%s]" % name)
            name = path.parentPath().name()
            translation = Options.translate_command(command.title, name)
        else:
            translation = Options.translate_command(command.title, name)
            self._titlelabel.setText(translation)

        # compute tooltip / what's this base info
        if translation != name:
            wttext = italic(translation) + " ({})".format(bold(name))
        else:
            wttext = bold(name)
        wttext = preformat(wttext)

        # set content
        contstr = ""
        if self.contentsMode() != "none" and \
                self.contentsValue() is not None:
            contstr = self._contentsText(self.path())
        self._contentslabel.setText(contstr)
        self._contentslabel.setVisible(len(self._contentslabel.text()) > 0)

        # set tooltip
        tooltip = wttext
        if debug_mode():
            tooltip += "<br>"
            tooltip += path.path()

        contstr = ""
        if self.contentsValue() is not None:
            contstr = self._contentsText(self.path(), None, "parameters")
        if contstr:
            tooltip += "<hr>" + contstr

        self.setToolTip(tooltip)

        # set what's this
        # - add native doc string if present
        docs = path.keyword().udocstring
        if docs:
            wttext = wttext + "<hr>" + docs

        # - add value type and default value information if present
        typeinfo = self._typeInformation()
        if typeinfo:
            listinfo = self._listInformation()
            if listinfo:
                typeinfo += "<br>" + listinfo
            wttext = wttext + "<hr>" + typeinfo
        definfo = self._defaultInformation()
        if definfo:
            wttext = wttext + "<br>" + definfo

        # - add rules description if present
        rules = self.rules()
        if rules:
            rulelines = []
            for rule in rules:
                # translate rule
                line = bold(translate_rule(rule.itemName()))
                kw_list = []
                for kword in rule.ruleKeywords():
                    if name == kword:
                        kw_list.append(font(kword, color="#0000ff"))
                    else:
                        kw_list.append(kword)
                line = line + ": " + ", ".join(kw_list)
                rulelines.append(line)
            wttext = wttext + "<hr>" + "<br>".join(rulelines)

        # - finally assign what's this info
        self.setWhatsThis(wttext)

    def path(self):
        """
        Get path assigned to the label.

        Returns:
            ParameterPath: Parameter path.
        """
        return self._path

    def rules(self):
        """
        Get rules assigned to the label.

        Returns:
            list[ParameterRuleItem]: Parameter rules.
        """
        return self._rules

    def match(self, text):
        """
        Check if label matches search criterion.

        Arguments:
            text (str): Regular expression.

        Returns:
            bool: *True* if label matches search criterion; *False*
            otherwise.
        """
        regex = Q.QRegExp(text, Q.Qt.CaseInsensitive)
        return regex.indexIn(self._titlelabel.text()) != -1 or \
            regex.indexIn(self.path().name()) != -1

    def minimumSizeHint(self):
        """
        Get size hint for the label.

        Returns:
            QSize: Label's size hint.
        """
        size = super().minimumSizeHint()
        if self.path().name().isdigit():
            size.setWidth(self.fontMetrics().width("[000]"))
        else:
            size.setWidth(100)
        return size

    def sizeHint(self):
        """
        Get size hint for the label.

        Returns:
            QSize: Label's size hint.
        """
        size = super().sizeHint()
        if self.path().name().isdigit():
            size.setWidth(self.fontMetrics().width("[000]"))
        else:
            size.setWidth(100)
        return size

    # pragma pylint: disable=unused-argument
    def mousePressEvent(self, event):
        """
        Reimplemented event to link the QLabel with the related radiobutton or
        checkbox.
        """
        self.clicked.emit()

    def showEvent(self, e):
        """
        Reimplemented event to update messages when label is shown.
        """
        super().showEvent(e)
        self.updateTranslations()

    def _typeInformation(self):
        """
        Gets the information text about keyword type.
        """
        inflist = []
        kword = self.path().keyword()
        if kword is not None:
            kwtypelist = []
            kwdef = kword.definition
            enum = kwdef.get('into') is not None
            if enum and sorted(kwdef.get('into')) == ["NON", "OUI"]:
                txt = "'%s'/'%s'" % (bold(translate("ParameterPanel", "Yes")),
                                     bold(translate("ParameterPanel", "No")))
                inflist.append(txt)
            elif kwdef.get('typ') is not None:
                kwtypelist = to_list(kwdef.get('typ'))

            for kwtype in kwtypelist:
                if kwtype is None:
                    continue

                if kwtype == 'I':
                    txt = bold(translate("ParameterPanel", "integer"))
                    lim = self._numberLimitsInfo(kwdef.get('val_min'),
                                                 kwdef.get('val_max'))
                    if lim:
                        txt += " " + lim
                elif kwtype == 'R':
                    txt = bold(translate("ParameterPanel", "float"))
                    lim = self._numberLimitsInfo(kwdef.get('val_min'),
                                                 kwdef.get('val_max'))
                    if lim:
                        txt += " " + lim
                elif kwtype == 'TXM':
                    txt = bold(translate("ParameterPanel", "string"))
                elif is_subclass(kwtype, CATA.package('DataStructure').CO):
                    txt = bold(translate("ParameterPanel", "macro name"))
                elif isinstance(kwtype, type):
                    txt = translate("ParameterPanel", "object with type")
                    txt += bold(" '%s'" % kwtype.__name__)
                else:
                    txt = bold(str(kwtype))

                if txt:
                    if enum:
                        txt += " (%s)" % italic(translate("ParameterPanel",
                                                          "enumerated"))
                    inflist.append(txt)
        info = ""
        if inflist:
            islist = self.path().isKeywordSequence() and \
                not self.path().isInSequence()
            prefix = translate("ParameterPanel", "List with types") \
                if islist else translate("ParameterPanel", "Value types")
            info = prefix + ": " + ", ".join(inflist)
        return info

    def _listInformation(self):
        """
        Gets the information text about keyword type list limits.
        """
        info = ""
        if self.path().isKeywordSequence() and \
                not self.path().isInSequence():
            kword = self.path().keyword()
            if kword is not None:
                kwdef = kword.definition
                min_limit = kwdef.get('min')
                max_limit = kwdef.get('max') \
                    if kwdef.get('max') != '**' else None
                lim = self._numberLimitsInfo(min_limit, max_limit, True, False)
                if lim:
                    info = " "  + translate("ParameterPanel",
                                            "List length should be") + lim
        return info

    # pragma pylint: disable=no-self-use
    def _numberLimitsInfo(self, vmin, vmax, inclusive=True, allowrange=True):
        """
        Format min, max limits information into human readable string.
        """
        txt = ""
        if allowrange and vmin is not None and vmax is not None:
            txt += " " + translate("ParameterPanel", "in range")
            if inclusive:
                txt += " [%s, %s]" % (italic(bold(str(vmin))),
                                      italic(bold(str(vmax))))
            else:
                txt += " (%s, %s)" % (italic(bold(str(vmin))),
                                      italic(bold(str(vmax))))
        else:
            if vmin is not None:
                if inclusive:
                    txt += " " + translate("ParameterPanel", "not less than")
                else:
                    txt += " " + translate("ParameterPanel", "greater than")
                txt += " " + italic(bold(str(vmin)))
            if vmax is not None:
                if txt:
                    txt += " " + translate("ParameterPanel", "and")
                if inclusive:
                    txt += " " + translate("ParameterPanel",
                                           "not greater than")
                else:
                    txt += " " + translate("ParameterPanel", "less than")
                txt += " " + italic(bold(str(vmax)))
        return txt

    def _defaultInformation(self):
        if not self.path().isKeywordSequence() or \
                self.path().isInSequence():
            kword = self.path().keyword()
            if kword is not None:
                if hasattr(kword, 'hasDefaultValue') \
                        and kword.hasDefaultValue():
                    return translate("ParameterPanel", "Default value: ") + \
                            italic(bold(str(kword.defaultValue())))
        return ""

    def _updateContents(self):
        """
        Updates the contents string.
        """
        self.updateTranslations()


class ParameterButton(ElidedButton, ContentData):
    """Helper class to display parameter's name."""

    def __init__(self, path, text, parent=None):
        """
        Create widget.

        Arguments:
            path (ParameterPath): Keyword's path.
            text (str): Button text.
            parent (Optional[QWidget]): Parent widget.
        """
        super().__init__(text, parent)
        self._path = path
        self._text = text

    def _updateContents(self):
        """
        Updates the contents string.
        """
        content = False
        self.setToolTip("")
        text = self._text

        mode = self.contentsMode()
        if mode is not None and mode != "none" and \
                self.contentsValue() is not None:
            content = True
            text = self._contentsText(self._path)
        contpal = self.palette()
        contpal.setColor(self.foregroundRole(), Q.Qt.darkBlue \
                             if content else Q.Qt.black)
        self.setPalette(contpal)

        self.setText(text)
        self.setToolTip(text)


class ParameterTitle(Q.QLineEdit):
    """Helper class to show a `path` for currently edited parameter."""

    def __init__(self, parent=None):
        """
        Create widget.

        Arguments:
            parent (Optional[QWidget]): Parent widget.
        """
        super().__init__(parent)
        self.setReadOnly(True)
        self.setFrame(False)

    def setTitle(self, names):
        """
        Set the path to the widget.

        Arguments:
           names (list[str]): Path components.
        """
        self.setText(" > ".join(names))
        self.end(False)


class ParameterItemHilighter(Q.QWidget):
    """
    Frame that highlight the item in view
    """
    def __init__(self, rect, parent=None):
        super().__init__(parent)
        self.setGeometry(rect)

    def paintEvent(self, pevent):
        """
        Paint event handler.
        Reimplemented for drawing rule group frames.
        """
        super().paintEvent(pevent)

        painter = Q.QPainter(self)
        rect = Q.QRect(0, 0, self.width(), self.height())
        rect.adjust(1, 1, -1, -1)
        painter.setPen(Q.Qt.red)
        painter.drawRect(rect)


class ParameterBaloon(Q.QWidget):
    """
    Frame that highlight the item in view
    """
    def __init__(self, parent=None):
        super().__init__(parent, Q.Qt.ToolTip)

        layout = Q.QGridLayout(self)
        layout.setSizeConstraint(Q.QGridLayout.SetFixedSize)
        self._title = Q.QLabel(self)
        layout.addWidget(self._title, 0, 0)

        line = Q.QLabel(self)
        line.setFrameStyle(Q.QLabel.Plain | Q.QLabel.HLine)
        layout.addWidget(line, 1, 0)

        self._message = Q.QLabel(self)
        layout.addWidget(self._message, 2, 0)

        self.setContentsMargins(5, 5, 5, 20)

    def title(self):
        """Returns title."""
        return self._title.text()

    def setTitle(self, txt):
        """Sets title."""
        self._title.setText(txt)
        self.updateGeometry()
        self.adjustSize()

    def message(self):
        """Returns message."""
        return self._message.text()

    def setMessage(self, txt):
        """Sets message."""
        self._message.setText(txt)
        self.updateGeometry()
        self.adjustSize()

    def setPositon(self, pos):
        """Sets the position."""
        self.move(pos.x() - self.sizeHint().width() / 2,
                  pos.y() - self.sizeHint().height())

    def resizeEvent(self, event):
        """Updates contour after resize."""
        super().resizeEvent(event)
        self._updateCountour()

    def paintEvent(self, event):
        """Paint contour."""
        super().paintEvent(event)
        ppath = self._contour()
        painter = Q.QPainter(self)
        painter.fillPath(ppath, Q.Qt.white)
        painter.setPen(Q.Qt.black)
        painter.drawPath(ppath)

    def _updateCountour(self):
        """Update countour."""
        ppath = self._contour()

        bmp = Q.QBitmap(self.size())
        bmp.fill(Q.Qt.color0)
        painter = Q.QPainter(bmp)
        painter.fillPath(ppath, Q.Qt.color1)
        painter.end()
        self.setMask(bmp)

    def _contour(self):
        """Returns contour path."""
        ppath = Q.QPainterPath()
        rect = self.contentsRect()
        margin = 5
        ppath.addRoundedRect(rect.left() - margin, rect.top() - margin,
                             rect.width() + 2 * margin,
                             rect.height() + 2 * margin, 15, 15)

        arrowpath = Q.QPainterPath()
        arrowpath.moveTo(rect.center().x(), self.height())
        arrowpath.lineTo(rect.center().x() - 10, rect.bottom())
        arrowpath.lineTo(rect.center().x() + 10, rect.bottom())
        arrowpath.lineTo(rect.center().x(), self.height())

        ppath = ppath.united(arrowpath)
        return ppath


class SpinWidget(Q.QWidget):
    """Spin buttons for up/down (increase/decrease) actions."""

    class SpinType:
        """Enumeration for spin types"""
        Decrease = 0
        Increase = 1
        Up = Decrease
        Down = Increase

    class Button(Q.QToolButton):
        """Internal button class for spin"""
        def sizeHint(self):
            """Reimplemented for internal reason"""
            sz = super(SpinWidget.Button, self).sizeHint()
            if self.parentWidget().layout().direction() \
                    == Q.QBoxLayout.TopToBottom:
                sz.setHeight(sz.height() / 2)
            return sz

        def minimuSizeHint(self):
            """Reimplemented for internal reason"""
            sz = super(SpinWidget.Button, self).minimuSizeHint()
            if self.parentWidget().layout().direction() \
                    == Q.QBoxLayout.TopToBottom:
                sz.setHeight(sz.height() / 2)
            return sz

    clicked = Q.pyqtSignal(int)

    def __init__(self, parent=None):
        super().__init__(parent)

        base = Q.QBoxLayout(Q.QBoxLayout.TopToBottom, self)
        base.setContentsMargins(0, 0, 0, 0)
        base.setSpacing(0)

        self._dec = SpinWidget.Button(self)
        self._dec.clicked.connect(self._onDecreaseClicked)
        self._dec.setObjectName("Decrease")

        self._inc = SpinWidget.Button(self)
        self._inc.clicked.connect(self._onIncreaseClicked)
        self._inc.setObjectName("Increase")

        base.addWidget(self._dec)
        base.addWidget(self._inc)

        self._updateButtons()

    def isSpinEnabled(self, spin):
        """
        Gets the enable/disable state of specified spin button

        Arguments:
            spin (SpinType): Spin button type

        Returns:
            bool: Button enable state
        """
        btn = self._spinButton(spin)
        return btn.isEnabled() if btn is not None else False

    def setSpinEnabled(self, spin, value):
        """
        Sets the enable/disable state of specified spin button

        Arguments:
            spin (SpinType): Spin button type
            value (bool): Button enable state
        """
        btn = self._spinButton(spin)
        if btn is not None:
            btn.setEnabled(value)

    def orientation(self):
        """
        Gets the orientation of spin buttons in control

        Returns:
            Qt.Orientation: Control orientation
        """
        direct = self.layout().direction()
        return Q.Qt.Horizontal if direct == Q.QBoxLayout.LeftToRight \
            else Q.Qt.Vertical

    def setOrientation(self, orient):
        """
        Sets the orientation of spin buttons in control


        Arguments:
            orient (Qt.Orientation): Control orientation
        """
        self.layout().setDirection(Q.QBoxLayout.LeftToRight \
                                       if orient == Q.Qt.Horizontal else \
                                       Q.QBoxLayout.TopToBottom)
        self._updateButtons()

    def _onDecreaseClicked(self):
        """
        Invoked when decrease button clicked.
        """
        self.clicked.emit(self.SpinType.Decrease)

    def _onIncreaseClicked(self):
        """
        Invoked when increase button clicked.
        """
        self.clicked.emit(self.SpinType.Increase)

    def _updateButtons(self):
        """
        Update button icons.
        """
        sz = Q.QSize(32, 32)
        if self.orientation() == Q.Qt.Vertical:
            sz.setHeight(sz.height() / 2)
        pix = Q.QPixmap(sz)
        pix.fill(Q.Qt.transparent)
        pnt = Q.QPainter(pix)
        pnt.setPen(Q.Qt.black)

        path = Q.QPainterPath()
        arrowwidth = pix.width() - 2 * 2
        arrowheight = min(arrowwidth / 2, pix.height() - 2 * 2)
        path.moveTo((pix.width() - arrowwidth) / 2,
                    (pix.height() - arrowheight) / 2)
        path.lineTo((pix.width() + arrowwidth) / 2,
                    (pix.height() - arrowheight) / 2)
        path.lineTo(pix.width() / 2, (pix.height() + arrowheight) / 2)
        path.lineTo((pix.width() - arrowwidth) / 2,
                    (pix.height() - arrowheight) / 2)
        pnt.fillPath(path, Q.Qt.black)
        pnt.end()

        self._inc.setIcon(Q.QIcon(pix))
        self._dec.setIcon(Q.QIcon(Q.QPixmap.fromImage(pix.toImage().mirrored())))

    def _spinButton(self, spin):
        """
        Gets the spin button by specified type.
        """
        btn = None
        if spin == self.SpinType.Decrease:
            btn = self._dec
        elif spin == self.SpinType.Increase:
            btn = self._inc
        return btn


class PlotWidget(Q.QWidget):
    """Plot widget to draw function curve."""

    class PlotCanvas(FigureCanvas):
        """Canvas the figure renders into."""

        def resizeEvent(self, event):
            """Overridden in order to correct negative size in the event."""
            w = event.size().width()
            h = event.size().height()
            FigureCanvas.resizeEvent(self, Q.QResizeEvent(Q.QSize(abs(w), abs(h)),
                                                          event.oldSize()))


    def __init__(self, view, parent=None):
        super().__init__(parent)
        self._view = view
        self.createPlot()
        self._view.functionChanged.connect(self.updatePlot)

    def setVisible(self, vis):
        """Show/hide the plot widget."""
        super().setVisible(vis)
        self.updatePlot()

    @Q.pyqtSlot()
    def updatePlot(self):
        """Is called to update plot with table data."""
        if self.isVisible():
            self.onDraw(self._view)

    def createPlot(self):
        """Creates plot and toolbar widgets"""
        self.fig = pyplot.figure()
        self.axes = self.fig.add_subplot(111)
        pyplot.subplots_adjust(bottom=0.15)

        self.canvas = self.PlotCanvas(self.fig)
        self.canvas.setParent(self)
        self.canvas.setFocusPolicy(Q.Qt.StrongFocus)
        self.canvas.setFocus()

        self.mpl_toolbar = NavigationToolbar(self.canvas, self)

        self.canvas.mpl_connect('key_press_event', self.onKeyPress)

        vbox = Q.QVBoxLayout()
        vbox.addWidget(self.mpl_toolbar)
        vbox.addWidget(self.canvas)  # the matplotlib canvas
        self.setLayout(vbox)

    @Q.pyqtSlot()
    def onDraw(self, table_item):
        """Draws table data on plot."""
        self.axes.cla()
        table_item.plot(self.axes)
        self.canvas.draw()

    @Q.pyqtSlot()
    def onKeyPress(self, event):
        """Implements the default mpl key press events described at
            http://matplotlib.org/users/navigation_toolbar.html\
            #navigation-keyboard-shortcuts"""
        key_press_handler(event, self.canvas, self.mpl_toolbar)


class HoverPopupWidget(Q.QToolButton):
    """
    Button that toggles between two or more states, provided by ``addAction()``.

    When user clicks on the button, it switches to the next state,
    and corresponding ``QAction`` is being triggered.

    A tooltip shows all availiable actions on mouse hover.
    """

    def __init__(self, parent):
        """Create widget."""
        super().__init__(parent)
        self.setToolButtonStyle(Q.Qt.ToolButtonIconOnly)
        self._current_action = None
        self.clicked.connect(self.select_next_action)

    def actionEvent(self, event):
        """Reimplemented from *QToolButton*.

        Arguments:
            event (QActionEvent)
        """
        if event.type() == Q.QEvent.ActionAdded:
            if self._current_action is None:
                self._current_action = self.actions()[-1]
            self.updateIcon()
            self.setToolTip('<br/>'.join([action.toolTip() for action in self.actions()]))

    @Q.pyqtSlot()
    def select_next_action(self):
        """Switches to the next action in list."""
        if self.actions():
            actions = self.actions() + self.actions()
            self._current_action = actions[actions.index(self._current_action)+1]
            self.updateIcon()
            self._current_action.trigger()

    def set_current_index(self, index):
        """
        Set current action.

        Arguments:
            index (int): Action index.

        Raises:
            IndexError: If index is out of range.
        """
        if index not in range(len(self.actions())):
            raise IndexError("action index out of range")
        action = self.actions()[index]
        if self._current_action != action:
            self._current_action = action
            self.updateIcon()
            self._current_action.trigger()

    @Q.pyqtSlot()
    def updateIcon(self):
        """
        After current action is changed, this slot is called to update button's icon accordingly.
        """
        try:
            self.setIcon(self._current_action.icon())
        except IndexError:
            self.setIcon(Q.QIcon())


class ValueOrVariableEditor(Q.QWidget):
    """
    Widget for either entering a value manually or selecting a preexisting variable.

    By default, it shows a ``QLineEdit`` with validators appropriate for given `typ`.
    A button in the right allows switching into another mode, in which user can select
    a ``Variable`` from a ``QComboBox``. The user can add new ``Variable`` in a separate
    panel by choosing dedicated option from combobox.
    """

    ICONS_BY_TYPE = {
        "I": "as_ico_number.png",
        "R": "as_ico_real.png",
        "C": "as_ico_complex.png",
    }

    TYPE_CONVERTERS = {
        "I": int,
        "R": float,
        "C": complex,
    }

    def __init__(self, parent, typ, command, variables):
        """
        Arguments:
            parent (QWidget): Parent widget.
            typ (str): Value type: `'I'`, `'R'`, `'C'`.
            command (Command): Command being edited.
            variables (list[Variable]): Initial list of variables.
        """
        super().__init__(parent)
        self.setObjectName('ValueOrVariableEditor')

        self.typ = typ
        self.command = command

        # Initialize layout for the widget
        layout = Q.QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.setLayout(layout)

        # Simple field for editing value
        self.lineedit = Q.QLineEdit()
        self.lineedit.setObjectName('ValueOrVariableEditor_LineEdit')
        if typ == 'I':
            self.lineedit.setValidator(Q.QIntValidator(self.lineedit))
        elif typ == 'R':
            self.lineedit.setValidator(Q.QDoubleValidator(self.lineedit))
        elif typ == 'C':
            regexp = Q.QRegExp(r'^\d+(\.\d+)?(\+\d+(\.\d+)?j)?$', self.lineedit)
            self.lineedit.setValidator(Q.QRegExpValidator(regexp))
        self.lineedit.returnPressed.connect(self._onReturnPressed)
        layout.addWidget(self.lineedit, 1)

        # Combobox for selecting a python variable
        self.variable_selector = Q.QComboBox(parent)
        self.variable_selector.setObjectName('ValueOrVariableEditor_VariableSelector')
        self.variable_selector.setVisible(False)
        self.variable_selector.addItem('<Add variable...>', None)
        self.variable_selector.activated.connect(self._onAddVariable)
        for var in variables:
            self.variable_selector.addItem(var.name, var)
        self.variable_selector.setCurrentIndex(-1)
        layout.addWidget(self.variable_selector, 1)

        # Switcher between two modes
        self.switcher = HoverPopupWidget(parent)
        self.switcher.setObjectName('ValueOrVariableEditor_Switcher')
        layout.addWidget(self.switcher)

        # Action 1: Activate lineedit
        icon_file = self.ICONS_BY_TYPE[typ]
        title = translate("ParameterPanel", "Enter real number")
        tooltip = image(CFG.rcfile(icon_file)) + wrap_html(" " + italic(title), "span")
        action = Q.QAction(load_icon(icon_file), title, self)
        action.setToolTip(tooltip)
        action.triggered.connect(self._activateLineEdit)
        self.switcher.addAction(action)

        # Action 2: Activate variable selector
        icon_file = "as_ico_variable.png"
        title = translate("ParameterPanel", "Select python variable")
        tooltip = image(CFG.rcfile(icon_file)) + wrap_html(" " + italic(title), "span")
        action = Q.QAction(load_icon(icon_file), title, self)
        action.setToolTip(tooltip)
        action.triggered.connect(self._activateVariableSelector)
        self.switcher.addAction(action)

        # When widgets is focused, focus must actually go to either lineedit or variable selector.
        # By default, it goes to lineedit.
        # The proxy can be changed by _activateLineEdit() or _activateVariableSelector().
        self.setFocusProxy(self.lineedit)

        # For some reason, newly created widget seems to sometimes lose focus
        # immediately after creation. So, we schedule to set it back.
        Q.QTimer.singleShot(0, self.setFocus)

    @Q.pyqtSlot()
    def _activateLineEdit(self):
        """Show lineedit, hide combobox, update focus."""
        self.lineedit.show()
        self.lineedit.setFocus()
        self.setFocusProxy(self.lineedit)
        self.variable_selector.hide()

    @Q.pyqtSlot()
    def _activateVariableSelector(self):
        """Show combobox, hide lineedit, update focus."""
        self.variable_selector.show()
        self.variable_selector.setFocus()
        self.setFocusProxy(self.variable_selector)
        self.lineedit.hide()

    @Q.pyqtSlot()
    def _onReturnPressed(self):
        """
        On lineedit's Enter key event, create identical event for the whole widget.

        This is needed for table to understand how user ended editing: by pressing Enter or Tab.
        """
        event = Q.QKeyEvent(Q.QEvent.KeyPress, Q.Qt.Key_Enter, Q.Qt.NoModifier)
        self.setFocus()
        Q.QApplication.sendEvent(self, event)

    def setData(self, data):
        """
        Set a value or a variable to the widget.

        Value can be given in form of `int`, `float` or `complex`.
        Variable can be given in form of instance of `Variable` or its name as `str`.
        """
        # Convert variable name to variable itself
        if isinstance(data, str):
            for var in self.command.groupby(self.typ):
                if var.name == data:
                    data = var
                    break

        # Process a Variable
        if isinstance(data, Variable):
            self.switcher.set_current_index(1)
            self.lineedit.clear()
            self.variable_selector.setCurrentText(data.name)
            self._activateVariableSelector()

        # Process a number
        elif data is not None:
            data = self.TYPE_CONVERTERS[self.typ](data)
            self.switcher.set_current_index(0)
            self.lineedit.setText(str(data))
            self._activateLineEdit()

        # Leave widget empty
        else:
            self.switcher.set_current_index(0)
            self.lineedit.clear()
            self._activateLineEdit()

    def data(self):
        """Get value entered by user or ``Variable`` choosen by user."""
        if self.variable_selector.isVisible():
            return self.variable_selector.currentData()

        text = self.lineedit.text()
        if text == '':
            return None

        if self.typ == 'I':
            return int(text)
        if self.typ == 'R':
            return float(text)
        if self.typ == 'C':
            return complex(text)
        return text

    @Q.pyqtSlot(int)
    def _onAddVariable(self, index):
        """
        Open "Add Variable" panel.

        Arguments:
            index (int): Combo box item's index.
        """
        item_data = self.variable_selector.itemData(index, Q.Qt.UserRole)
        if item_data is not None:
            return

        parampanel = parameterPanel(self)
        astergui = parampanel.astergui()
        varpanel = VariablePanel(astergui, owner=parampanel)
        varpanel.stage = self.command.stage
        varpanel.destroyed.connect(self._onAddVariableFinished)
        parampanel.registerChildPanel(varpanel)
        astergui.workSpace().panel(Panel.Edit).setEditor(varpanel)

    @Q.pyqtSlot()
    def _onAddVariableFinished(self):
        """
        When "Add variable" dialog is closed, refresh list and select the new variable.
        """
        # Find all variables that existed before
        existing = set()
        for i in range(self.variable_selector.count()):
            item_data = self.variable_selector.itemData(i, Q.Qt.UserRole)
            if isinstance(item_data, Variable):
                existing.add(item_data)

        # Add variables that haven't existed before
        for x in self.command.groupby(self.typ):
            if isinstance(x, Variable) and x not in existing:
                self.variable_selector.addItem(x.name, x)
                self.variable_selector.setCurrentText(x.name)
