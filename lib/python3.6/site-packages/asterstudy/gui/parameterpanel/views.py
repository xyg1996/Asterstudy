# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Parameters Panel Views
----------------------

Implementation of the Parameters panel views for different cases.

"""


import re
from collections import OrderedDict

import numpy
from PyQt5 import Qt as Q

from .. import ActionType, clipboard_text
from ...common import (MeshElemType, MeshGroupType, common_filters, connect,
                       debug_mode, get_cmd_groups, get_cmd_mesh, get_file_name,
                       is_child, is_medfile, is_reference, is_subclass,
                       is_valid_group_name, load_icon, translate)
from ...datamodel import CATA
from ...datamodel.command import Variable
from ...datamodel.command.helper import avail_meshes
from ..behavior import behavior
from ..widgets import FilterWidget, MessageBox
from .basic import CataInfo, IntervalType, Options, parameterPanel
from .items import ParameterBlockItem, ParameterListItem
from .path import ParameterPath
from .widgets import ParameterItemHilighter, ValueOrVariableEditor

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name

# pragma pylint: disable=too-many-lines,too-many-branches

class ParameterView(FilterWidget, ParameterBlockItem):
    """Top-level parameters editor item."""

    ensureVisible = Q.pyqtSignal(Q.QRect)
    """
    Signal: emitted when item rect should be visible.

    Arguments:
        rect (QRect): Item's rect.
    """

    checkConstraints = Q.pyqtSignal(ParameterPath)
    """
    Signal: emitted when constrants of current list should be checked.

    Arguments:
        bool: Enable state.
    """

    appendEnabled = Q.pyqtSignal(bool)
    """
    Signal: emitted when append enabled/disabled for current list.

    Arguments:
        bool: Enable state.
    """

    editContextChanged = Q.pyqtSignal(str)
    """
    Signal: emitted when edit context was changed.

    Arguments:
        str: Context type.
    """

    valuesChanged = Q.pyqtSignal()
    """
    Signal: emitted when any value in panel was changed.

    Arguments:
        str: Context type.
    """

    gotoParameter = Q.pyqtSignal(ParameterPath, str)
    """
    Signal: emitted when parameter's sub-editor is activated.

    Arguments:
        uid (int): Parameter's UID.
    """

    class GridLayout(Q.QGridLayout):
        """
        Extended grid layout.
        """
        def __init__(self, parent=None):
            """Constructor"""
            super(ParameterView.GridLayout, self).__init__(parent)
            self._rows = None
            self._cols = None

        def actualRowCount(self):
            """Gets the actual row count in grid"""
            if self._rows is None:
                last = -1
                for row in range(self.rowCount() - 1, -1, -1):
                    for col in range(self.columnCount()):
                        if self.itemAtPosition(row, col) is not None:
                            last = row
                            break
                    if last != -1:
                        break
                self._rows = last + 1
            return self._rows

        def actualColumnCount(self):
            """Gets the actual column count in grid"""
            if self._cols is None:
                last = -1
                for col in range(self.columnCount() - 1, -1, -1):
                    for row in range(self.rowCount()):
                        if self.itemAtPosition(row, col) is not None:
                            last = col
                            break
                    if last != -1:
                        break
                self._cols = last + 1
            return self._cols

        def invalidate(self):
            """Reimplemented for internal reason"""
            super(ParameterView.GridLayout, self).invalidate()
            self._rows = None
            self._cols = None


    def __init__(self, panel, **kwargs):
        """
        Create view.

        Arguments:
            **kwargs: Arbitrary keyword arguments.
        """
        self._frames = []
        self._cache = None
        self._panel = panel

        super().__init__(**kwargs)

        self._initDependancies()
        self.appendTo()

        connect(self.checkConstraints, self._checkConstraints)

        self.itemStateChanged(self)

    def grid(self):
        """
        Create and return top-level grid layout to arrange child items.

        Returns:
            QGridLayout: Layout for widgets.
        """
        if self.layout() is None:
            grid = self.GridLayout()
            grid.setSpacing(10)
            extlist = behavior().external_list
            if self.isItemList() and not extlist:
                grid.setColumnStretch(self.ColumnId.Label, 0)
                grid.setColumnStretch(self.ColumnId.Editor, 1)
            else:
                grid.setColumnStretch(self.ColumnId.Label, 1)
                grid.setColumnStretch(self.ColumnId.Editor, 0)
            self.setLayout(grid)
            self._updateGrid()
        return self.layout()

    def panel(self):
        """
        Gets the panel which view belongs to.

        Returns:
            (ParameterPanel): Parent panel object
        """
        return self._panel

    def reorder(self, items):
        """
        Reorder items.

        Arguments:
            items (list[ParameterItem]): Child items.

        Returns:
            list[ParameterItem]: Reordered child items.
        """
        r_dict = {}
        r_items = []
        for rule in self.itemRules(True):
            if rule.isGrouped():
                r_items.append(rule)
                r_dict[rule] = 0
                for i in rule.childItems():
                    r_dict[i] = 0

        m_items = []
        o_items = []
        for item in items:
            if item not in r_dict:
                if item.isKeywordMandatory():
                    m_items.append(item)
                else:
                    o_items.append(item)

        return r_items + m_items + o_items

    def filter(self, text):
        """
        Apply filter.

        Arguments:
            text (str): Regular expression.
        """
        self.filterItem(text)

    def setItemValue(self, values):
        """
        Set values of child items.

        Arguments:
            values: Dictionary with item values (see `childValues()`).
        """
        super().setItemValue(values)

        self.updateCondition()
        self.updateConditions()
        self.itemStateChanged(self)
        self._cache = self.itemValue()

    def hasModifications(self):
        """
        Returns 'True' if view has modifications.
        """
        return self._cache != self.itemValue()

    def validate(self):
        """
        Perform value validation.

        Returns:
           bool: Validation status: True if value is valid; False
           otherwise.
        """
        state = True
        checker = CATA.package('Syntax').SyntaxCheckerVisitor()
        cond_context = self.conditionStorage(with_default=True)
        # conditionStorage returns values for simple keyword
        if isinstance(cond_context, dict):
            checker.set_parent_context(cond_context)

        exc_message = []
        try:
            self.keyword().accept(checker, self.itemValue())
        except Exception as exc: # pragma pylint: disable=broad-except
            from traceback import format_exc
            exc_message.append("Raw output message:\n{}\n".format(exc.args[0]))
            if debug_mode():
                exc_message.append("\n" + format_exc())
            state = False

        if state:
            return True

        rule = None
        stack = checker.stack
        if stack and not isinstance(stack[-1], str):
            rule = stack.pop()

        item = self
        while stack:
            for i in item.findItemsByName(stack.pop(0)):
                if not i.testFlags(self.ItemFlags.Filtered) and \
                        not i.testFlags(self.ItemFlags.Excluded):
                    item = i
                    break

#        pos = self.contentsRect().center()
        msgInfo = []
        hiframe = None
        if item is not None and item != self:
            rect = item.itemRect()
            space = self.grid().spacing() / 2
            rect.adjust(-space, -space, space, space)
            self.ensureVisible.emit(rect)
#            pos = rect.center()

            hiframe = ParameterItemHilighter(rect, self)
            hiframe.show()
            kwtext = Options.translate_command(item.command().title,
                                               item.itemName())
            msgInfo.append(translate("ParameterPanel",
                                     "Invalid input in {0}.").format(kwtext))
        else:
            msgInfo.append(translate("ParameterPanel", "Invalid input."))

        if rule is not None:
            rulemsg = translate("ParameterPanel", "Not respected the rule: {0}"
                                                  " with keywords: {1}.")
            msgInfo.append(rulemsg.format(type(rule).__name__,
                                          ", ".join(rule.ruleArgs)))

        msgInfo.append(translate("ParameterPanel",
                                 "Do you want to save the changes any way?"))

#        balloon = ParameterBaloon(self)
#        balloon.setTitle(translate("ParameterPanel", "Error"))
#        balloon.setMessage("<br>".join(msg))
#        balloon.setPositon(self.mapToGlobal(pos))
#        balloon.show()

        details = " ".join(exc_message)
        answer = MessageBox.question(self,
                                     translate("ParameterPanel", "Error"),
                                     "\n".join(msgInfo),
                                     Q.QMessageBox.Yes | Q.QMessageBox.No,
                                     Q.QMessageBox.Yes, detailedText=details)

        if hiframe is not None:
            hiframe.hide()

        return answer == Q.QMessageBox.Yes

    def setUnusedVisibile(self, state):
        """
        Sets the visibility of unsed items in the view.

        Arguments:
            state (bool): visibility state for unsed items.
        """
        items = self.childItems(all=True)
        for item in items:
            item.modifyFlags(self.ItemFlags.HideUnused, not state)

    def createItem(self):
        """
        Create, append to list and show item.
        """
        nb_child = len(self.childItems())
        new_num = 0
        if nb_child > 0:
            last = self.childItems()[nb_child - 1]
            new_num = int(last.itemName()) + 1
        item = ParameterListItem(item_path=self.itemPath().
                                 absolutePath(str(new_num)),
                                 parent_item=self)
        item.appendTo()

        for i in self.childItems():
            i.updateItem()

        self.updateTranslations()
        self.itemStateChanged(self)

    def deleteItem(self, item):
        """
        Delete the specified item.

        Arguments:
            item (ParameterItem): Moved item
        """
        item.removeFrom()
        self.removeChildItem(item)
        item.cleanup()

        for idx, child in enumerate(self.childItems()):
            child.itemPath().rename(str(idx))
            child.updateTranslations()
            child.updateItem()

        self.updateTranslations()
        self.itemStateChanged(self)

    def moveItem(self, item, step):
        """
        Move the specified item by the given step.

        Arguments:
            item (ParameterItem): Moved item
            step (int): Move offset
        """
        self.removeFrom()
        self.moveChildItem(item, step)
        for idx, child in enumerate(self.childItems()):
            child.itemPath().rename(str(idx))
            child.updateTranslations()
        self.appendTo()

    def appendFrame(self, frame):
        """
        Append the specified frame into view.

        Arguments:
            frame (asterstudy.gui.parameterpanel.items.Frame)
        """
        if not self._frames.__contains__(frame):
            self._frames.append(frame)
            self._updateGrid()
            self.update()

    def parameterActivated(self, path, link=''):
        """
        Called when item's sub-editor is activated.

        Arguments:
            obj (Parameter): Command's parameter.
        """
        self.gotoParameter.emit(path, link)

    def itemStateChanged(self, item):
        """
        Called when item state is changed.

        Arguments:
            item (ParameterItem): changed item.
        """
        self.checkConstraints.emit(item.itemPath())

    def valueChanged(self):
        """Called when item's value is changed."""
        super().valueChanged()
        self.valuesChanged.emit()

    def setVisible(self, visible):
        """
        Reimplemented for setting focus on view during showing process
        """
        if visible:
            for item in self.childItems(all=True):
                item.updateItem(True)

        super().setVisible(visible)
        self.setFocus(Q.Qt.OtherFocusReason)

    def eventFilter(self, obj, event):
        """
        Follow the mouse press events on it's child widget with disabled state.
        """
        if event.type() != Q.QEvent.MouseButtonPress:
            return False

        if hasattr(obj, "isEnabled") and not obj.isEnabled():
            if is_child(obj, self):
                if obj != self:
                    item = self.itemAt(self.mapFromGlobal(event.globalPos()))
                    if item is not None:
                        item.itemClicked(event)
                        return True
        return False

    def showEvent(self, event):
        """
        Show event handler.
        Reimplemented for install global event filter.
        """
        super().showEvent(event)
        Q.QApplication.instance().installEventFilter(self)

    def hideEvent(self, event):
        """
        Hide event handler.
        Reimplemented for remove global event filter.
        """
        super().hideEvent(event)
        Q.QApplication.instance().removeEventFilter(self)

    def paintEvent(self, pevent):
        """
        Paint event handler.
        Reimplemented for drawing rule group frames.
        """
        super().paintEvent(pevent)

        grid = self.grid()
        offset = grid.contentsMargins().left() / 2
        for frame in self._frames:
            # Get geometry of opening and closing widgets
            start_cell = grid.cellRect(frame.start_row, frame.start_column)
            finish_cell = grid.cellRect(frame.end_row, frame.end_column)

            # Draw a rectangle that spans from the opening widget to the closing one,
            # add some spacing to both sides horizontally
            # (but not vertically, since some space is already provided by those two widgets)
            rect = Q.QRect(start_cell.topLeft(), finish_cell.bottomRight())
            if rect.isValid():
                rect.adjust(-offset, 0, offset, 0)
                self._paintGroupBox(rect, frame.title)

    # pragma pylint: disable=unused-argument
    def _checkConstraints(self, path):
        """
        Called when `Add` or 'Delete' button is clicked in Edition panel
        during tuple parameter modification.
        """
        addstate = False
        if self.isItemList():
            defin = self.keyword().definition
            items = self.childItems()

            # check lower bound: min
            nb_min = defin.get('min', 0)
            for item in items:
                item.modifyFlags(self.ItemFlags.CantRemove,
                                 len(items) <= nb_min)

            # check upper bound: max
            nb_max = defin.get('max')
            addstate = nb_max is None or nb_max == "**" or len(items) < nb_max
        self.appendEnabled.emit(addstate)

    def _paintGroupBox(self, rect, title):
        painter = Q.QPainter(self)
        Q.qDrawShadeRect(painter, rect, self.palette(), True)

        if title:
            fnt = self.font()
            fnt.setPointSize(fnt.pointSize() - 1)
            offset = 5
            asterix = ' *'
            twidth = Q.QFontMetrics(fnt).width(title)
            awidth = Q.QFontMetrics(fnt).width(asterix)
            width = twidth + awidth + 2 * offset
            height = Q.QFontMetrics(fnt).height()
            rect = Q.QRect(rect.left() + 2 * offset,
                           rect.top() - height / 2 + 1, width, height)
            painter.fillRect(rect,
                             self.palette().color(self.backgroundRole()))
            painter.setFont(fnt)
            painter.drawText(Q.QRect(rect.left() + offset, rect.top(),
                                     twidth, rect.height()),
                             Q.Qt.AlignLeft, title)
            painter.setPen(Q.Qt.red)
            painter.drawText(Q.QRect(rect.left() + offset + twidth, rect.top(),
                                     awidth, rect.height()), Q.Qt.AlignRight,
                             asterix)

    def _updateGrid(self):
        """
        Updates the grid layout margins
        """
        self.grid().setContentsMargins(20 if self._frames else 5, 5,
                                       20 if self._frames else 5, 5)

    def _initDependancies(self):
        """
        Set the dependancies beetwin child items
        """
        table = CataInfo.keyword_dependancies()
        for key, value in table.items():
            item = self.findItemByPath(key)
            if item is not None:
                deps = value if isinstance(value, list) else [value]
                for dep in deps:
                    depitem = self.findItemByPath(dep)
                    if depitem is not None:
                        item.appendDependItem(depitem)

    def meshview(self):
        """
        Returns central view where mesh and groups should be displayed
        """
        return parameterPanel(self).meshview()


class ParameterTableView(ParameterView):
    """Table editor item."""

    class AbstractVOVDelegate(Q.QStyledItemDelegate):
        """
        Base class for item delegates that use ``ValueOrVariableEditor`` for editing.

        Actual value is always stored in the model with ``Qt::UserRole`` in every cell.
        Method ``setEditorData()`` just passes this value to the editor.
        Method ``setModelData()`` displays ``Variable`` instances by their names,
        and all other values by their values.

        Derived classes must implement ``createEditor()``
        returning a properly configured instance of ``ValueOrVariableEditor``.
        """

        def setEditorData(self, widget, index):
            """Reimplemented from ``QStyledItemDelegate``.

            Arguments:
                widget (ValueOrVariableEditor): Editor.
                index (PyQt5.QtCore.QModelIndex.QModelIndex): Model index.
            """
            # pylint: disable=no-self-use
            widget.setData(index.data(Q.Qt.UserRole))

        def setModelData(self, widget, model, index):
            """Reimplemented from ``QStyledItemDelegate``.

            Arguments:
                widget (ValueOrVariableEditor): Editor.
                model (PyQt5.QtCore.QAbstractItemModel.QAbstractItemModel): Model.
                index (PyQt5.QtCore.QModelIndex.QModelIndex): Model index.
            """
            # pylint: disable=no-self-use,unused-argument
            set_cell_value(index, widget.data())

        def destroyEditor(self, widget, index):
            """Reimplemented from ``QStyledItemDelegate``.
            Inform the parent ``Table`` that current cell is no longer being edited.

            Arguments:
                widget (ValueOrVariableEditor): Editor.
                index (PyQt5.QtCore.QModelIndex.QModelIndex): Model index.
            """
            # pylint: disable=no-self-use
            table = widget.parent().parent()
            table.resetCurrentlyEditing(index)

    class SimpleVOVDelegate(AbstractVOVDelegate):
        """
        Simple version of ``AbstractVOVDelegate``.

        Uses statically defined `typ` for variable type.
        """
        def __init__(self, parent, typ, command):
            super(ParameterTableView.SimpleVOVDelegate, self).__init__(parent)
            self.typ = typ
            self.command = command

        def createEditor(self, parent, option, index):
            """Gets list of availiable variables for current type and initializes editor."""
            # pylint: disable=unused-argument

            # Inform parent table that current index is being edited
            table = parent.parent()
            variables = list(reversed(self.command.groupby(self.typ)))
            editor = ValueOrVariableEditor(parent, self.typ, self.command, variables)
            table.currently_editing = index, editor
            return editor

    class DependentVOVDelegate(AbstractVOVDelegate):
        """
        A version of ``AbstractVOVDelegate`` with variable type dependent on cell from the left.

        Cell from the left is expected to have ``IntervalTypeDelegate``.
        """
        def __init__(self, parent, command):
            super(ParameterTableView.DependentVOVDelegate, self).__init__(parent)
            self.command = command

        def createEditor(self, parent, option, index):
            """Gets cell from the left and chooses variable type according to its value."""
            # pylint: disable=unused-argument

            # Inform parent table that current index is being edited
            table = parent.parent()

            typ_index = index.sibling(index.row(), 1)
            typ = IntervalType.str2value(typ_index.data())

            if typ in (IntervalType.NbSteps,):
                variables = list(reversed(self.command.groupby('I')))
                editor = ValueOrVariableEditor(parent, 'I', self.command, variables)
            else:
                variables = list(reversed(self.command.groupby('R')))
                editor = ValueOrVariableEditor(parent, 'R', self.command, variables)
            table.currently_editing = index, editor
            return editor

    class IntervalTypeDelegate(Q.QStyledItemDelegate):
        """
        A delegate for choosing one of two values: either "Number of steps" or "Step length".
        """

        def createEditor(self, parent, option, index):
            """Creates ``QComboBox`` with two options."""
            # pylint: disable=no-self-use,unused-argument
            widget = Q.QComboBox(parent)
            widget.addItem(IntervalType.value2str(IntervalType.NbSteps))
            widget.addItem(IntervalType.value2str(IntervalType.StepVal))
            return widget

        def setEditorData(self, widget, index):
            """
            Arguments:
                widget (QComboBox)
                index (QModelIndex)
            """
            # pylint: disable=no-self-use
            data = index.data()
            for i in range(widget.count()):
                if widget.itemText(i) == data:
                    widget.setCurrentIndex(i)
                    break

        def setModelData(self, widget, model, index):
            """
            Arguments:
                widget (QComboBox)
                model (QAbstractItemModel)
                index (QModelIndex)
            """
            # pylint: disable=no-self-use,unused-argument
            model.setData(index, widget.currentText(), Q.Qt.DisplayRole)
            model.setData(index, widget.currentText(), Q.Qt.UserRole)

    class Table(Q.QTableWidget):
        """Base table editor class."""

        valueChanged = Q.pyqtSignal()
        """Signal: emitted when table is changed."""

        def __init__(self, parent=None):
            super(ParameterTableView.Table, self).__init__(parent)
            self.setShowGrid(True)
            self.setAlternatingRowColors(True)
            self.horizontalHeader().setStretchLastSection(True)
            self.setSizePolicy(Q.QSizePolicy.Expanding, Q.QSizePolicy.Expanding)

            self.setRowCount(self.defaultRowCount())
            self.setColumnCount(self.headerCount())

            for i in range(self.rowCount()):
                self.initializeRow(i)

            connect(self.itemChanged, self._valueChanged)

            self.updateTranslations()

            self.currently_editing = None, None
            """
            If not `None`, contains ``QModelIndex`` of the cell that is currently edited by user.

            See also:
                resetCurrentlyEditing()
            """

        def defaultRowCount(self): # pragma pylint: disable=no-self-use
            """
            Get default number of table rows.

            Returns:
                int: Number of rows.
            """
            return 1

        def headerCount(self):
            """
            Get number of table columns.

            Returns:
                int: Number of columns.
            """
            return len(self.headers())

        def headers(self): # pragma pylint: disable=no-self-use
            """
            Get horizontal header's labels.

            Returns:
                list[str]: Table's labels.
            """
            return []

        def updateTranslations(self):
            """
            Update table headers.
            """
            self.setHorizontalHeaderLabels(self.headers())

        def moveCursor(self, cursor_action, modifiers):
            """
            Chooses next cell. Optionally creates new row. Optionally initializes editor.
            """
            # If we are in the last cell of the last row and trying to go gurther,
            # create new row and prepare index of its first cell
            if cursor_action == Q.QAbstractItemView.MoveNext \
            and self.currentRow() == self.rowCount() - 1 \
            and self.currentColumn() == self.columnCount() - 1:
                self.insertRow(self.rowCount())
                self.initializeRow(self.rowCount()-1)
                index = self.model().index(self.currentRow() + 1, 0)

            # For other cases, call default implementation
            else:
                index = super(ParameterTableView.Table, self).moveCursor(cursor_action, modifiers)

            # If previous cell was in editing mode right now,
            # we should initialize editing mode for the new cell, too
            if self.currently_editing[0] is not None:
                def _inner():
                    self.setCurrentIndex(index)
                    self.edit(index)
                Q.QTimer.singleShot(0, _inner)

            return index

        def validate(self):
            """
            Perform table validation.

            Returns:
                bool: *True* if all cells were filled in; *False* otherwise.
            """
            if self.currently_editing[1] is not None:
                key_event = Q.QKeyEvent(Q.QEvent.KeyPress, Q.Qt.Key_Enter, Q.Qt.NoModifier)
                Q.QApplication.sendEvent(self.currently_editing[1], key_event)
                Q.QApplication.sendPostedEvents()
            state = True
            empty_cells = self.findItems('', Q.Qt.MatchFixedString)
            if empty_cells:
                self.setCurrentItem(empty_cells[0])
                self.setFocus()
                state = False
            return state

        def value(self): # pragma pylint: disable=no-self-use
            """Get table's value."""
            return None

        def setValue(self, values): # pragma pylint: disable=no-self-use
            """Set table's value."""

        def setCellValue(self, row, column, value):
            """
            Shortcut for ``set_cell_value()``.
            """
            set_cell_value(self.model().index(row, column), value)

        def plot(self, plotter):
            """Plot data."""

        def initializeRow(self, row):
            """Initialize table row."""
            self.blockSignals(True)
            for col in range(self.columnCount()):
                self.setItem(row, col, Q.QTableWidgetItem(''))
            self.blockSignals(False)

        def _valueChanged(self, item): # pragma pylint: disable=unused-argument
            """
            Called when table data is changed. Emits *valueChanged()* signal.
            """
            self.valueChanged.emit()

        @staticmethod
        def factory(view):
            """Create appropriate table widget."""
            path = view.itemPath().path()
            if re.match("^.*INTERVALLE$", path):
                return ParameterTableView.IntervalTable.create(view)
            return ParameterTableView.FunctionTable.create(view)

        def resetCurrentlyEditing(self, index):
            """
            Forgets about which cell is being edited now.

            The private variable is cleared not right away but during next iteration of event loop.
            This ensures that other code is able to determine if the editor had been closed
            «right now» (during current iteration) or «long ago» (any time before).
            So when ``moveCursor()`` is called soon after ``AbstractVOVDelegate.destroyEditor()``,
            it can still see which editor has been destroyed.

            To clear the variable, you have to pass its current value to this method.
            This is to avoid accidental removal of value after it has already been changed.

            Arguments:
                index (PyQt5.QtCore.QModelIndex.QModelIndex)
            """
            @Q.pyqtSlot()
            def _inner():
                if self.currently_editing[0] == index:
                    self.currently_editing = None, None

            Q.QTimer.singleShot(0, _inner)

    class FunctionTable(Table):
        """Function table edition widget."""

        def __init__(self, parent=None):
            super(ParameterTableView.FunctionTable, self).__init__(parent)

            # Detect existing variables of current type
            table_view = self.parent()
            typ = table_view.keyword().definition.get('typ')
            command = table_view.command()

            # Create delegate
            self.setItemDelegate(ParameterTableView.SimpleVOVDelegate(self, typ, command))

        @staticmethod
        def create(view):
            """Create instance of FunctionTable widget."""
            table = ParameterTableView.FunctionTable(view)
            grid = view.grid()
            grid.setContentsMargins(0, 0, 0, 0)
            grid.addWidget(table, 0, 0, grid.rowCount(), grid.columnCount())
            return table

        def defaultRowCount(self):
            """Reimplemented from Table."""
            nb_rows = 1
            param_def = self.parent().keyword()
            nb_min = param_def.definition.get('min') if param_def else None
            if nb_min is not None:
                nb_cols = self.headerCount()
                if nb_min > nb_cols:
                    nb_rows = nb_min / nb_cols
            return nb_rows

        def headers(self):
            """Reimplemented from Table."""
            param_name = None
            func_name = None

            command = self.parent().command()
            path = self.parent().itemPath().path()
            item_name = self.parent().itemName()
            item = self.parent().rootItem()

            master = item.masterItem()
            if master is not None:
                parent_item = master.parentItem()
                if parent_item is not None:
                    for item in parent_item.childItems():
                        if not item.isUsed():
                            continue
                        if item.itemName() == 'NOM_PARA':
                            if item.itemValue():
                                param_name = \
                                    Options.translate_command(command.title,
                                                              item_name,
                                                              item.itemValue())
                        elif item.itemName() == 'NOM_RESU':
                            func_name = item.itemValue()
            labels = list()
            if not param_name:
                param_name = translate("ParameterPanel", "Parameter")
            labels.append(param_name)
            if re.match("^.*[.]VALE$", path) and \
                    not re.match("^[.]?DEFI_LIST", path):
                if not func_name:
                    func_name = translate("ParameterPanel", "Function")
                labels.append(func_name)
            elif re.match("^.*[.]VALE_C$", path):
                re_label = translate("ParameterPanel", "Real")
                im_label = translate("ParameterPanel", "Imaginary")
                if func_name:
                    re_label = func_name + ' ({})'.format(re_label)
                    im_label = func_name + ' ({})'.format(im_label)
                labels.append(re_label)
                labels.append(im_label)
            return labels

        def value(self):
            """Reimplemented from Table."""
            values = []
            for i in range(self.rowCount()):
                for j in range(self.columnCount()):
                    item = self.item(i, j)

                    # Save value from the item
                    # If there is no item in this place, save None
                    if item is not None:
                        val = item.data(Q.Qt.UserRole)
                    else:
                        val = None

                    values.append(val)
            return values

        def setValue(self, values):
            """Reimplemented from Table."""
            if values:
                self.blockSignals(True)
                nb_cols = self.columnCount()
                nb_rows = len(values) // nb_cols
                self.setRowCount(nb_rows)

                idx = 0
                for i in range(nb_rows):
                    for j in range(nb_cols):
                        self.setCellValue(i, j, values[idx])
                        idx += 1

                self.blockSignals(False)
            self.updateTranslations()

        def plot(self, plotter):
            """Reimplemented from Table."""
            labels = self.headers()
            values = self.value()
            nb_cols = len(labels) if labels else 1

            # Convert every variable to its value
            values = list(map(value_or_variable_evaluation, values))

            left_ext = self.parent().leftProlongation()
            right_ext = self.parent().rightProlongation()

            if not values:
                return

            if nb_cols == 1:
                x = tuple(values)

                nb_add = max(len(x) / 4, 1) if x else 0
                if len(x) > 1:
                    if left_ext in ('CONSTANT',) and x[0] is not None:
                        x = (x[0],) * nb_add + x
                    elif left_ext in ('LINEAIRE',) and None not in x[:2]:
                        x = tuple(x[0] + (x[0] - x[1]) * i \
                                      for i in range(nb_add, 0, -1)) + x
                    if right_ext in ('CONSTANT',) and x[-1] is not None:
                        x = x + (x[-1],) * nb_add
                    elif right_ext in ('LINEAIRE',) and None not in x[-2:]:
                        x = x + tuple(x[-1] + (x[-1] - x[-2]) * (i + 1) \
                                          for i in range(nb_add))

                plotter.plot(x, 'ko-')
                if left_ext in ('EXCLU',) and x is not None:
                    for i, j in enumerate(x):
                        if j is not None:
                            plotter.plot([i], [j], 'rx', markersize=10)
                            break
                if right_ext in ('EXCLU',) and x is not None:
                    for i, j in enumerate(reversed(x)):
                        if j is not None:
                            plotter.plot([len(x)-i-1], [j], 'rx', markersize=10)
                            break
            else:
                # convert [x1, y1, x2, y2] => [[x1, x2], [y1, y2]]
                values = numpy.reshape(values, (2, -1), order='F')
                x = tuple(values[0])
                y = tuple(values[1])

                nb_add = max(len(x) / 4, 1) if x else 0
                if len(x) > 1:
                    if left_ext in ('CONSTANT',) and None not in x[:2] \
                            and y[0] is not None:
                        x = tuple(x[0] + (x[0] - x[1]) * i \
                                      for i in range(nb_add, 0, -1)) + x
                        y = (y[0],) * nb_add + y
                    elif left_ext in ('LINEAIRE',) and None not in x[:2] \
                            and None not in y[:2] is not None:
                        x = tuple(x[0] + (x[0] - x[1]) * i \
                                      for i in range(nb_add, 0, -1)) + x
                        y = tuple(y[0] + (y[0] - y[1]) * i \
                                      for i in range(nb_add, 0, -1)) + y
                    if right_ext in ('CONSTANT',) and None not in x[-2:] \
                            and y[-1] is not None:
                        x = x + tuple(x[-1] + (x[-1] - x[-2]) * (i + 1) \
                                          for i in range(nb_add))
                        y = y + (y[-1],) * nb_add
                    elif right_ext in ('LINEAIRE',) and None not in x[-2:] \
                            and None not in y[-2:]:
                        x = x + tuple(x[-1] + (x[-1] - x[-2]) * (i + 1) \
                                          for i in range(nb_add))
                        y = y + tuple(y[-1] + (y[-1] - y[-2]) * (i + 1) \
                                          for i in range(nb_add))

                plotter.plot(x, y, 'ko-')
                if left_ext in ('EXCLU',) and x is not None:
                    for i, j in zip(x, y):
                        if None not in (i, j):
                            plotter.plot([i], [j], 'rx', markersize=10)
                            break
                if right_ext in ('EXCLU',) and x is not None:
                    for i, j in zip(reversed(x), reversed(y)):
                        if None not in (i, j):
                            plotter.plot([i], [j], 'rx', markersize=10)
                            break

            xlabel = ''
            ylabel = ''
            if labels:
                if len(labels) > 1:
                    xlabel = labels.pop(0)
                ylabel = labels.pop(0)
            plotter.set_xlabel(xlabel)
            plotter.set_ylabel(ylabel)

    class IntervalTable(Table):
        """Intervals table edition widget."""

        BarPlot = 0
        LinePlot = 1
        ShowLabels = 2

        def __init__(self, parent=None):
            super(ParameterTableView.IntervalTable, self).__init__(parent)

            # Detect existing variables, either integer or float
            table_view = self.parent()
            command = table_view.command()

            # Set different delegates for different columns of the table
            self.setItemDelegateForColumn(
                0, ParameterTableView.SimpleVOVDelegate(self, 'R', command))
            self.setItemDelegateForColumn(
                1, ParameterTableView.IntervalTypeDelegate(self))
            self.setItemDelegateForColumn(
                2, ParameterTableView.DependentVOVDelegate(self, command))

            self.ops = {}

            title = translate("IntervalTable", "Bar plot")
            action = Q.QAction(title, self)
            action.setToolTip(title)
            action.setStatusTip(title)
            action.setIcon(load_icon("as_pic_plot_bars.png"))
            action.setCheckable(True)
            action.setChecked(True)
            self.ops[self.BarPlot] = action

            title = translate("IntervalTable", "Line plot")
            action = Q.QAction(title, self)
            action.setToolTip(title)
            action.setStatusTip(title)
            action.setIcon(load_icon("as_pic_plot_lines.png"))
            action.setCheckable(True)
            self.ops[self.LinePlot] = action

            self._action_group = Q.QActionGroup(self)
            self._action_group.addAction(self.ops[self.BarPlot])
            self._action_group.addAction(self.ops[self.LinePlot])
            connect(self._action_group.triggered, self._updatePlot)

            title = translate("IntervalTable", "Show labels")
            action = Q.QAction(title, self)
            action.setToolTip(title)
            action.setStatusTip(title)
            action.setIcon(load_icon("as_pic_plot_labels.png"))
            action.setCheckable(True)
            action.setChecked(True)
            self.ops[self.ShowLabels] = action
            connect(action.toggled, self._updatePlot)

        @staticmethod
        def create(view):
            """Create instance of IntervalTable widget."""
            table = ParameterTableView.IntervalTable(view)
            table.toolbar = Q.QToolBar(view) # pragma pylint: disable=attribute-defined-outside-init
            table.toolbar.setToolButtonStyle(Q.Qt.ToolButtonIconOnly)
            table.toolbar.setOrientation(Q.Qt.Vertical)
            table.toolbar.setObjectName("IntervalTableToolbar")
            table.toolbar.addAction(table.ops[table.BarPlot])
            table.toolbar.addAction(table.ops[table.LinePlot])
            table.toolbar.addSeparator()
            table.toolbar.addAction(table.ops[table.ShowLabels])

            grid = view.grid()
            grid.setContentsMargins(0, 0, 0, 0)
            grid.setSpacing(5)
            grid.addWidget(table, 0, 0, grid.rowCount(), grid.columnCount())
            grid.addWidget(table.toolbar, 0, grid.columnCount(),
                           grid.rowCount(), 1)
            return table

        def defaultRowCount(self):
            """Reimplemented from Table."""
            param_def = self.parent().keyword()
            return param_def.definition.get('min', 1) if param_def else 1

        def headers(self):
            """Reimplemented from Table."""
            labels = []
            labels.append(translate("ParameterPanel", "Until"))
            labels.append(translate("ParameterPanel", "Interval type"))
            labels.append(translate("ParameterPanel", "Value"))
            return labels

        def value(self):
            """Reimplemented from Table."""
            values = []
            for i in range(self.rowCount()):
                dic = {}

                fin = self.item(i, 0).data(Q.Qt.UserRole)
                typ = IntervalType.str2value(self.item(i, 1).data(Q.Qt.UserRole))
                val3 = self.item(i, 2).data(Q.Qt.UserRole)

                if fin is not None:
                    dic['JUSQU_A'] = fin

                if typ is not None and val3 is not None:
                    if typ == IntervalType.NbSteps:
                        dic['NOMBRE'] = val3
                    elif typ == IntervalType.StepVal:
                        dic['PAS'] = val3

                values.append(dic)
            return values

        def setValue(self, values):
            """Reimplemented from Table."""
            if values:
                if isinstance(values, dict):
                    values = [values]
                self.blockSignals(True)
                self.setRowCount(len(values))

                for i, dic in enumerate(values):
                    fin = dic.get('JUSQU_A')
                    self.setCellValue(i, 0, fin)

                    if 'NOMBRE' in dic:
                        typ = IntervalType.NbSteps
                        val3 = dic['NOMBRE']
                    else:
                        typ = IntervalType.StepVal
                        val3 = dic.get('PAS')

                    self.setCellValue(i, 1, IntervalType.value2str(typ))
                    self.setCellValue(i, 2, val3)

                self.blockSignals(False)
            self.updateTranslations()

        def plot(self, plotter):
            """Reimplemented from Table."""
            debut = self.parent().debut()
            if debut is None:
                return

            if self.ops[self.BarPlot].isChecked():
                x = []
                steps = []
                widths = []

                for i in range(self.rowCount()):
                    fin = self.item(i, 0).data(Q.Qt.UserRole)
                    typ = IntervalType.str2value(self.item(i, 1).data(Q.Qt.UserRole))
                    val3 = self.item(i, 2).data(Q.Qt.UserRole)

                    fin = value_or_variable_evaluation(fin)
                    val3 = value_or_variable_evaluation(val3)

                    if fin is None or fin <= debut:
                        return
                    if val3 is None:
                        return

                    if typ == IntervalType.NbSteps:
                        if val3 < 1:
                            return
                    else:
                        val3 = int((fin - debut) / val3)
                        if debut + val3 * val3 < fin:
                            val3 = val3 + 1

                    x.append(debut)
                    steps.append(val3)
                    widths.append(fin-debut)

                    debut = fin

                plotter.bar(x, steps, width=widths, align='edge')
                if self.ops[self.ShowLabels].isChecked():
                    bbox = dict(fc='blue', alpha=0.3, boxstyle='round')
                    for i, val3 in enumerate(steps):
                        plotter.text(x[i] + widths[i]/2., val3, str(val3),
                                     ha='center', va='center', bbox=bbox)

                xlabel = translate("IntervalTable", "Interval range")
                plotter.set_xlabel(xlabel)
                ylabel = translate("IntervalTable", "Number of steps")
                plotter.set_ylabel(ylabel)

                last = x[-1] + widths[-1]
                plotter.set_xticks(x+[last])
                plotter.set_xticklabels([str(i) for i in x+[last]])

            else:
                values = []
                steps = []

                values.append(debut)
                for i in range(self.rowCount()):
                    fin = self.item(i, 0).data(Q.Qt.UserRole)
                    typ = self.item(i, 1).data(Q.Qt.UserRole)
                    val3 = self.item(i, 2).data(Q.Qt.UserRole)

                    fin = value_or_variable_evaluation(fin)
                    val3 = value_or_variable_evaluation(val3)

                    if fin is None:
                        return
                    if val3 is None:
                        return

                    if typ == IntervalType.NbSteps:
                        val3 = val3
                        if val3 < 1:
                            return

                    else:
                        val3 = val3
                        v1 = abs(fin - debut)
                        v2 = abs(fin - debut - val3)
                        if v1 < v2:
                            return

                        val3 = int((fin - debut) / val3)
                        if (fin > debut and debut + val3 * val3 < fin) \
                        or (fin < debut and debut + val3 * val3 > fin):
                            val3 = val3 + 1

                    values.append(fin)
                    steps.append(val3)

                    debut = fin

                plotter.plot(values, 'ko-')
                if self.ops[self.ShowLabels].isChecked():
                    bbox = dict(fc='blue', alpha=0.3, boxstyle='round')
                    for i, val3 in enumerate(steps):
                        x = i + 0.5
                        y = (values[i] + values[i+1]) / 2.
                        plotter.text(x, y, str(val3),
                                     ha='center', va='center', bbox=bbox)

                xlabel = translate("IntervalTable", "Interval index")
                plotter.set_xlabel(xlabel)
                ylabel = translate("IntervalTable", "Interval range")
                plotter.set_ylabel(ylabel)

                indices = [i for i in range(len(values))]
                plotter.set_xticks(indices)
                plotter.set_xticklabels(['%d'%i for i in indices])
                plotter.set_yticks(values)
                plotter.set_yticklabels([str(i) for i in values])

        def initializeRow(self, row):
            """Reimplemented from Table."""
            self.blockSignals(True)
            self.setItem(row, 0, Q.QTableWidgetItem(''))
            self.setItem(row, 1, Q.QTableWidgetItem(IntervalType.value2str(IntervalType.NbSteps)))
            self.setItem(row, 2, Q.QTableWidgetItem(''))
            self.blockSignals(False)

        def _updatePlot(self):
            """Update plot."""
            super(ParameterTableView.IntervalTable, self)._valueChanged(None)

        def _valueChanged(self, item):
            """Reimplemented from Table."""
            if item.column() == 1 and self.item(item.row(), 2) is not None:
                self.setCellValue(item.row(), 2, None)
            super(ParameterTableView.IntervalTable, self)._valueChanged(item)

    functionChanged = Q.pyqtSignal()
    """Signal: emitted when table is changed."""

    selectionChanged = Q.pyqtSignal()
    """Signal: emitted when table selection is changed."""

    def __init__(self, panel, **kwargs):
        """
        Create view.

        Arguments:
            **kwargs: Arbitrary keyword arguments.
        """
        super().__init__(panel, **kwargs)
        self.table = ParameterTableView.Table.factory(self)
        connect(self.table.valueChanged, self.valueChanged)
        connect(self.table.itemSelectionChanged, self.selectionChanged)

    def validate(self):
        """
        Validate user's input.
        See ParameterTableView.Table.validate().
        """
        return self.table.validate()

    def selectedRows(self):
        """
        Gets the selected rows.
        """
        return list(set(i.row() for i in self.table.selectedItems()))

    def plot(self, plotter):
        """Plot table's data."""
        self.table.plot(plotter)

    def updateTranslations(self):
        """
        Update translations.
        """
        self.table.updateTranslations()
        self.functionChanged.emit()

    def itemValue(self, **kwargs):
        """
        Get table values.

        Returns:
            list: List with all table values
        """
        childvalue = self.storage
        glob = kwargs['glob'] if 'glob' in kwargs else False
        if glob and self.slaveItem() is not None:
            childvalue = self.slaveItem().itemValue(**kwargs)
        else:
            value = self.table.value()
            if value is not None:
                childvalue = tuple(value)
                self.storage = childvalue
        return childvalue

    def setItemValue(self, values):
        """
        Set data to the table.

        Arguments:
            values: Dictionary with item values (see `childValues()`).
        """
        self.table.setValue(values)
        self.valueChanged()
        self.storage = values
        self._cache = self.itemValue()

    def valueChanged(self):
        """
        Called when item's value is changed.
        """
        super().valueChanged()
        self.functionChanged.emit()

    def columnCount(self):
        """Get number of columns in table."""
        return self.table.columnCount()

    def leftProlongation(self):
        """
        Get left prolongation type.

        Returns:
            str: Left prolongation enumerator.
        """
        context = self.conditionStorage(with_default=True)
        return context.get('PROL_GAUCHE')

    def rightProlongation(self):
        """
        Get right prolongation type.

        Returns:
            str: Right prolongation enumerator.
        """
        context = self.conditionStorage(with_default=True)
        return context.get('PROL_DROITE')

    def debut(self):
        """
        Get 'debut' value.

        Returns:
            float: Debut value.
        """
        context = self.conditionStorage(with_default=True)
        return context.get('DEBUT')

    def canImport(self):
        """Return *True* if data can be imported from file."""
        path = self.itemPath().path()
        return not re.match("^.*INTERVALLE$", path)

    def canPlot(self):
        """Return *True* if data can be plotted."""
        path = self.itemPath().path()
        return re.match("^.*[.](VALE|ABSCISSE|ORDONNEE|INTERVALLE)$", path)

    @Q.pyqtSlot()
    def importFile(self):
        """
        Called when 'Import from file' button is clicked.

        Allows to select file and fills in a table if any file was given.
        """
        # Begin an infinite loop (because user can make multiple attempts to choose a file)
        while True:
            # Show dialog to choose file
            title = translate("ParameterPanel", "Import table")
            filters = common_filters()
            filename = get_file_name(mode=1, parent=self.table, title=title,
                                     url="", filters=filters,
                                     dflt_filter=filters[2]) # "Text files"
            if not filename:
                return

            # Load data from file
            try:
                data = numpy.loadtxt(filename, delimiter=',')
                if data.size == 0:
                    return
            except BaseException as exc:  # pragma pylint: disable=broad-except
                Q.QMessageBox.critical(self.table, "AsterStudy", str(exc))
                return

            # Check for mismatch of column count
            file_cols = data.ndim
            nb_cols = self.table.columnCount()
            if file_cols != nb_cols:
                # Ask user if they are sure to continue regardless of the mismatch
                # If not, let them choose another file
                msg = translate("ParameterPanel",
                                "Number of columns in the file does not correspond"
                                " to the table dimension."
                                "\nDo you want to read this file anyway?")
                answer = Q.QMessageBox.question(self.table, "AsterStudy", msg)
                if answer != Q.QMessageBox.Yes:
                    continue

            # If everything is ok, finally replace table data and stop
            self.table.blockSignals(True)
            self.table.setRowCount(len(data))
            for i in range(len(data)):  # pragma pylint: disable=consider-using-enumerate
                for j in range(nb_cols):
                    if j < file_cols:
                        value = data[i, j] if file_cols > 1 else data[i]
                    else:
                        value = None
                    self.table.setCellValue(i, j, value)
            self.table.blockSignals(False)
            self.valueChanged()
            break

    @Q.pyqtSlot()
    def appendRow(self, activate=True):
        """
        Adds empty row to the end of table.
        """
        self._insertRow(self.table.rowCount(), activate)

    @Q.pyqtSlot()
    def insertRow(self):
        """
        Inserts empty row before selected one.
        """
        selected = [i.row() for i in self.table.selectedIndexes()]
        self._insertRow(min(selected) if selected else self.table.rowCount())

    @Q.pyqtSlot()
    def removeRows(self):
        """
        Remove selected rows.
        """
        # get selected rows
        selected = [i.row() for i in self.table.selectedIndexes()]
        selected = sorted(set(selected), reverse=True)
        if not selected:
            return
        # remove selected rows
        for row in selected:
            self.table.removeRow(row)
        # set selection
        if self.table.rowCount() > 0:
            row_to_select = min([selected[0], self.table.rowCount() - 1])
            self.table.setCurrentCell(row_to_select, 0)
        self.table.setFocus()
        self.valueChanged()

    @Q.pyqtSlot()
    def moveRowsUp(self):
        """
        Move selected rows up by one position.
        """
        self.moveRows(-1)

    @Q.pyqtSlot()
    def moveRowsDown(self):
        """
        Move selected rows down by one position.
        """
        self.moveRows(1)

    def moveRows(self, offset):
        """
        Move selected rows by specified offset.
        """
        selrows = self.selectedRows()
        if not selrows or not offset:
            return

        selitems = self.table.selectedItems()

        if offset > 0:
            selrows.reverse()

        moved = []

        chaged = False
        nb_rows = self.table.rowCount()
        nb_cols = self.table.columnCount()
        for row in selrows:
            pos = max(0, min(row + offset, nb_rows - 1))
            if pos != row and pos not in moved:
                trg = pos if offset < 0 else pos + 1
                src = row if offset > 0 else row + 1
                self.table.insertRow(trg)
                for col in range(nb_cols):
                    self.table.setItem(trg, col, self.table.takeItem(src, col))
                self.table.removeRow(src)
                chaged = True
            else:
                pos = row
            moved.append(pos)

        self.table.clearSelection()
        for item in selitems:
            item.setSelected(True)

        if chaged:
            self.valueChanged()

    def canCopy(self):
        """Check if data can be copied to clipboard."""
        return self._single_range_selected() is not None

    def canCut(self):
        """Check if data can be cut to clipboard."""
        return self.canCopy()

    def canPaste(self): # pragma pylint: disable=no-self-use
        """Check if data can be pasted from clipboard."""
        return len(clipboard_text()) > 0

    def canClear(self):
        """Check if there is data to clear."""
        return len(self.table.selectedItems()) > 0

    def copy(self):
        """Copy selected data to clipboard."""
        if self.canCopy():
            self._copy_or_cut(False)

    def cut(self):
        """Cut selected data to clipboard."""
        if self.canCut():
            self._copy_or_cut(True)

    def paste(self):
        """Paste data from clipboard."""
        first_row = last_row = 0
        first_column = last_column = 0
        if self.table.selectionModel().hasSelection():
            selected = self._single_range_selected()
            if selected is None:
                msg = translate("ParameterPanel",
                                "Insert into multiple selection not possible")
                Q.QMessageBox.critical(self, "AsterStudy", msg)
                return
            first_row = selected.topRow()
            last_row = selected.bottomRow()
            first_column = selected.leftColumn()
            last_column = selected.rightColumn()
        elif self.table.currentItem() is not None:
            first_row = last_row = self.table.currentItem().row()
            first_column = last_column = self.table.currentItem().column()
        data = clipboard_text()
        if not data:
            return
        lines = [i for i in data.split('\n') if i]
        if not lines:
            return
        # total nb rows to insert is
        nb_rows = max(len(lines), (last_row - first_row + 1))
        last_row = first_row + nb_rows - 1

        nb_columns = max([len(i.split('\t')) for i in lines])
        last_column = min(max(last_column + 1, first_column + nb_columns),
                          self.table.columnCount()) - 1

        # Prepare list of variables
        typ = self.keyword().definition.get('typ')
        variables = {var.name: var for var in self.command().groupby(typ)}

        def _insert_row(_row, _index):
            _values = lines[_index].split('\t')
            if not _values:
                return
            if self.table.rowCount() < _row + 1:
                self.appendRow(False)
            _j = 0
            for _column in range(first_column, last_column + 1):
                value = _values[_j]
                if isinstance(_values[_j], str):
                    value = variables.get(value)
                self.table.setCellValue(_row, _column, value)

                _j = _j + 1 if _j < len(_values) - 1 else 0

        index = 0
        for i in range(nb_rows):
            _insert_row(first_row + i, index)
            index = index + 1 if index < len(lines) - 1 else 0

        self.table.clearSelection()
        selection = Q.QTableWidgetSelectionRange(first_row, first_column,
                                                 last_row, last_column)
        self.table.setRangeSelected(selection, True)

    def clear(self):
        """Clear data in selected cells."""
        items = self.table.selectedItems()
        for item in items:
            item.setText(None)

    def _single_range_selected(self):
        selected = self.table.selectedItems()
        if selected:
            first_row = min(i.row() for i in selected)
            last_row = max(i.row() for i in selected)
            first_column = min(i.column() for i in selected)
            last_column = max(i.column() for i in selected)
            for i in range(first_row, last_row + 1):
                for j in range(first_column, last_column + 1):
                    if not self.table.item(i, j).isSelected():
                        return None
            return Q.QTableWidgetSelectionRange(first_row, first_column,
                                                last_row, last_column)
        return None

    def _copy_or_cut(self, clear=False):
        rows = []
        selected = self._single_range_selected()
        if selected is None:
            return
        for i in range(selected.topRow(), selected.bottomRow() + 1):
            row = []
            for j in range(selected.leftColumn(), selected.rightColumn() + 1):
                row.append(self.table.item(i, j).text())
                if clear:
                    self.table.setCellValue(i, j, None)
            rows.append('\t'.join(row))
        if rows:
            data = '\n'.join(rows) + '\n'
            Q.QApplication.clipboard().setText(data, Q.QClipboard.Selection)
            Q.QApplication.clipboard().setText(data, Q.QClipboard.Clipboard)

    def _insertRow(self, row, activate=True):
        """Insert row at given position."""
        self.table.insertRow(row)
        self.table.initializeRow(row)
        if activate:
            item = self.table.item(row, 0)
            self.table.scrollTo(self.table.indexFromItem(item))
            self.table.setCurrentCell(row, 0)
            self.table.setFocus()


class ParameterMeshGroupView(ParameterView):
    """Top-level table editor item."""

    meshFileChanged = Q.pyqtSignal(str, str, float, bool)
    meshGroupCheck = Q.pyqtSignal(str, str, str, int)
    meshGroupUnCheck = Q.pyqtSignal(str, str, str, int)
    meshChanged = Q.pyqtSignal()
    """Signal: emitted when mesh is changed in the combo box."""

    ShowNormals = 0
    FitSelection = 1
    SelectGroups = 2

    def __init__(self, panel, **kwargs):
        """
        Create view.

        Arguments:
            **kwargs: Arbitrary keyword arguments.
        """
        super().__init__(panel, **kwargs)

        self.ops = {}

        action = Q.QAction(translate("AsterStudy", "&Show Normals"), self)
        action.setToolTip(translate("AsterStudy",
                                    "Show faces orientation vectors"))
        action.setStatusTip(translate("AsterStudy",
                                      "Show faces orientation vectors"))
        action.setIcon(load_icon("as_pic_show_normals.png"))
        action.setCheckable(True)
        connect(action.toggled, self._showNormals)
        self.ops[ParameterMeshGroupView.ShowNormals] = action

        action = Q.QAction(translate("AsterStudy", "&Fit Selection"), self)
        action.setToolTip(translate("AsterStudy", "Fit selection"))
        action.setStatusTip(translate("AsterStudy",
                                      "Fit view contents to selected groups"))
        action.setIcon(load_icon("as_pic_fit_selection.png"))
        connect(action.triggered, self._fitSelection)
        self.ops[ParameterMeshGroupView.FitSelection] = action
        # Add a side button for the group selection
        action = Q.QAction(translate("AsterStudy", "&Select Groups"), self)
        action.setToolTip(translate("AsterStudy",
                                    "Select groups from central view"))
        action.setStatusTip(translate("AsterStudy",
                                      "Select groups from central view"))
        action.setIcon(load_icon("as_pic_select_groups.png"))
        action.setCheckable(True)
        action.toggled.connect(self._selectGroups)
        self.ops[ParameterMeshGroupView.SelectGroups] = action

        self.setStretchable(True)

        # Add the radio button for all, points, edges, faces, volumes
        self._bgroup = Q.QButtonGroup(self)
        self._gbox = Q.QGroupBox(self)
        self._rbutton = []
        if self._meshGroupType() is MeshGroupType.GElement:
            tlist = MeshElemType.elem_types(MeshGroupType.GElement, True)
            for i, v in enumerate(tlist):
                self._rbutton.append(Q.QRadioButton(MeshElemType.value2str(v)))
                self._bgroup.addButton(self._rbutton[i], i)
            self._rbutton[0].setChecked(True)

        self._mesh = Q.QComboBox(self)
        self._mesh.setObjectName("MESH")

        self._toolbar = Q.QToolBar(self)
        self._toolbar.setToolButtonStyle(Q.Qt.ToolButtonIconOnly)
        self._toolbar.setObjectName("MeshGroupToolbar")

        self._toolbar.addAction(self.ops[ParameterMeshGroupView.ShowNormals])
        self._toolbar.addAction(self.ops[ParameterMeshGroupView.FitSelection])
        self._toolbar.addAction(self.ops[ParameterMeshGroupView.SelectGroups])

        self._msg = Q.QLabel(self)

        self._list = Q.QTreeWidget(self)
        self._list.setAllColumnsShowFocus(True)
        self._list.setSelectionMode(Q.QTreeWidget.ExtendedSelection)
        self._list.setColumnCount(2)
        self._list.setContextMenuPolicy(Q.Qt.CustomContextMenu)
        titles = []
        titles.append(translate("AsterStudy", "Name"))
        titles.append(translate("AsterStudy", "Size"))
        self._list.setHeaderLabels(titles)
        self._list.header().setSectionResizeMode(Q.QHeaderView.ResizeToContents)
        self._list.header().setStretchLastSection(True)

        manlabel = Q.QLabel(translate("ParameterPanel", "Manual selection"),
                            self)
        manlabel.setToolTip(translate("ParameterPanel",
                                      "Enter manually the wanted groups if "
                                      "not present in the list"))
        self._manual = Q.QLineEdit(self)
        self._manual.setObjectName("MANUAL_INPUT")
        self._invalid_groups = []

        base = self.grid()
        hlayout = Q.QHBoxLayout()
        hlayout.setContentsMargins(0, 0, 0, 0)
        hlayout.setSpacing(5)
        hlayout.addWidget(self._mesh)
        hlayout.addWidget(self._toolbar)
        hlayout.setStretch(0, 10)
        base.addLayout(hlayout, 0, 0, 1, -1)

        hlayout = Q.QHBoxLayout()
        hlayout.setContentsMargins(0, 0, 0, 0)
        hlayout.setSpacing(5)
        for button in self._rbutton:
            hlayout.addWidget(button)
        hlayout.setStretch(0, 10)
        self._gbox.setLayout(hlayout)
        base.addWidget(self._gbox, 1, 0, 1, -1)
        self._gbox.hide()

        base.addWidget(self._msg, 2, 0, 1, -1)
        base.addWidget(self._list, 3, 0, 1, -1)
        base.addWidget(manlabel, 4, 0, 1, -1)
        base.addWidget(self._manual, 5, 0, 1, -1)

        connect(self._mesh.activated[int], self._meshActivated)
        self._updateMeshList()

        connect(self.meshFileChanged, self.meshview().displayMEDFileName)
        connect(self.meshGroupCheck, self.meshview().displayMeshGroup)
        connect(self.meshGroupUnCheck, self.meshview().undisplayMeshGroup)
        connect(self._list.itemChanged, self.meshGroupToChange)
        connect(self._list.itemSelectionChanged, self.meshGroupSelected)
        connect(self.meshview().selectionChanged, self.updateSelection)
        connect(self._list.customContextMenuRequested, self._popupMenuRequest)
        connect(self._manual.textChanged, self._manualChanged)

        # Connect Radio button with corresponding display
        self._bgroup.buttonClicked[int].connect(self._selectGroupType)

        normals_enabled = self.meshview().isFeatureSupported('normals') \
            and behavior().grp_global_cmd
        fit_enabled = self.meshview().isFeatureSupported('fit_objects')

        self.ops[ParameterMeshGroupView.ShowNormals].setVisible(normals_enabled)
        self.ops[ParameterMeshGroupView.FitSelection].setVisible(fit_enabled)
        self._toolbar.setVisible(normals_enabled or fit_enabled)

        normals_shown = self.meshview().allNormalsShown()
        self.ops[ParameterMeshGroupView.ShowNormals].setChecked(normals_shown)

    def meshList(self):
        """
        Gets the mesh commands list

        Returns:
            list (Command): List of commands with meshes.
        """
        mlist = []
        for i in range(self._mesh.count()):
            mlist.append(self._mesh.itemData(i).name)
        return mlist

    def setMeshList(self, meshlist):
        """
        Sets the mesh commands list

        Arguments:
            meshlist: List of commands with meshes.
        """
        self._mesh.clear()
        show_title = behavior().show_catalogue_name_in_selectors
        title_mask = '{n} ({t})' if show_title else '{n}'
        for meshcmd in meshlist:
            title = title_mask.format(n=meshcmd.name, t=meshcmd.title)
            self._mesh.addItem(title, meshcmd)

    def mesh(self):
        """
        Gets the currently selected mesh command object or None in error case.

        Returns:
            Command: Current mesh command object.
        """
        idx = self._mesh.currentIndex()
        return self._mesh.itemData(idx) if idx >= 0 else None

    def setMesh(self, mesh):
        """
        Sets the current mesh command object if it exists in the list.

        Arguments:
            mesh: Current mesh command object.
        """
        self._mesh.setCurrentIndex(self._mesh.findData(mesh))

    def message(self):
        """
        Gets the info message text.

        Returns:
            str: info message text.
        """
        return self._msg.text()

    def setMessage(self, msg):
        """
        Sets the info message text.

        Arguments:
            msg (str): info message text.
        """
        self._msg.setText(msg)
        self._msg.setVisible(len(msg) > 0)

    def setMeshGroups(self, groups):
        """
        Sets the mesh group list

        Arguments:
            groups (dict[int, list[tuple[str, int]]]): Mesh groups info.
        """
        self._list.clear()
        self._invalid_groups.clear()
        grp_types = sorted(groups.keys())
        invalid_icon = load_icon("as_pic_exclamation.png")
        invalid_tip = translate("ParameterPanel",
                                "Invalid group name: '{}'. "
                                "Please rename the group.")
        for typ in grp_types:
            names = groups[typ]
            if not names:
                continue
            title = MeshElemType.value2str(typ)
            item = Q.QTreeWidgetItem(self._list, [title])
            item.setFlags(Q.Qt.ItemIsEnabled)
            for name, size, occurs in names:
                is_valid = is_valid_group_name(name) and occurs == 1
                if occurs > 1:
                    self._invalid_groups.append(name)
                sub_item = Q.QTreeWidgetItem(item, [name, str(size)])
                flags = Q.Qt.ItemIsUserCheckable | Q.Qt.ItemIsSelectable
                if is_valid:
                    flags |= Q.Qt.ItemIsEnabled
                sub_item.setFlags(flags)
                sub_item.setCheckState(0, Q.Qt.Unchecked)
                sub_item.setTextAlignment(1, Q.Qt.AlignRight)
                if is_valid:
                    sub_item.setToolTip(0, name)
                else:
                    sub_item.setToolTip(0, invalid_tip.format(name))
                    sub_item.setIcon(0, invalid_icon)
        self._list.expandAll()
        if behavior().mesh_view_handle_selection:
            self.updateSelection()

    def inputMeshGroups(self):
        """
        Gets the mesh group names list entered manually

        Returns:
            list (str): List of group names.
        """
        text = self._manual.text().strip()
        return [i.strip() for i in text.split(",")] if text else []

    def setInputMeshGroups(self, groups):
        """
        Sets the mesh group list entered manually

        Arguments:
            groups: List of mesh group names.
        """
        self._manual.setText(",".join(groups))

    def selectedMeshGroups(self):
        """
        Gets the names of selected (checked) mesh groups.

        Returns:
            list (str): List of selected group names.
        """
        groups = []
        for i in range(self._list.topLevelItemCount()):
            item = self._list.topLevelItem(i)
            for j in range(item.childCount()):
                sub_item = item.child(j)
                if sub_item.checkState(0) == Q.Qt.Checked:
                    if sub_item.text(0) not in groups:
                        groups.append(sub_item.text(0))
        return groups

    def setSelectedMeshGroups(self, groups, clear=True):
        """
        Sets the specified group names are selected (checked)
        and unchecked all other if `clear`.

        Arguments:
            groups: List of selected mesh group names.
            clear: If *True*, unchecks all other
        """
        for i in range(self._list.topLevelItemCount()):
            item = self._list.topLevelItem(i)
            for j in range(item.childCount()):
                sub_item = item.child(j)
                if sub_item.text(0) in groups:
                    state = Q.Qt.Checked
                elif clear:
                    state = Q.Qt.Unchecked
                else:
                    continue
                sub_item.setCheckState(0, state)

    def highlightedMeshGroups(self):
        """
        Gets the names of highlighted (selected items) mesh groups.

        Returns:
            list (str): List of highlighted group names.
        """
        groups = []
        for i in range(self._list.topLevelItemCount()):
            item = self._list.topLevelItem(i)
            for j in range(item.childCount()):
                sub_item = item.child(j)
                if sub_item.isSelected():
                    groups.append(sub_item.text(0))
        return list(set(groups))

    @Q.pyqtSlot()
    def meshGroupSelected(self):
        """
        Called when selection is changed in a view.

        Emits `meshGroupCheck()` and `meshGroupUnCheck()` signal for
        each mesh group to display/undisplay it in a mesh view.
        Sets selection to a mesh view as well.
        """
        if not behavior().mesh_view_handle_selection:
            return
        meshcmd = self._meshcmd(self._mesh.currentIndex())
        if meshcmd is None:
            return
        file_name, nom_med = get_cmd_mesh(meshcmd)
        if file_name is None or nom_med is None:
            return
        selected = []
        for i in range(self._list.topLevelItemCount()):
            item = self._list.topLevelItem(i)
            for j in range(item.childCount()):
                sub_item = item.child(j)
                if sub_item.checkState(0) == Q.Qt.Checked or \
                        sub_item.isSelected():
                    self.meshGroupCheck.emit(file_name,
                                             nom_med,
                                             sub_item.text(0),
                                             self._meshGroupType())
                    if sub_item.isSelected():
                        selected.append((file_name,
                                         nom_med,
                                         sub_item.text(0),
                                         self._meshGroupType()))
                else:
                    self.meshGroupUnCheck.emit(file_name,
                                               nom_med,
                                               sub_item.text(0),
                                               self._meshGroupType())
        self.meshview().setSelected(selected)
        if self.filterPanel() is not None:
            self.filterPanel().applyFilter()

    def meshGroupToChange(self, item, column):
        """
        Called when mesh group item is checked ON/OFF.

        Emits `meshGroupCheck()` or `meshGroupUnCheck()` signal
        to display/undisplay given group in a mesh view.
        """
        if behavior().mesh_view_handle_selection:
            self.meshGroupSelected()
            return
        meshcmd = self._meshcmd(self._mesh.currentIndex())
        if meshcmd is not None:
            file_name, nom_med = get_cmd_mesh(meshcmd)
            if file_name is not None and nom_med is not None:
                if not self.ops[self.SelectGroups].isChecked():
                    if item.checkState(column) == Q.Qt.Checked:
                        self.meshGroupCheck.emit(file_name,
                                                 nom_med,
                                                 item.text(0),
                                                 self._meshGroupType())
                    # Do not hide in 'group selection' mode
                    if item.checkState(column) == Q.Qt.Unchecked:
                        self.meshGroupUnCheck.emit(file_name,
                                                   nom_med,
                                                   item.text(0),
                                                   self._meshGroupType())
                if self.ops[self.SelectGroups].isChecked():
                    index = self._bgroup.checkedId()
                    tlist = MeshElemType.elem_types(MeshGroupType.GElement,
                                                    True)
                    thetype = tlist[index]
                    self.meshview().setSelection(file_name,
                                                 nom_med,
                                                 self.selectedMeshGroups(),
                                                 self._meshGroupType(),
                                                 thetype)
        if self.filterPanel() is not None:
            self.filterPanel().applyFilter()

    def updateSelection(self):
        """Update selection in a view."""
        if not behavior().mesh_view_handle_selection:
            return
        selection = self.meshview().getSelected()
        blocked = self._list.blockSignals(True)
        self._list.clearSelection()
        for i in range(self._list.topLevelItemCount()):
            item = self._list.topLevelItem(i)
            for j in range(item.childCount()):
                if selection and item.child(j).text(0) in selection:
                    item.setSelected(True)
        self._list.blockSignals(blocked)
        if behavior().mesh_view_handle_selection:
            self.meshGroupSelected()

    def _meshcmd(self, index):
        """
        Returns the *Command* instance associated with the panel
        """
        meshcmd = None
        if 0 <= index < self._mesh.count():
            meshcmd = self._mesh.itemData(index)
        return meshcmd

    def itemValue(self, **kwargs):
        """
        Get selected values.

        Returns:
            tuple: List with all selected mesh groups
        """
        res = tuple(self.selectedMeshGroups() + self.inputMeshGroups())
        return res or None

    def setItemValue(self, values):
        """
        Set values of child items.

        Arguments:
            values: Tuple with item values (see `childValues()`).
        """
        grplist = []
        if values is not None:
            if isinstance(values, (tuple, list)):
                grplist = list(values)
            else:
                grplist = [values]
        self.setSelectedMeshGroups(grplist)
        check = dict.fromkeys(self.selectedMeshGroups())
        grplist = [grp for grp in grplist if grp not in check]
        self.setInputMeshGroups(grplist)
        self._cache = self.itemValue()

    def filterItem(self, text):
        """
        Filter out the item.

        Arguments:
            text (str): Regular expression.
        """
        gui = parameterPanel(self).astergui()
        hide_unused = gui.action(ActionType.HideUnused).isChecked()
        regex = Q.QRegExp(text, Q.Qt.CaseInsensitive)
        for i in range(self._list.topLevelItemCount()):
            item = self._list.topLevelItem(i)
            cnt_visible = 0
            for j in range(item.childCount()):
                sub_item = item.child(j)
                item_text = sub_item.text(0)
                hidden = text != "" and regex.indexIn(item_text) == -1
                hidden = hidden or \
                    sub_item.checkState(0) != Q.Qt.Checked and hide_unused
                sub_item.setHidden(hidden)
                if not hidden:
                    cnt_visible += 1
            item.setHidden(cnt_visible == 0)

    def setUnusedVisibile(self, state):
        """Redefined from *ParameterView* class."""
        super().setUnusedVisibile(state)
        if self.filterPanel() is not None:
            self.filterPanel().applyFilter()

    def _updateMeshList(self):
        """
        Updates the mesh list in the combobox
        """
        mlist_cur = avail_meshes(parameterPanel(self).pendingStorage())
        mlist_cmd = avail_meshes(parameterPanel(self).pendingCommandStorage())
        mlist_cmd = [m for m in mlist_cmd if m not in mlist_cur]
        meshlist = mlist_cur + mlist_cmd
        meshlist.reverse()
        self.setMeshList(meshlist)
        msg = ""
        if len(meshlist) > 1:
            msg = translate("ParameterPanel", "More than one mesh found")
        elif not meshlist:
            msg = translate("ParameterPanel", "No mesh found")
        self.setMessage(msg)
        self._meshActivated(self._mesh.currentIndex())

    def _meshActivated(self, index):
        """
        Updates the mesh groups in checkable list.
        Invoked after mesh changing in mesh combobox.
        """
        meshcmd = None
        if 0 <= index < self._mesh.count():
            meshcmd = self._mesh.itemData(index)

        groups = {}
        if meshcmd is not None:
            group_type = self._meshGroupType()
            file_name, nom_med = get_cmd_mesh(meshcmd)
            if is_medfile(file_name) or is_reference(file_name):
                self.meshFileChanged.emit(file_name, nom_med, 0.1, False)
            try:
                groups = get_cmd_groups(meshcmd, group_type, with_size=True)
            except TypeError:
                pass
        # The value is overriden by "setMeshGroups"
        # It needs to be kept and set again
        value = self.itemValue()
        self.setMeshGroups(groups)
        self.setItemValue(value)
        self.meshChanged.emit()

    def _meshGroupType(self):
        """
        Get the type of the mesh group

        Returns:
            str: Mesh group type (see `MeshGroupType`).
        """
        mgtype = -1
        kw_def = self.keyword().definition
        typ = kw_def.get('typ')
        if isinstance(typ, (tuple, list)):
            typ = typ[0] if typ else None
        if is_subclass(typ, CATA.package('DataStructure').grma):
            mgtype = MeshGroupType.GElement
        elif is_subclass(typ, CATA.package('DataStructure').grno):
            mgtype = MeshGroupType.GNode
        return mgtype

    @Q.pyqtSlot("QPoint")
    def _popupMenuRequest(self, pos):
        """
        Process context menu request.
        """
        manage_normals = self.meshview().isFeatureSupported('normals') and \
            not behavior().grp_global_cmd

        meshcmd = self._meshcmd(self._mesh.currentIndex())
        file_name, nom_med = get_cmd_mesh(meshcmd)

        actions_list = ['select', 'unselect']
        if manage_normals:
            actions_list.extend(['show_normals', 'hide_normals'])
        actions_dict = OrderedDict.fromkeys(actions_list, False)

        selected_items = self._list.selectedItems()
        for item in selected_items:
            if item.checkState(0) == Q.Qt.Checked:
                actions_dict['unselect'] = True
            if item.checkState(0) == Q.Qt.Unchecked:
                actions_dict['select'] = True
            if manage_normals and file_name is not None and \
                    nom_med is not None:
                shown = self.meshview().normalsShown(file_name, nom_med,
                                                     item.text(0))
                if shown is None:
                    continue
                if shown:
                    actions_dict['hide_normals'] = True
                if not shown:
                    actions_dict['show_normals'] = True
            if all(actions_dict.values()):
                break

        actions_titles = {
            'select': translate("ParameterPanel", "Select"),
            'unselect': translate("ParameterPanel", "Unselect"),
            'show_normals': translate("ParameterPanel", "Show Normals"),
            'hide_normals':  translate("ParameterPanel", "Hide Normals"),
            }

        actions = OrderedDict()
        for item, shown in actions_dict.items():
            if not shown:
                continue
            action = Q.QAction(actions_titles[item], None)
            action.setToolTip(actions_titles[item])
            action.setStatusTip(actions_titles[item])
            actions[action] = item
        if actions:
            action = Q.QMenu.exec_(actions.keys(), self._list.mapToGlobal(pos))
            action_type = actions.get(action)
            if action_type == 'select':
                for item in selected_items:
                    item.setCheckState(0, Q.Qt.Checked)
            elif action_type == 'unselect':
                for item in selected_items:
                    item.setCheckState(0, Q.Qt.Unchecked)
            elif action_type == 'show_normals':
                for item in selected_items:
                    self.meshview().showNormals(file_name, nom_med,
                                                item.text(0), True)
            elif action_type == 'hide_normals':
                for item in selected_items:
                    self.meshview().showNormals(file_name, nom_med,
                                                item.text(0), False)

    @Q.pyqtSlot()
    def _showNormals(self):
        """Called when global 'Show/Hide normals' button is toggled."""
        shown = self.ops[ParameterMeshGroupView.ShowNormals].isChecked()
        self.meshview().setAllNormalsShown(shown)

    @Q.pyqtSlot()
    def _fitSelection(self):
        """Called when global 'Fit selection' button is clicked."""
        meshcmd = self._meshcmd(self._mesh.currentIndex())
        file_name, nom_med = get_cmd_mesh(meshcmd)
        if file_name is None or nom_med is None:
            return
        group_type = self._meshGroupType()
        groups = self.highlightedMeshGroups() or self.selectedMeshGroups()
        self.meshview().fitObjects(file_name, nom_med, groups, group_type)

    @Q.pyqtSlot(bool)
    def _selectGroups(self, checked):
        """Action when the select groups icon is toggled or untoggled"""
        if checked:
            behavior().mesh_view_handle_selection = False
            self._gbox.show()
            self._selectGroupType(self._bgroup.checkedId())
            self.meshview().enable_selection = True
        if not checked:
            self.meshview().enable_selection = False
            self._gbox.hide()
            meshcmd = self._meshcmd(self._mesh.currentIndex())
            file_name, nom_med = get_cmd_mesh(meshcmd)
            self.meshview().displayAllGroups(file_name, nom_med,
                                             self._meshGroupType(),
                                             MeshElemType.EAll,
                                             self.selectedMeshGroups())
            self.meshview().setSelection(file_name,
                                         nom_med,
                                         [],
                                         self._meshGroupType())
            behavior().mesh_view_handle_selection = True

    @Q.pyqtSlot()
    def _manualChanged(self):
        """Called when user enters group names in dedicated widget."""
        groups = self.inputMeshGroups()
        invalid_names = [i for i in groups if not is_valid_group_name(i) \
                                              or i in self._invalid_groups]
        pal = self._manual.palette()
        color = Q.Qt.red if invalid_names else Q.Qt.black
        pal.setColor(self._manual.foregroundRole(), color)
        self._manual.setPalette(pal)
        invalid_names = ', '.join(["'{}'".format(i) for i in invalid_names])
        tip = translate("ParameterPanel", "Invalid names of groups: {}.") \
            if invalid_names else ''
        self._manual.setToolTip(tip.format(invalid_names))

    @Q.pyqtSlot(int)
    def _selectGroupType(self, index):
        """
        Called when group type radio button is changed.

        Arguments:
            index(int): number of the selected radio button.
        """
        if self._meshGroupType() is MeshGroupType.GElement:
            tlist = MeshElemType.elem_types(MeshGroupType.GElement, True)
            thetype = tlist[index]
            meshcmd = self._meshcmd(self._mesh.currentIndex())
            file_name, nom_med = get_cmd_mesh(meshcmd)
            self.meshview().displayAllGroups(file_name, nom_med,
                                             MeshGroupType.GElement,
                                             thetype)
            self.meshview().setSelection(file_name,
                                         nom_med,
                                         self.selectedMeshGroups(),
                                         self._meshGroupType(),
                                         thetype)


def value_or_variable_name(x):
    """
    Given a ``Variable``, returns its name.
    Given anything else, returns its text representation (or empty string if it's `None`).

    Returns:
        str
    """
    if isinstance(x, Variable):
        return x.name
    if x is not None:
        return str(x)
    return ''


def value_or_variable_evaluation(x):
    """
    Given a ``Variable``, evaluates and returns it value.
    Given anything else, just returns it unmodified.
    """
    if isinstance(x, Variable):
        return x.evaluation
    return x


def set_cell_value(index, value):
    """
    Sets `value` of a table cell specified by `index`.

    Arguments:
        index (QModelIndex):
        value:
    """
    model = index.model()
    model.setData(index, value_or_variable_name(value), Q.Qt.DisplayRole)
    model.setData(index, value, Q.Qt.UserRole)
