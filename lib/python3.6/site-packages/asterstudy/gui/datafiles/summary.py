# coding: utf-8

"""
Data Files Summary panel
------------------------

Implements panel with data files summary.
"""


import os.path as osp

from PyQt5 import Qt as Q

from ...common import (bold, common_filters, external_file, external_files,
                       get_file_name, is_reference, load_icon, preformat,
                       translate)
from ...datamodel import FileAttr, synchronize
from .. import Context, NodeType, check_selection
from ..actions import OpenWithAction, OnFileAction
from ..controller import Controller
from ..widgets import TitleWidget
from .objects import File

__all__ = ["DataFilesSummary"]

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name


UnitRole = Q.Qt.UserRole
StageRole = Q.Qt.UserRole + 1
FilenameRole = Q.Qt.UserRole + 2
SortRole = Q.Qt.UserRole + 3

class DataFilesSummary(Q.QWidget):
    """
    Widget displaying unified list of files from all stages in current case.

    Through the context menu, user can open that file in an app or go to its directory.
    Additionally, when listing files for Current Case, user can update a file's path.
    """

    Edit = 1
    OpenWith = 2
    BrowseDirectory = 3
    PostProcess = 4

    def __init__(self, astergui, parent):
        """
        Create view.

        Arguments:
            astergui (asterstudy.gui.astergui.AsterGui): *AsterGui* instance.
            parent (Q.QWidget): Parent widget.
        """
        super().__init__(parent)
        self.setObjectName('DataFilesSummary')

        self._astergui = astergui
        self._actions = {}

        # initialize layout
        layout = Q.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # panel title
        layout.addWidget(TitleWidget(translate("DataFiles", "Data Files Summary"), self))

        # files model
        self._model = _FilesModel(0, 4)
        proxy_model = Q.QSortFilterProxyModel()
        proxy_model.setSourceModel(self._model)
        proxy_model.setSortRole(SortRole)

        # files view
        self._tree = Q.QTreeView(self)
        self._tree.setObjectName('DataFilesSummary_Tree')
        self._tree.setModel(proxy_model)
        self._tree.setRootIsDecorated(False)
        self._tree.setSortingEnabled(True)
        self._tree.setEditTriggers(Q.QAbstractItemView.NoEditTriggers)
        self._tree.setItemDelegate(_EditingDelegate(self._tree, self._astergui))
        self._tree.setContextMenuPolicy(Q.Qt.CustomContextMenu)
        self._tree.doubleClicked.connect(self._edit)
        self._tree.customContextMenuRequested.connect(self._show_context_menu)
        self._tree.header().setSectionsMovable(False)
        self._tree.header().setSectionResizeMode(Q.QHeaderView.ResizeToContents)
        layout.addWidget(self._tree)

        # actions
        # - <Edit>
        action = Q.QAction(translate("DataFiles", "Edit..."), self)
        action.setIcon(load_icon('as_pic_edit_file.png'))
        action.setToolTip(translate("DataFiles", "Edit"))
        action.setStatusTip(translate("DataFiles", "Edit file path"))
        action.setShortcut('F4')
        action.setShortcutContext(Q.Qt.WidgetWithChildrenShortcut)
        action.triggered.connect(self._edit)
        action.setEnabled(False)
        self._actions[self.Edit] = action
        # - <Open With>
        action = OpenWithAction(self, self._astergui.main_window)
        action.setEnabled(False)
        self._actions[self.OpenWith] = action
        # - post-process in the results tab
        action = OnFileAction(translate("AsterStudy", "Post-process"),
                              self,
                              self._astergui.showResultsFile)
        action.setToolTip(translate("AsterStudy", "Post-process"))
        action.setStatusTip(translate("AsterStudy",
                                      "Post-process the result the Results tab"))
        action.setIcon(load_icon("as_pic_open_in_paravis.png"))
        self._actions[self.PostProcess] = action
        # - <Browse Directory>
        action = Q.QAction(translate("DataFiles", "Browse Directory"), self)
        action.setToolTip(translate("DataFiles", "Browse directory"))
        action.setStatusTip(translate("DataFiles", "Show selected file in the explorer"))
        action.triggered.connect(self._browse_directory)
        action.setEnabled(False)
        self._actions[self.BrowseDirectory] = action
        # add actions to this widget to access their via shortcuts
        self.addActions(self._actions.values())

    def setSelection(self, objs):
        """
        Select given objects.

        Arguments:
            objs (list[Entity]): Objects being selected.
        """
        # If user has selected exactly one case, we should show file list for this case.
        # Otherwise, we should show nothing.
        # This function is called from ``Workspace.setSelected()`` or ``update()``.

        if check_selection(objs, size=1, typeid=NodeType.Case):
            study = self._astergui.study()
            case = study.node(objs[0])

            # enable / disable actions
            is_editable = (case is study.history.current_case)
            self._actions[self.Edit].setEnabled(is_editable)
            self._actions[self.OpenWith].setEnabled(is_editable)
            self._actions[self.PostProcess].setEnabled(True)
            self._actions[self.BrowseDirectory].setEnabled(True)

            # intialize create temporary files model from case
            tmp_model = Q.QStandardItemModel(0, 1)
            for stage in case.stages:
                for unit in stage.handle2info:
                    item = DataFileItem(stage, unit)
                    item.setEditable(is_editable)
                    tmp_model.appendRow(item)

            # update files model by syncing it with temporary model
            synchronize(
                tmp_model.invisibleRootItem(),
                self._model.invisibleRootItem(),
                _DataFilesSummaryTreeData())

            # re-sort files view
            self._tree.sortByColumn(1, Q.Qt.AscendingOrder)

        else:
            # clear files model
            self._model.clear()

    @Q.pyqtSlot()
    def update(self):
        """
        Update view.
        """
        # just call `setSelection()` with current selection
        self.setSelection(self._astergui.view(Context.Cases).selection())

    @Q.pyqtSlot(Q.QPoint)
    def _show_context_menu(self, pos):
        """
        Show context menu for a file.

        Arguments:
            pos (QPoint): Cursor position.
        """
        index = self._tree.indexAt(pos)  # type: Q.QModelIndex
        if index.isValid():
            index = index.sibling(index.row(), 1) # get model index for second column
            file_name = index.data(FilenameRole) # type: str

            menu = Q.QMenu(self)

            menu.addAction(self._actions[self.Edit])
            menu.setDefaultAction(self._actions[self.Edit])
            menu.addSeparator()

            if file_name:
                self._actions[self.OpenWith].setFileName(file_name)
                self._actions[self.PostProcess].setFileName(file_name)
                menu.addAction(self._actions[self.OpenWith])
                menu.addAction(self._actions[self.PostProcess])
                menu.addAction(self._actions[self.BrowseDirectory])

            menu.popup(self._tree.viewport().mapToGlobal(pos))

    @Q.pyqtSlot()
    def _edit(self):
        """Open editor for selection file item."""
        index = self._tree.currentIndex()  # type: Q.QModelIndex
        index = index.sibling(index.row(), 1) # get model index for second column
        if index.flags() & Q.Qt.ItemIsEditable:
            self._tree.edit(index) # activate in-place editing

    @Q.pyqtSlot()
    def _browse_directory(self):
        """
        Launch file manager on the selected file's directory.
        """
        index = self._tree.currentIndex()  # type: Q.QModelIndex
        file_name = index.data(FilenameRole) # type: str
        directory = osp.dirname(file_name)
        Q.QDesktopServices.openUrl(Q.QUrl(directory))


class DataFileItem(Q.QStandardItem):
    """
    Item representing a data file.
    """

    def __init__(self, stage=None, unit=None):
        """
        Create item.

        Arguments:
            file (asterstudy.gui.datafiles.objects.File): File helper.
        """
        super().__init__()
        self.stage = stage
        self.unit = unit

    def __eq__(self, other):
        return isinstance(other, DataFileItem) and \
            self.stage.uid == other.stage.uid and self.unit == other.unit

    @classmethod
    def clone(cls, other):
        """Create a copy of this item."""
        item = cls(other.stage, other.unit)
        item.setEditable(other.isEditable())
        return item

    def copy_from(self, other):
        """Update this item from reference one.."""
        self.stage = other.stage
        self.unit = other.unit
        self.setEditable(other.isEditable())
        self.emitDataChanged()

    def data(self, role=Q.Qt.UserRole+1):
        """
        Provide readable filename as item's text, and full details as tooltip.
        """
        info = self.stage.handle2info.get(self.unit)
        path = info is not None and info.filename

        if role in (Q.Qt.DisplayRole, SortRole,):
            return _file_title(path, info and info.embedded)

        if role in (Q.Qt.ToolTipRole,):
            if not path:
                path = "&lt;{}&gt;".format(translate("DataFiles", "undefined"))
            if self.stage and path:
                tooltip = []
                tooltip.append(bold(NodeType.value2str(NodeType.Stage)) + ": " + self.stage.name)
                tooltip.append(bold(NodeType.value2str(NodeType.Unit)) + ": " + path)
                return preformat('<br/>'.join(tooltip))

        if role in (Q.Qt.BackgroundRole,):
            if not path:
                return Q.QBrush(Q.Qt.yellow)

        if role in (Q.Qt.ForegroundRole,):
            if not path:
                return Q.QBrush(Q.Qt.red)

        if role in (Q.Qt.SizeHintRole,):
            fm = Q.QFontMetrics(self.font())
            return Q.QSize(fm.width(self.text()) + 50, 18)

        if role in (UnitRole,): # unit
            return self.unit

        if role in (StageRole,): # stage
            return self.stage

        if role in (FilenameRole,): # filename
            return info and info.filename

        return super().data(role)


class _DataFilesSummaryTreeData:
    """
    Implementation of `tree_data` for `synchronize()`.
    """

    def is_equal(self, src, dst): # pragma pylint: disable=no-self-use
        """
        Arguments:
            src (Q.QStandardItem)
            dst (DataFileItem)

        Returns:
            bool
        """
        if isinstance(src, DataFileItem):
            return src == dst
        return True # for invisible root items

    def create_item(self, src): # pragma pylint: disable=no-self-use
        """
        Arguments:
            src (Q.QStandardItem)

        Returns:
            DataFileItem
        """
        if isinstance(src, DataFileItem):
            return DataFileItem.clone(src)
        return DataFileItem() # should not get here

    def update_item(self, src, dst): # pragma pylint: disable=no-self-use
        """
        Arguments:
            src (DataFileItem)
            dst (DataFileItem)
        """
        if isinstance(src, DataFileItem) and isinstance(dst, DataFileItem):
            dst.copy_from(src)

    def get_src_children(self, src): # pragma pylint: disable=no-self-use
        """
        Arguments:
            src (DataFileItem)

        Returns:
            list[DataFileItem]
        """
        return [src.child(i) for i in range(src.rowCount())]

    def get_dst_children(self, dst): # pragma pylint: disable=no-self-use
        """
        Arguments:
            dst (DataFileItem)

        Returns:
            list[DataFileItem]
        """
        return [dst.child(i, 1) for i in range(dst.rowCount())]

    def replace_dst_children(self, dst, children): # pragma pylint: disable=no-self-use
        """
        Arguments:
            dst (DataFileItem)
            children (list[DataFileItem])
        """
        # Remove items that are not present in new list
        # Also, remember which ones are present
        existing_children = []
        for i in reversed(range(dst.rowCount())):
            child = dst.child(i, 1)
            if child not in children:
                dst.removeRow(i)
            else:
                existing_children.append(child)

        # Add items from new list that weren't present in list before
        for i, child in enumerate(children):
            if child not in existing_children:
                unit = child.unit
                unit_item = Q.QStandardItem(str(unit))
                unit_item.setData(unit, SortRole)
                stage = child.stage
                stage_item = Q.QStandardItem(stage.name)
                stage_item.setData(stage.name, SortRole)
                attr = stage.handle2info[unit].attr if unit in stage.handle2info else FileAttr.No
                attr_item = Q.QStandardItem(FileAttr.value2str(attr))
                attr_item.setData(FileAttr.value2str(attr), SortRole)
                dst.insertRow(i, [unit_item, child, stage_item, attr_item])


class _EditingWidget(Q.QWidget):
    """
    Simple widget for selecting a file.

    User can either select an existing file from combobox or open a dialog for choosing a new one.
    Actual logic is implemented in ``__EditingDelegate``.
    """
    def __init__(self, parent):
        """
        Arguments:
            parent (Q.QWidget)
        """
        super().__init__(parent)
        self.setObjectName('DataFilesSummary_EditingWidget')

        layout = Q.QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.setLayout(layout)

        self.combobox = Q.QComboBox(self)
        self.combobox.setObjectName('DataFilesSummary_EditingWidget_ComboBox')
        self.combobox.setFocusPolicy(Q.Qt.NoFocus)
        layout.addWidget(self.combobox, 1)

        self.button = Q.QToolButton(self)
        self.button.setObjectName('DataFilesSummary_EditingWidget_Button')
        self.button.setText('...')
        self.button.setFocusPolicy(Q.Qt.NoFocus)
        layout.addWidget(self.button, 0)

    def keyPressEvent(self, event):
        """Redefined from *QWidget*."""
        if not getattr(self, "in_key_press", False):
            setattr(self, "in_key_press", True)
            Q.QApplication.instance().sendEvent(self.combobox, event)
            delattr(self, "in_key_press")


class _EditingDelegate(Q.QStyledItemDelegate):
    """
    Uses ``_EditingWidget`` for inline editing of a ``File``.
    When user selects a new file (with Open File dialog),
    this delegate adds the file to the datamodel.
    """
    def __init__(self, tree, astergui):
        """
        Arguments:
            tree (Q.QTreeView)
            astergui (asterstudy.gui.astergui.AsterGui)
        """
        super().__init__()
        self._tree = tree
        self._astergui = astergui

    def createEditor(self, parent, option, index): # pylint: disable=unused-argument,no-self-use
        """
        Arguments:
            parent (Q.QWidget)
            option (Q.QStyleOptionViewItem)
            index (Q.QModelIndex)

        Returns:
            _EditingWidget
        """
        stage = index.data(StageRole)  # type: Stage
        case = stage.parent_case

        widget = _EditingWidget(parent)
        widget.button.clicked.connect(self._onButtonClicked)

        model = _ComboModel(widget)

        # Add all current known files
        for stage in case.stages:
            for info in stage.handle2info.values():
                model.addItem(info.filename, _file_title(info.filename, info.embedded))

        # Add all known external files
        for uid in external_files():
            model.addItem(uid, external_file(uid))

        widget.combobox.setModel(model)
        return widget

    def setEditorData(self, widget, index): # pylint: disable=no-self-use
        """
        Arguments:
            widget (_EditingWidget)
            index (Q.QModelIndex)
        """
        stage = index.data(StageRole)  # type: Stage
        unit = index.data(UnitRole)  # type: int
        info = stage.handle2info[unit]
        widget.combobox.attr = info.attr
        for i in range(widget.combobox.count()):
            path = widget.combobox.itemData(i, Q.Qt.ToolTipRole)  # type: str
            if path == info.filename:
                widget.combobox.setCurrentIndex(i)
                break
        else:
            widget.combobox.setCurrentIndex(-1) # undefined filename

    def setModelData(self, widget, model, index): # pylint: disable=no-self-use,unused-argument
        """
        Arguments:
            widget (_EditingWidget)
            model (PyQt5.QtCore.QStandardItemModel.QStandardItemModel)
            index (PyQt5.QtCore.QModelIndex.QModelIndex)
        """
        path = widget.combobox.currentData(Q.Qt.ToolTipRole)  # type: str
        stage = index.data(StageRole)  # type: Stage
        unit = index.data(UnitRole)  # type: int
        info = stage.handle2info[unit]
        study_dir = stage.model.tmpdir

        if path and path != info.filename:
            if self._astergui.prepare_for_new_operation():
                operation = translate("DataFiles", "Change file path")
                ctr = Controller(operation, self._astergui)
                # Update actual file
                is_embedded = not is_reference(path) and osp.dirname(path) == study_dir
                current_file = File(stage, unit)
                current_file.filename = path
                current_file.embedded = is_embedded
                # Commit changes to data model
                ctr.controllerCommit()
                self._astergui.study().commit(operation)
                # Update GUI
                self._astergui.update()

    @Q.pyqtSlot()
    def _onButtonClicked(self):
        """
        Open file dialog and select a new file.
        Put its name to the combobox.
        """
        widget = self.sender().parent()  # type: _EditingWidget
        path = widget.combobox.currentData(Q.Qt.ToolTipRole)  # type: str
        attr = widget.combobox.attr  # type: str

        # Show file selection dialog
        title = translate("DataFiles", "Select File")
        file_name = path if not is_reference(path) else None
        mode = 0 if (attr & ~FileAttr.Named) == 2 else 1
        filters = common_filters()
        file_name = get_file_name(mode, widget, title, file_name, filters)

        if file_name:
            # Add an item to combo box if necessary
            widget.combobox.model().addItem(file_name)
            # Select an item in combo box
            for i in range(widget.combobox.count()):
                path = widget.combobox.itemData(i, Q.Qt.ToolTipRole)  # type: str
                if path == file_name:
                    widget.combobox.setCurrentIndex(i)
                    break
            self.commitData.emit(widget)
            self.closeEditor.emit(widget, Q.QAbstractItemDelegate.SubmitModelCache)


class _FilesModel(Q.QStandardItemModel):
    """Helper model to manage list of data files in the *Data Files Summary* panel."""

    def headerData(self, section, orientation, role=Q.Qt.DisplayRole):
        """Redefined from *QStandardItemModel*."""
        headers = {0: translate("DataFiles", "Unit"),
                   1: translate("DataFiles", "Filename"),
                   2: translate("DataFiles", "Stage"),
                   3: translate("DataFiles", "Mode")}

        if orientation == Q.Qt.Horizontal and role in (Q.Qt.DisplayRole,):
            return headers.get(section)
        return super().headerData(section, orientation, role)

class _ComboModel(Q.QSortFilterProxyModel):
    """Helper model to show list of unique file names in selection combo."""

    def __init__(self, parent):
        """Create model."""
        super().__init__(parent)
        source_model = Q.QStandardItemModel(parent)
        self.setSourceModel(source_model)
        self.sort(0, Q.Qt.AscendingOrder)

    def addItem(self, path, title=None):
        """Add item to model."""
        source_model = self.sourceModel()
        if path and not source_model.findItems(path, Q.Qt.MatchExactly, 1):
            if not title:
                title = osp.basename(path)
            item0 = Q.QStandardItem(title)
            item0.setData(path, Q.Qt.ToolTipRole) # tooltip
            item1 = Q.QStandardItem(path) # for search
            source_model.appendRow([item0, item1])


def _file_title(file_name, is_embedded=False):
    """
    Returns nice title for the file's item in a list, such as a tree or a combobox.

    For a normal file, renders its basename.
    For an embedded file, renders its external name and adds "(embedded)" after the name.
    For an empty filename, renders <undefined>.

    Arguments:
        file (File):

    Returns:
        str
    """
    if file_name:
        if is_reference(file_name):
            title = external_file(file_name)
        else:
            title = osp.basename(file_name)
    else:
        title = '<{}>'.format(translate("DataFiles", "undefined"))

    if is_embedded:
        title += ' ({})'.format(translate("DataFiles", "embedded"))

    return title
