# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Unused Concepts dialog
----------------------

The module implements a dialog for unused concepts detection.

"""


from PyQt5 import Qt as Q

from . import Role, get_icon, is_noname
from .datasettings.model import get_object_name, get_object_type
from .widgets import Dialog, TreeWidget
from ..common import translate
from ..datamodel.command import Comment, Hidden

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name


class UnusedConceptsDialog(Dialog):
    """Unused concepts dialog."""

    def __init__(self, astergui, obj, parent=None):
        """
        Create dialog.

        Arguments:
            astergui (AsterGui): Parent AsterGui instance.
            obj (Stage, Case): Stage or Case object.
            parent (Optional[QWidget]): Parent widget. Defaults to *None*.
        """
        super().__init__(parent)

        self._astergui = astergui

        # Main parameters
        title = translate("UnusedConceptsDialog",
                          "Detect unused concepts for {}").format(obj.name)
        self.setWindowTitle(title)
        self.setModal(True)

        # List of commands
        self._tree = TreeWidget(self.main())
        self._tree.setColumnCount(2)
        self._tree.setSelectionMode(Q.QTreeWidget.ExtendedSelection)
        self._tree.setItemsExpandable(False)
        self._tree.setMinimumWidth(100)
        self._tree.header().hide()
        self._tree.header().setSectionResizeMode(Q.QHeaderView.ResizeToContents)
        self._tree.header().setStretchLastSection(True)
        self._tree.setContextMenuPolicy(Q.Qt.CustomContextMenu)

        if hasattr(obj, 'stages'):
            for stage in obj.stages:
                item = Q.QTreeWidgetItem()
                item.setText(0, stage.name)
                item.setIcon(0, get_icon(stage))
                item.setData(0, Role.IdRole, stage.uid)
                flags = Q.Qt.ItemIsSelectable | Q.Qt.ItemIsEnabled
                item.setFlags(flags)
                self._tree.addTopLevelItem(item)
                self._detectUnusedCommands(item)
        else:
            item = self._tree.invisibleRootItem()
            item.setData(Role.IdRole, obj.uid)
            self._detectUnusedCommands(item)

        # Select All / Unselect all buttons
        title = translate("UnusedConceptsDialog", "Select All")
        select_all_btn = Q.QPushButton(title, self.main())
        title = translate("UnusedConceptsDialog", "Unselect All")
        unselect_all_btn = Q.QPushButton(title, self.main())

        # Standard buttons
        self.setStandardButtons(Q.QDialogButtonBox.Close)
        title = translate("UnusedConceptsDialog", "&Delete")
        delete_btn = self.addButton(title)

        # Layout
        vlayout = Q.QVBoxLayout(self.main())
        vlayout.setContentsMargins(0, 0, 0, 0)
        hlayout = Q.QHBoxLayout()
        hlayout.setContentsMargins(0, 0, 0, 0)
        hlayout.addWidget(select_all_btn)
        hlayout.addWidget(unselect_all_btn)
        hlayout.addStretch()
        vlayout.addWidget(self._tree)
        vlayout.addLayout(hlayout)

        # Connections
        self._tree.customContextMenuRequested.connect(self._popupMenuRequest)
        select_all_btn.clicked.connect(self._selectAll)
        unselect_all_btn.clicked.connect(self._unselectAll)
        self.button(Q.QDialogButtonBox.Close).clicked.connect(self.close)
        delete_btn.clicked.connect(self._deleteCommands)

        # Initialization
        self.resize(400, 400)
        self._tree.expandAll()

    def _detectUnusedCommands(self, parent):
        """Collect unused concepts for given stage."""
        parent.takeChildren()
        uid = parent.data(0, Role.IdRole)
        stage = self._astergui.study().history.get_node(uid)
        commands = [i for i in stage.sorted_commands if not isinstance(i, (Comment, Hidden))]
        for command in commands:
            if is_noname(command) or command.nb_children:
                continue
            command_name = ""
            try:
                command_name = get_object_name(command)
                command_type = get_object_type(command)
                if command_type:
                    command_name += " ({})".format(command_type)
            except RuntimeError:
                # for batch mode
                command_name = command.name

            item = Q.QTreeWidgetItem()
            item.setText(0, command_name)
            item.setIcon(0, get_icon(command))
            item.setData(0, Role.IdRole, command.uid)
            flags = Q.Qt.ItemIsUserCheckable | Q.Qt.ItemIsSelectable | Q.Qt.ItemIsEnabled
            item.setFlags(flags)
            item.setCheckState(0, Q.Qt.Unchecked)
            parent.addChild(item)

    @staticmethod
    def _setItemsCheckState(items, state):
        """Check/uncheck given items."""
        for item in items:
            if item.flags() & Q.Qt.ItemIsUserCheckable:
                item.setCheckState(0, state)

    @Q.pyqtSlot()
    def _selectAll(self):
        """Check all items."""
        items = self._tree.findItems('*', Q.Qt.MatchWildcard | Q.Qt.MatchRecursive)
        self._setItemsCheckState(items, Q.Qt.Checked)

    @Q.pyqtSlot()
    def _unselectAll(self):
        """Uncheck all items."""
        items = self._tree.findItems('*', Q.Qt.MatchWildcard | Q.Qt.MatchRecursive)
        self._setItemsCheckState(items, Q.Qt.Unchecked)

    @Q.pyqtSlot(bool)
    def _select(self):
        """Check selected items."""
        items = self._tree.selectedItems()
        self._setItemsCheckState(items, Q.Qt.Checked)

    @Q.pyqtSlot(bool)
    def _unselect(self):
        """Uncheck selected items."""
        items = self._tree.selectedItems()
        self._setItemsCheckState(items, Q.Qt.Unchecked)

    @Q.pyqtSlot()
    def _deleteCommands(self):
        """Delete selected commands."""
        # delete
        items = self._tree.findItems('*', Q.Qt.MatchWildcard | Q.Qt.MatchRecursive)
        commands = []
        for item in items:
            if item.checkState(0) == Q.Qt.Checked:
                uid = item.data(0, Role.IdRole)
                commands.append(self._astergui.study().history.get_node(uid))
        if commands:
            self._astergui.study().delete(commands)
            self._astergui.update()
            # update
            for i in range(self._tree.topLevelItemCount()):
                self._detectUnusedCommands(self._tree.topLevelItem(i))

    @Q.pyqtSlot("QPoint")
    def _popupMenuRequest(self, pos):
        """Process context menu request."""
        items = self._tree.selectedItems()
        has_checked = False
        has_unchecked = False
        for item in items:
            if item.flags() & Q.Qt.ItemIsUserCheckable:
                has_checked = has_checked or item.checkState(0) == Q.Qt.Checked
                has_unchecked = has_unchecked or item.checkState(0) == Q.Qt.Unchecked
        if has_checked or has_unchecked:
            menu = Q.QMenu()
            if has_unchecked:
                action = menu.addAction(translate("UnusedConceptsDialog", "Select"))
                action.triggered.connect(self._select)
            if has_checked:
                action = menu.addAction(translate("UnusedConceptsDialog", "Unselect"))
                action.triggered.connect(self._unselect)
            menu.exec_(self.mapToGlobal(pos))
