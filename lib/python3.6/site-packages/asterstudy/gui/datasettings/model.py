# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Category model
--------------

Implementation of the category model for *Data Settings* view.

"""


from PyQt5 import Qt as Q

from .. import (HistoryProxy, NodeType, Role, get_icon, get_node_type,
                is_noname, root_node_type, translate_category,
                translate_command)
from ...common import bold, font, italic, preformat, to_list, translate
from ...datamodel import CATA, History, Validity, synchronize
from ...datamodel.command import Command, Comment, Hidden
from ..behavior import behavior
from .category import Category


def get_id(tree_item):
    """
    Get id from the tree widget item.

    Arguments:
        tree_item (QTreeWidgetItem): Tree widget item.

    Returns:
        int: Item's identifier (UID).
    """
    return tree_item.data(0, Role.IdRole)


def get_type(tree_item):
    """
    Get the node type from the tree widget item.

    Arguments:
        tree_item (QTreeWidgetItem): Tree widget item.

    Returns:
        int: Item's type name (*NodeType*).
    """
    return tree_item.data(0, Role.TypeRole)


def get_object_name(obj):
    """
    Get object name to be displayed in data view.

    Arguments:
        obj (Node): Data model node.

    Returns:
        str: Object's name.
    """
    node_type = get_node_type(obj)
    if node_type == NodeType.History:
        return translate("AsterStudy", "History")
    if node_type == NodeType.Command:
        if not is_noname(obj):
            return obj.name
        if behavior().show_catalogue_name:
            return translate("AsterStudy", "[noname]")
        return translate_command(obj.title)
    if node_type == NodeType.Comment:
        return obj.content.split("\n")[0]

    return obj.name


def get_object_type(obj):
    """
    Get object catalogue name to be displayed in data view.

    Arguments:
        obj (Node): Data model node.

    Returns:
        str: Object's catalogue name.
    """
    name = ""
    node_type = get_node_type(obj)
    if node_type == NodeType.Command:
        name = translate_command(obj.title)
    return name


def get_object_info(obj, **kwargs):
    """
    Get object info to be displayed in tooltip.

    Arguments:
        obj (Node): Data model node.
        **kwargs: Arbitrary keyword arguments:

    Returns:
        str: Object's info.
    """
    node_type = get_node_type(obj)
    info = NodeType.value2str(node_type)
    if node_type == NodeType.Command:
        if not obj.active:
            info += " ({})".format(translate("AsterStudy", "deactivated"))
        info += ": "
        if is_noname(obj):
            name = translate("AsterStudy", "[noname]")
        else:
            name = obj.name
        info += bold(name)
        cata = obj.title
        title = translate_command(cata)
        tip = " ({title} / {name})" if title != cata else " ({name})"
        info += tip.format(title=italic(title), name=cata)
        if kwargs.get('with_parent_stage', False):
            info += "<br>"
            st_name = bold(obj.stage.name)
            info += translate("AsterStudy", "From stage: {}").format(st_name)
    elif node_type == NodeType.Comment:
        info += ":<br>"
        content = obj.content.split("\n")
        content = ["  # " + i for i in content]
        info += italic("\n".join(content))
    elif node_type == NodeType.Variable:
        info += ": "
        info += bold(obj.name)
        info += " ({})".format(italic(obj.expression))
    elif node_type == NodeType.Case:
        info += ": "
        info += bold(obj.name)
        if obj.description:
            info += "\n\n"
            info += obj.description
    elif node_type != NodeType.History:
        info += ": "
        info += bold(obj.name)
    if node_type in [NodeType.Case, NodeType.Stage, NodeType.Category,
                     NodeType.Command]:
        check = obj.check()
        names = []
        if check & Validity.Naming and \
            node_type in [NodeType.Case, NodeType.Stage]:
            visitor = NameConflictVisitor()
            obj.accept(visitor)
            names = visitor.names
        validity = Validity.value2str(check, names)
        if validity:
            info += "<br>"
            info += font("Invalid:", color="#ff0000")
            info += ", ".join([bold(i.strip()) for i in validity.split(";")])
    info = preformat(info)
    return info


def match_string(text, pattern, case_sensitive=False):
    """
    Check if string matches given pattern.
    Used within search functionality of 'Data Settings' panel.

    Arguments:
        text (str): String to check.
        pattern (str): Match pattern.
        case_sensitive (Optional[bool]): Make case sensitive search.
            Defaults to *False*.

    Returns:
        bool: *True* if string matches pattern; *False* otherwise.
    """
    if case_sensitive:
        return pattern in text
    return pattern.lower() in text.lower()


def match_name(obj, pattern):
    """
    Check if given object matches name pattern.

    An object matches name pattern if it is a command, variable
    or result of macro and its type matches given pattern,

    Arguments:
        obj (Command): Command.
        pattern (str): Search pattern.

    Returns:
        bool: *True* if object matches name pattern; *False* otherwise.
    """
    result = False
    if get_node_type(obj) in (NodeType.Command,
                              NodeType.Variable,
                              NodeType.Macro):
        result = match_string(obj.title, pattern) or \
            match_string(translate_command(obj.title), pattern)
    return result


def match_concept(obj, pattern):
    """
    Check if given object matches concept pattern.

    An object matches concept pattern if:

    - It is a command or variable, which name matches given patten;
    - It is a command, that refers (via any keyword) to another command
      which name matches given pattern.

    Arguments:
        obj (Command): Command or variable.
        pattern (str): Search pattern.

    Returns:
        bool: *True* if object matches concept pattern; *False* otherwise.
    """
    result = False
    typ = get_node_type(obj)
    if typ in (NodeType.Command, NodeType.Variable, NodeType.Macro):
        result = match_string(obj.name, pattern)
        if not result and typ in (NodeType.Command,):
            items = [obj.storage_nocopy]
            while items and not result:
                item = items.pop(0)
                if isinstance(item, dict):
                    for child in item.values():
                        items.append(child)
                elif isinstance(item, tuple):
                    for child in item:
                        items.append(child)
                elif hasattr(item, 'is_typco') and item.is_typco():
                    result = match_string(item.name, pattern)
                elif get_node_type(item) in (NodeType.Command,
                                             NodeType.Variable,
                                             NodeType.Macro):
                    result = match_string(item.name, pattern)
    return result


def match_keyword(obj, keyword_pattern, value_pattern=None):
    """
    Check if given object matches keyword pattern.

    Keyword pattern is specified via:

    - Keyword name pattern;
    - Optionally, keyword value pattern.

    An object matches keyword pattern if it is a command which
    contains keyword matching given name pattern and, optionally,
    that keyword's value matches value pattern.

    Arguments:
        obj (Command): Command.
        keyword_pattern (str): Keyword name pattern.
        value_pattern (Optional[str]): Keyword value pattern.
            Defaults to *None*.

    Returns:
        bool: *True* if object matches keyword pattern; *False* otherwise.
    """
    result = False
    typ = get_node_type(obj)
    if typ in (NodeType.Command,):
        items = [obj.storage_nocopy]
        while items and not result:
            item = items.pop(0)
            for key, value in item.items():
                if keyword_pattern is not None:
                    kw_ok = match_string(key, keyword_pattern) or \
                        match_string(Model.translate_command(obj.title, key),
                                     keyword_pattern)
                else:
                    kw_ok = True
                if value_pattern:
                    val_ok = match_value(obj, key, value, value_pattern)
                else:
                    val_ok = keyword_pattern is not None
                result = kw_ok and val_ok
                if result:
                    break
                else:
                    if isinstance(value, dict):
                        items.append(value)
                    else:
                        for i in to_list(value):
                            if isinstance(i, dict):
                                items.append(i)
    return result


def match_value(obj, keyword, value, pattern):
    """
    Check if command's keyword value matches given pattern.

    Arguments:
        obj (Command): Command.
        keyword (str): Keyword name.
        value (str|list): Keyword value.
        pattern (str): Value pattern.

    Returns:
        bool: *True* if value matches pattern; *False* otherwise.
    """
    result = False
    if value is not None:
        value = to_list(value)
        for item in value:
            if isinstance(item, (int, float, complex)):
                result = match_string(str(item), pattern) # str(item) == pattern
            elif isinstance(item, str):
                result = match_string(item, pattern) or \
                    match_string(translate_command(obj.title, keyword, item),
                                 pattern)
            if result:
                break
    return result


class NameConflictVisitor:
    """
    Visitor for case and stage to collect the names of sub-objects that
    caused the name conflicts.
    """
    def __init__(self):
        self._names = []

    @property
    def names(self):
        """
        Return names of sub-objects that caused the name conflicts.

        Returns:
            list(str): Names of sub-objects.
        """
        return self._names

    def visit_case(self, case):
        """
        Visit a case.

        Arguments:
            Case: Instance of case object.
        """
        for stage in case.stages:
            self.visit_stage(stage)

    def visit_stage(self, stage):
        """
        Visit a stage.

        Arguments:
            Case: Instance of stage object.
        """
        for command in stage.commands:
            if command.check() & Validity.Naming:
                if command.name not in self._names:
                    self._names.append(command.name)


class CategoryTreeData:
    """
    Tree data for category model synchronization.

    The class is used to synchronize data model (*History*) with the GUI
    widget (*QTreeWidget*).

    Methods related to synchronization purposes take one or two
    arguments:

    - *obj*: Source item which is either an actual data mode object
      (*Node*) or an instance of helper class (*Model*, *Category*);
    - *tree_item*: Destination item which is a tree widget item
      (*QTreeWidgetItem*).
    """

    def __init__(self, category_model):
        """
        Create object.

        Arguments:
            category_model (asterstudy.gui.datasettings.Model): Category model.
        """
        self.category_model = category_model
        self._selected_ids = []

    def init_selection(self, tree_item):
        """
        Store current selection in tree widget.

        Arguments:
            tree_item (QTreeWidgetItem): Tree widget item.
        """
        if tree_item is not None:
            if tree_item.isSelected():
                self._selected_ids.append(get_id(tree_item))
            for i in range(0, tree_item.childCount()):
                self.init_selection(tree_item.child(i))

    def is_equal(self, obj, tree_item): # pragma pylint: disable=no-self-use
        """
        Check if two items are equivalent.

        Note:
            See class description for more details about argument types.

        Arguments:
            obj (object): Source data object.
            tree_item (TreeWidgetItem): Tree widget item.

        Returns:
            bool: *True* if items correspond to each other; *False*
            otherwise.
        """
        if tree_item is None:
            return obj is None
        if isinstance(obj, History):
            return tree_item.text(0) == "History"
        return get_id(tree_item) == obj.uid

    def update_item(self, obj, tree_item): # pragma pylint: disable=no-self-use
        """
        Update destination item from source data item.

        Note:
            See class description for more details about argument types.

        Arguments:
            obj (object): Source data object.
            tree_item (QTreeWidgetItem): Tree widget item.
        """
        node_id = root_node_type() if isinstance(obj, History) else obj.uid
        node_type = get_node_type(obj)

        # first column: name, icon, tooltip, type, id...
        # - validity: must be recomputed before other data set
        if node_type & NodeType.ValidityItems:
            validity = obj.check() == Validity.Nothing
            tree_item.setData(0, Role.ValidityRole, validity)
        # - name
        tree_item.setText(0, get_object_name(obj))
        # icon
        icon = get_icon(obj)
        if icon is not None:
            tree_item.setIcon(0, icon)
        # tooltip
        tree_item.setData(0, Q.Qt.ToolTipRole, get_object_info(obj))
        # expanded state
        tree_item.setData(0, Role.ExpandedRole, tree_item.isExpanded())
        # type
        tree_item.setData(0, Role.TypeRole, node_type)
        # id
        tree_item.setData(0, Role.IdRole, node_id)
        # font
        if node_type in (NodeType.Command, NodeType.Variable):
            item_font = tree_item.font(0)
            item_font.setItalic(is_noname(obj))
            tree_item.setFont(0, item_font)
        if node_type & NodeType.ActivateItems or \
                node_type in (NodeType.Comment, NodeType.Macro):
            tree_item.setData(0, Role.ActivityRole, obj.active)

        # second column: catalogue name (Command only)
        tree_item.setText(1, get_object_type(obj))

        # third column (visible only in debug mode): id
        tree_item.setText(2, str(node_id))

        # set item flags
        flags = tree_item.flags()
        is_current_case = self.category_model.case == \
            self.category_model.history.current_case
        is_editable = is_current_case and \
            (node_type in (NodeType.Stage,) or \
                 (node_type in (NodeType.Command, NodeType.Variable) and \
                      not is_noname(obj)))
        if is_editable:
            flags = flags | Q.Qt.ItemIsEditable
        else:
            flags = flags & ~Q.Qt.ItemIsEditable
        tree_item.setFlags(flags)

    def get_src_children(self, obj):
        """
        Get children items for a source item.

        Note:
            See class description for more details about argument and
            return type.

        Arguments:
            obj (object): Source data object.

        Returns:
            list[object]: Child items.
        """
        children = []
        node_type = get_node_type(obj)
        if isinstance(obj, Model):
            children = [obj.root]
        elif node_type == NodeType.History:
            children = [self.category_model.case]
        elif node_type == NodeType.Case:
            children = obj.child_nodes
        elif node_type == NodeType.Stage:
            children = self.category_model.get_stage_children(obj)
        elif node_type & NodeType.NoChildrenItems:
            if isinstance(obj, Command) and not obj.is_prologue:
                # case of macro-command
                for child in obj.child_nodes:
                    if isinstance(child, Hidden):
                        children.append(child)
            else:
                # it is confirmed that command has no children in the
                # categories representation (except macro-command, see above)
                children = []
        else:
            children = obj.child_nodes
        return children

    def get_dst_children(self, tree_item): # pragma pylint: disable=no-self-use
        """
        Get children items for a destination item.

        Note:
            See class description for more details about argument and
            return type.

        Arguments:
            tree_item (TreeWidgetItem): Tree widget item.

        Returns:
            list[TreeWidgetItem]: Child items.
        """
        children = []
        for i in range(0, tree_item.childCount()):
            children.append(tree_item.child(i))
        return children

    def create_item(self, obj):
        """
        Create a destination item for given source item.

        Note:
            See class description for more details about argument and
            return type.

        Arguments:
            obj (object): Source data object.

        Returns:
            TreeWidgetItem: Tree widget item.
        """
        tree_item = Q.QTreeWidgetItem()
        self.update_item(obj, tree_item)
        return tree_item

    def replace_dst_children(self, tree_item, children): # pragma pylint: disable=no-self-use
        """
        Replace children in the destination item.

        Note:
            See class description for more details about argument types.

        Arguments:
            tree_item (TreeWidgetItem): Tree widget item.
            children (list[TreeWidgetItem]): Child items.
        """
        while tree_item.childCount():
            child_item = tree_item.takeChild(0)
            if child_item not in children:
                del child_item
        for child in children:
            tree_item.addChild(child)

    def update_expanded_status(self, tree_item):
        """
        Update `expanded` status of given tree item and its children
        recursively.

        Arguments:
            tree_item (TreeWidgetItem): Tree widget item.
        """
        is_expanded = tree_item.data(0, Role.ExpandedRole)
        if is_expanded is not None:
            tree_item.setExpanded(is_expanded)
        for i in range(0, tree_item.childCount()):
            self.update_expanded_status(tree_item.child(i))

    def update_selection(self, tree_item):
        """
        Update selection under tree widget item.

        Arguments:
            tree_item (TreeWidgetItem): Tree widget item.
        """
        if tree_item is not None:
            if get_id(tree_item) in self._selected_ids:
                tree_item.setSelected(True)
        for i in range(0, tree_item.childCount()):
            self.update_selection(tree_item.child(i))


class SearchContext:
    """
    Enumerator for search context.

    Attributes:
        Name: Search by type.
        Concept: Search by name.
        Keyword: Search by keyword name.
        Group: Search by group name.
    """
    All = 0
    Name = 1
    Concept = 2
    Keyword = 3
    Group = 4
    Value = 5

    @staticmethod
    def value2str(value):
        """
        Get title for given search context type.

        Arguments:
            value (int): Search type (*SearchContext*).

        Returns:
            str: Search type's title.
        """
        text = None
        if value == SearchContext.All:
            text = translate("Searcher", "All")
        if value == SearchContext.Name:
            text = translate("Searcher", "Command")
        if value == SearchContext.Concept:
            text = translate("Searcher", "Concept")
        if value == SearchContext.Keyword:
            text = translate("Searcher", "Keyword")
        if value == SearchContext.Group:
            text = translate("Searcher", "Group")
        if value == SearchContext.Value:
            text = translate("Searcher", "Value")
        return text

    @staticmethod
    def items():
        """Get all supported search types."""
        return (SearchContext.All, SearchContext.Name, SearchContext.Concept,
                SearchContext.Keyword, SearchContext.Group, SearchContext.Value)

class Model:
    """Category model."""

    @staticmethod
    def translate_command(*args):
        """Wrapper for the method imported from the external module."""
        return translate_command(*args)

    def __init__(self, history_proxy):
        """
        Create model.

        Arguments:
            history_proxy (HistoryProxy): History proxy object.

        Raises:
            RuntimeError: If `history_proxy` is not of *HistoryProxy*
                class or if proxy refers to the invalid root.
        """
        if not isinstance(history_proxy, HistoryProxy):
            raise RuntimeError("Category model should be created only "
                               "on the HistoryProxy object")
        if history_proxy.root is None:
            raise RuntimeError("Null root node not allowed for Category model construction")
        self._name = ''
        self._categories = []
        self._stage_children = {}
        self._history_proxy = history_proxy

    @property
    def history(self):
        """
        Get study history.

        Returns:
            History: Associated *History* object.
        """
        node = self._history_proxy.root
        return node if isinstance(node, History) else node.model

    @property
    def root(self):
        """
        Get the root node of the tree to be created.

        Returns:
            Node: Root node of the tree to be created.
        """
        return self._history_proxy.root

    @property
    def case(self):
        """
        Get case to be displayed.

        Returns:
            Case: Case to be displayed.
        """
        return self._history_proxy.case

    @property
    def uid(self):
        """int: Attribute that holds identifier (UID) of the model."""
        return root_node_type()

    @property
    def name(self):
        """str: Attribute that holds name of the model."""
        return self._name

    def category(self, uid):
        """
        Get category with given *uid*.

        Arguments:
            uid (int): Category UID.

        Returns:
            Category: Category node (*None* if *uid* is invalid).
        """
        category = None
        if uid < 0 and -uid <= len(self._categories):
            category = self._categories[-uid - 1]
        return category

    def get_stage_children(self, stage):
        """
        Get children of the stage.

        Arguments:
            stage (Stage): Stage object.

        Returns:
            list[Category]: Child categories of the stage.
        """
        return self._stage_children.get(stage, [])

    def update(self):
        """Update model."""
        # pragma pylint: disable=too-many-branches
        show_categories = behavior().show_categories
        stages = []
        if self.case is None:
            if get_node_type(self.root) == NodeType.Stage:
                stages.append(self.root)
        else:
            self._stage_children = {}
            self._categories = []
            stages = self.case.stages
        for stage in stages:
            if stage.is_graphical_mode():
                # not be necessary if command.check was called before update
                # now reorder is called by Command.init()
                # stage.reorder()
                commands = stage.sorted_commands
                categories = []
                adding = []
                for command in commands:
                    if isinstance(command, Comment):
                        if behavior().show_comments:
                            adding.append(command)
                        continue
                    elif isinstance(command, Hidden):
                        parent = None
                        for node in command.parent_nodes:
                            if isinstance(node, Command) and \
                                not node.is_prologue:
                                parent = node
                                break
                        if parent:
                            parent.add_child(command)
                            continue
                    adding.append(command)
                    if show_categories:
                        category = CATA.get_command_category(command.title)
                        category = translate_category(category)
                        if not categories or categories[-1].name != category:
                            uid = len(self._categories) + 1
                            new_category = Category(-uid, category, stage.uid,
                                                    self._history_proxy)
                            self._categories.append(new_category)
                            categories.append(new_category)
                    for i in adding:
                        if show_categories:
                            categories[-1].add_child(i)
                        else:
                            categories.append(i)
                    adding = []
                # purge the buffer (remaining commands, normally comments)
                for i in adding:
                    if show_categories:
                        if categories:
                            # there are no categories but only comments in study
                            # => ignored!
                            categories[-1].add_child(i)
                    else:
                        categories.append(i)
                self._stage_children[stage] = categories
            else:
                self._stage_children[stage] = []

    def synchronize(self, root_tree_item=None):
        """
        Synchronize model with tree widget.

        Arguments:
            root_tree_item (Optional[QTreeWidgetItem]): Tree widget.
                 item. Defaults to *None* that means root item.

        Returns:
            QTreeWidgetItem: Updated tree widget item.
        """
        category_tree_data = CategoryTreeData(self)
        category_tree_data.init_selection(root_tree_item)
        new_root = synchronize(self, root_tree_item, category_tree_data)
        category_tree_data.update_expanded_status(new_root)
        category_tree_data.update_selection(new_root)
        return new_root

    def update_all(self, root_tree_item=None):
        """
        Update and synchronize the model with tree widget.

        Arguments:
            root_tree_item (Optional[QTreeWidgetItem]): Tree widget.
                item. Defaults to *None* that means root item.

        Returns:
            QTreeWidgetItem: Updated tree widget item.
        """
        self.update()
        return self.synchronize(root_tree_item)

    def get_node(self, tree_item, node_type=None):
        """
        Find appopriate node from tree item.

        Arguments:
            tree_item (QTreeWidgetItem): Tree widget item.
            node_type (Optional[str, Node, Category]): Requested node
                type or typename.

        Returns:
            Node: Data model node (*None* if not found).
        """
        node = None
        type_id = get_type(tree_item)
        needed_type_id = get_node_type(node_type) if node_type else type_id
        if type_id > needed_type_id:
            # search among parents
            node = self.get_node(tree_item.parent(), node_type)
        elif type_id == needed_type_id:
            node_id = get_id(tree_item)
            if type_id == NodeType.History:
                node = self.history
            elif type_id == NodeType.Category:
                node = self._categories[node_id]
            elif node_id:
                node = self.history.get_node(node_id)
        return node

    def match_item(self, item, pattern, context):
        """
        Check if item matches given search criterion.

        Arguments:
            item (QTreeWidgetItem): Item being checked.
            pattern (str): Search pattern.
            context (int): Search context (SearchContext).

        Returns:
            bool: *True* if item matches criterion; *False* otherwise.
        """
        result = False

        if item is not None and context is not None:
            result = not pattern
            if not result:
                uid = get_id(item)
                obj = self.category(uid) if uid < 0 else \
                    self.history.get_node(uid)

                if not result and context in (SearchContext.All, SearchContext.Name):
                    result = match_name(obj, pattern)
                if not result and context in (SearchContext.All, SearchContext.Concept):
                    result = match_concept(obj, pattern)
                if not result and context in (SearchContext.All, SearchContext.Keyword):
                    result = match_keyword(obj, pattern)
                if not result and context in (SearchContext.All, SearchContext.Group):
                    result = match_keyword(obj, 'GROUP', pattern)
                if not result and context in (SearchContext.All, SearchContext.Value):
                    result = match_keyword(obj, None, pattern)
        return result


def create_model(history_proxy):
    """
    Create category model.

    Arguments:
        history_proxy (HistoryProxy): History proxy object.

    Returns:
        asterstudy.gui.datasettings.Model: New category model.
    """
    model = Model(history_proxy)
    return model
