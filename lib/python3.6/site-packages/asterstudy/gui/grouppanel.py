# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Involved groups panel
---------------------

This module implements the `Analysis summary` / `Groups Involved` panel.

The panel displays a summary about groups involved into a command or analysis.

"""


from PyQt5 import Qt as Q

from . import Panel, is_noname, translate_command
from .behavior import behavior
from .widgets import TitleWidget
from ..common import bold, connect, get_cmd_mesh, italic, load_icon, load_pixmap, preformat, \
    translate
from ..datamodel import CATA
from ..datamodel.command import Command
from ..datamodel.command.helper import (avail_groups, avail_groups_in_cmd, avail_groups_in_storage,
                                        avail_meshes, avail_meshes_in_cmd,
                                        tout_usage, tout_usage_in_cmd, tout_usage_in_storage)

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name,too-many-instance-attributes


class GroupPanel(Q.QFrame):
    """`Analysis Summary` panel."""

    ShowGroups = 0
    HideGroups = 1
    FitSelection = 2
    WhatsThisFromContextMenu = 3

    hidden = Q.pyqtSignal()
    """Emitted when panel is closed."""

    def __init__(self, astergui, parent=None):
        """
        Create panel.

        Arguments:
            astergui (AsterGui): Parent AsterGui instance.
            parent (Optional[QWidget]): Parent widget. Defaults to *None*.
        """
        super().__init__(parent=parent)
        self.setObjectName('group_panel')

        self._astergui = astergui
        self._model = None
        self._index = 0
        self._ops = {}
        self._groups_visibility = {}
        self._groups_usages = {}

        # ##
        # Create main layout
        # ##

        self.setLayout(Q.QVBoxLayout())
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.layout().setSpacing(0)

        # ##
        # Create title
        # ##

        # Panel title
        self._title = TitleWidget(parent=self)
        self._title.setObjectName('title')
        self.layout().addWidget(self._title)

        # Combo box for categories
        self._categories = Q.QComboBox(self)
        self._categories.setObjectName('categories')
        self._categories.setSizePolicy(Q.QSizePolicy.Minimum, Q.QSizePolicy.Fixed)
        self._categories.setMinimumWidth(150)
        self._title.addWidget(self._categories, TitleWidget.Left)

        # Buttons in the title
        action = Q.QAction(translate("AsterStudy", "&Show Groups"), self)
        action.setToolTip(translate("AsterStudy", "Show groups"))
        action.setStatusTip(translate("AsterStudy", "Show groups associated with selected usage"))
        action.setIcon(load_icon("as_ico_eye_off.png"))
        self._ops[self.ShowGroups] = action
        self._title.toolbar().addAction(action)

        action = Q.QAction(translate("AsterStudy", "&Hide Groups"), self)
        action.setToolTip(translate("AsterStudy", "Hide groups"))
        action.setStatusTip(translate("AsterStudy", "Hide groups associated with selected usage"))
        action.setIcon(load_icon("as_ico_eye_on.png"))
        self._ops[self.HideGroups] = action
        self._title.toolbar().addAction(action)

        action = Q.QAction(translate("AsterStudy", "&Fit Selection"), self)
        action.setToolTip(translate("AsterStudy", "Fit selection"))
        action.setStatusTip(translate("AsterStudy", "Fit view contents to selected groups"))
        action.setIcon(load_icon("as_pic_fit_selection.png"))
        self._ops[self.FitSelection] = action
        self._title.toolbar().addAction(action)

        action = Q.QWhatsThis.createAction(self)
        action.setToolTip(translate("AsterStudy", "What's this?"))
        action.setStatusTip(translate("AsterStudy", "Show description of usage"))
        action.setIcon(load_icon("as_pic_whats_this.png"))
        self._title.toolbar().addAction(action)

        action = Q.QAction(translate("AsterStudy", "What's This?"), self)
        action.setToolTip(translate("AsterStudy", "What's this?"))
        action.setStatusTip(translate("AsterStudy", "Show description of usage"))
        action.setIcon(load_icon("as_pic_whats_this.png"))
        self._ops[self.WhatsThisFromContextMenu] = action

        # Close button
        self._close_btn = Q.QToolButton(self)
        self._close_btn.setObjectName('close_btn')
        self._close_btn.setIcon(load_icon('as_pic_find_close.png'))
        self._close_btn.setToolTip(translate("AsterStudy", "Close"))
        self._close_btn.setFixedSize(Q.QSize(16, 16))
        self._title.addWidget(self._close_btn, TitleWidget.Right)

        # ##
        # Create table view for the groups
        # ##

        self._view = ResizableListView(self)
        self._view.setObjectName('view')
        self._view.setSelectionMode(Q.QAbstractItemView.ExtendedSelection)
        self._view.setContextMenuPolicy(Q.Qt.CustomContextMenu)
        self._view.setWrapping(True)
        self._view.setResizeMode(Q.QListView.Adjust)
        self._view.setIconSize(_iconSize())
        self.layout().addWidget(self._view)

        # ##
        # Create Show previous / next buttons + counter
        # ##

        # Control widget
        self._controls = Q.QWidget(self)
        self._controls.setObjectName('controls')
        self._controls.setLayout(Q.QHBoxLayout())
        self._controls.layout().setContentsMargins(0, 3, 0, 0)
        self.layout().addWidget(self._controls)

        # Show previous / next buttons
        self._buttons = Q.QDialogButtonBox(self._controls)
        self._buttons.setObjectName('buttons')
        self._prev_button = Q.QPushButton(translate("GroupPanel", "< Previous"))
        self._prev_button.setObjectName('previous_btn')
        self._next_button = Q.QPushButton(translate("GroupPanel", "Next >"))
        self._next_button.setObjectName('next_btn')
        self._buttons.addButton(self._prev_button, Q.QDialogButtonBox.ActionRole)
        self._buttons.addButton(self._next_button, Q.QDialogButtonBox.ActionRole)
        self._controls.layout().addWidget(self._buttons)

        # Counter label
        self._counter = Q.QLabel(self._controls)
        self._counter.setObjectName("counter")
        self._counter.setMinimumWidth(60)
        self._counter.setAlignment(Q.Qt.AlignCenter)
        self._counter.setFrameStyle(Q.QLabel.Box)
        self._counter.setBackgroundRole(Q.QPalette.Base)
        self._counter.setAutoFillBackground(True)
        self._controls.layout().addWidget(self._counter)

        # ##
        # Connect signals
        # ##

        connect(self._prev_button.clicked, self.showPrevious)
        connect(self._next_button.clicked, self.showNext)
        connect(self._categories.currentIndexChanged, self.showCurrent)
        connect(self._close_btn.clicked, self.hide)
        connect(self._close_btn.clicked, self.hidden)
        connect(self._view.customContextMenuRequested, self._onViewContextMenuRequested)
        connect(self._view.usageVisibilityToggled, self.setUsageVisibility)
        connect(self._ops[self.ShowGroups].triggered, self._showSelection)
        connect(self._ops[self.HideGroups].triggered, self._hideSelection)
        connect(self._ops[self.FitSelection].triggered, self._fitSelection)
        connect(self._ops[self.WhatsThisFromContextMenu].triggered, self._showWhatsThis)

        # ##
        # Finalize intialization
        # ##

        self._update_controls()
        self.hide()

    def setVisible(self, visible):
        """Reimplemented from *QFrame*."""
        if not visible and not self.isVisible():
            return
        super().setVisible(visible)
        if not visible and self._model is not None:
            erase = True
            for meshfile, meshname in self._model.meshes:
                self._meshView().displayMEDFileName(meshfile, meshname, 1.0, erase)
                erase = False

    def updateTranslations(self):
        """
        Update translations in GUI elements.
        """
        cmd_name = self._model.command_title if self._model is not None else ''
        is_analysis = self._model.show_categories if self._model is not None else False
        title = translate("AsterStudy", "Analysis summary for {}") if is_analysis \
            else translate("AsterStudy", "Groups involved in {}")
        self._title.setText(preformat(title.format(cmd_name)))

    def showInfo(self, **kwargs):
        """
        Show information on given command.

        The following keyword arguments are supported:

        * command (Command): Command object.
        * is_analysis (bool): Show analysis when *True* or groups involved when *False*.
            Defaults to *False*.
        * storage (dict): Command's storage.
        * title (str): Command's title.
        * name (str): Command's name.

        Note:
            * `command` and `storage` arguments are mutually exclusive.
            * `is_analysis` argument is applicable only when `command` is specified.
            * `title` and `name` arguments are applicable only when `storage` is specified.

        Arguments:
            **kwargs: Keywords arguments.
        """

        # Reset previous groups to default state
        self._setGroupsVisibility(False)

        # initialize model
        self._model = Model(self)
        self._model.init(**kwargs)

        # update title
        self.updateTranslations()

        # display meshes
        for meshfile, meshname in self._model.meshes:
            self._meshView().displayMEDFileName(meshfile, meshname, 0.1, False)

        # update categories
        blocked = self._categories.blockSignals(True)
        self._categories.clear()
        self._categories.addItem(translate("GroupPanel", "All"))
        if self._model.show_categories:
            self._categories.addItems(self._model.categories)
        self._categories.setVisible(self._model.show_categories)
        self._categories.blockSignals(blocked)

        # show panel
        self.show()

        # show default category
        self.showCurrent()

    @Q.pyqtSlot()
    def showPrevious(self):
        """Show previous chunk of data."""
        if self._model is None:
            return
        self._setGroupsVisibility(False)
        self._view.setModel(self._model.previous())
        self._view.updateGridSize()
        connect(self._view.selectionModel().selectionChanged, self._update_controls)
        connect(self._view.selectionModel().selectionChanged, self._onListSelectionChanged)
        self._update_controls()
        self._setGroupsVisibility(True)

    @Q.pyqtSlot()
    def showNext(self):
        """Show next chunk of data."""
        if self._model is None:
            return
        self._setGroupsVisibility(False)
        self._view.setModel(self._model.next())
        self._view.updateGridSize()
        connect(self._view.selectionModel().selectionChanged, self._update_controls)
        connect(self._view.selectionModel().selectionChanged, self._onListSelectionChanged)
        self._update_controls()
        self._setGroupsVisibility(True)

    @Q.pyqtSlot()
    def showCurrent(self):
        """Update current chunk of data."""
        if self._model is None:
            return
        self._setGroupsVisibility(False)
        filter_string = '^{}$'.format(self._categories.currentText()) \
            if self._categories.currentIndex() > 0 else ''
        self._view.setModel(self._model.filter(filter_string))
        self._view.updateGridSize()
        connect(self._view.selectionModel().selectionChanged, self._update_controls)
        connect(self._view.selectionModel().selectionChanged, self._onListSelectionChanged)
        self._update_controls()
        self._update_cache()
        self._setGroupsVisibility(True)

        if any(lambda x: len(x) > 1 for x in self._groups_usages.values()):
            text = translate('GroupPanel', 'Some groups are used multiple times.')
            self._astergui.showNotification(text)

    def _meshView(self):
        """Get mesh view."""
        return self._astergui.workSpace().panel(Panel.View)

    def _update_controls(self):
        """Update controls."""
        can_show = False
        can_hide = False
        for index in self._view.selectedIndexes():
            grtype = index.data(Model.GroupTypeRole)
            if grtype is None:
                continue

            if behavior().recalculate_usages_visibility:
                is_visible = index.data(Model.VisibilityRole)
                can_show = can_show or not is_visible
                can_hide = can_hide or is_visible
            else:
                for group in index.data(Model.GroupsRole):
                    for meshfile, meshname in self._model.meshes:
                        is_visible = self._meshView().alreadyOnDisplay(meshfile, meshname,
                                                                       group, grtype)
                        can_show = can_show or not is_visible
                        can_hide = can_hide or is_visible
                        if can_show and can_hide:
                            break
                    if can_show and can_hide:
                        break
            if can_show and can_hide:
                break

        nb_previous = self._model.nb_previous if self._model is not None else 0
        tip = translate("GroupPanel", "Show previous {} usages")
        self._prev_button.setToolTip(tip.format(nb_previous))
        self._prev_button.setEnabled(nb_previous > 0)

        nb_next = self._model.nb_next if self._model is not None else 0
        tip = translate("GroupPanel", "Show next {} usages")
        self._next_button.setToolTip(tip.format(nb_next))
        self._next_button.setEnabled(nb_next > 0)

        current_range = self._model.current_range if self._model is not None else (0, 0)
        total = self._model.count  if self._model is not None else 0
        self._counter.setText('{0[0]}-{0[1]}/{1}'.format(current_range, total))

        self._controls.setVisible(nb_previous + nb_next > 0)
        self._ops[self.ShowGroups].setVisible(can_show)
        self._ops[self.HideGroups].setVisible(can_hide)
        try:
            fit_enabled = self._meshView().isFeatureSupported('fit_objects')
        except AttributeError:
            fit_enabled = False
        self._ops[self.FitSelection].setVisible(fit_enabled and can_hide)

    def _update_cache(self):
        """
        Updates data in ``_groups_visibility`` and ``_groups_usages``.
        """
        self._groups_visibility.clear()
        self._groups_usages.clear()
        for row in range(self._view.model().rowCount()):
            index = self._view.model().index(row, 0)
            groups = index.data(Model.GroupsRole)
            grtype = index.data(Model.GroupTypeRole)
            if not groups:
                continue
            for group in groups:
                self._groups_visibility[group, grtype] = index.data(Model.VisibilityRole)
                self._groups_usages.setdefault((group, grtype), []).append(index)

    def _setGroupsVisibility(self, visible):
        """Redisplay currently selected groups in mesh view."""
        if self._view.model() is None:
            return
        for row in range(self._view.model().rowCount()):
            index = self._view.model().index(row, 0)
            is_shown = index.data(Model.VisibilityRole)
            if visible and is_shown:
                self._showUsage(index)
            else:
                self._hideUsage(index)

    @Q.pyqtSlot(Q.QModelIndex, bool)
    def setUsageVisibility(self, index, visibility):
        """
        Shows or hides group in mesh view corresponding to given `index`
        and, if neccessary, updates colors for groups from usages that intersect with current.

        Arguments:
            index (Q.QModelIndex):
            visibility (bool):
        """
        if not behavior().recalculate_usages_visibility:
            if visibility:
                self._showUsage(index)
            else:
                self._hideUsage(index)
            self._update_controls()
            return

        groups = index.data(Model.GroupsRole)
        grtype = index.data(Model.GroupTypeRole)

        if visibility:
            show_notification = False
            for group in groups:
                usages = self._groups_usages[group, grtype]

                # Redisplay the group using the usage's color
                usages.append(index)
                color = index.data(Model.ColorRole)
                self._showGroup(group, grtype, color, force=True)

                # If the group is now used more than once, show a warning
                if len(usages) > 1:
                    show_notification = True

            # The warning is shown once, even if we found many groups used multiple times each
            if show_notification:
                text = translate('GroupPanel', 'Some groups are used multiple times.')
                self._astergui.showNotification(text)
        else:
            for group in groups:
                usages = self._groups_usages[group, grtype]

                # Remove current usage from the group's usages
                # If it was the last entry (which means it was actually used), use previous one
                # If it was the only usage for this group, hide the group
                if len(usages) > 1 and usages[-1] == index:
                    usages.remove(index)
                    color = usages[-1].data(Model.ColorRole)
                    self._showGroup(group, grtype, color, force=True)
                elif index in usages:
                    usages.remove(index)
                    if not usages:
                        self._hideGroup(group, grtype)

                # Maybe we have just removed last conflict between any usages
                # In that case, hide the warning if we had shown it earlier
                if all(len(x) <= 1 for x in self._groups_usages.values()):
                    text = translate('GroupPanel', 'Some groups are used multiple times.')
                    self._astergui.hideNotification(text)

        self._view.model().setData(index, visibility, Model.VisibilityRole)
        self._update_controls()

    def _showUsage(self, index):
        """
        Display group in mesh view.

        Arguments:
            index (QModelIndex): Model index.
        """
        grtype = index.data(Model.GroupTypeRole)
        grouplist = index.data(Model.GroupsRole)
        color = index.data(Model.ColorRole)

        if grtype is None:
            return
        if not color:
            return

        for group in grouplist:
            self._showGroup(group, grtype, color)

    def _hideUsage(self, index):
        """
        Erase group in mesh view.

        Arguments:
            index (QModelIndex): Model index.
        """
        grtype = index.data(Model.GroupTypeRole)
        grouplist = index.data(Model.GroupsRole)
        if grtype is None:
            return

        for group in grouplist:
            self._hideGroup(group, grtype)

    def _showGroup(self, group, grtype, color, force=False):
        """
        Shows `group` in mesh view and highlights it with given `color`.

        Arguments:
            group (str):
            grtype (int):
            color (Q.QColor):
            force (bool):
        """
        rgb = color.redF(), color.greenF(), color.blueF()
        for meshfile, meshname in self._model.meshes:
            if self._meshView().displayMeshGroup(meshfile, meshname, group, grtype, rgb, force):
                self._groups_visibility[group, grtype] = True
                return

    def _hideGroup(self, group, grtype):
        """
        Hides `group` from mesh view.

        Arguments:
            group (str):
            grtype (int):
        """
        for meshfile, meshname in self._model.meshes:
            if self._meshView().undisplayMeshGroup(meshfile, meshname, group, grtype):
                self._groups_visibility[group, grtype] = False
                return

    @Q.pyqtSlot(bool)
    def _showSelection(self):
        for index in self._view.selectedIndexes():
            self.setUsageVisibility(index, True)

    @Q.pyqtSlot(bool)
    def _hideSelection(self):
        for index in self._view.selectedIndexes():
            self.setUsageVisibility(index, False)

    @Q.pyqtSlot(bool)
    def _fitSelection(self):
        for index in self._view.selectedIndexes():
            grtype = index.data(Model.GroupTypeRole)
            grouplist = index.data(Model.GroupsRole)

            if grtype is not None:
                meshiter = iter(self._model.meshes)
                try:
                    meshfile, meshname = next(meshiter)
                    while not self._meshView().fitObjects(meshfile, meshname, grouplist, grtype):
                        meshfile, meshname = next(meshiter)
                except StopIteration:
                    pass

    @Q.pyqtSlot()
    def _showWhatsThis(self):
        index = self._view.currentIndex()
        text = index.data(Q.Qt.WhatsThisRole)
        pos = Q.QCursor.pos()
        Q.QWhatsThis.showText(pos, text)

    @Q.pyqtSlot()
    def _onListSelectionChanged(self):
        if not behavior().mesh_view_handle_selection:
            return

        selected_meshes = []
        selected = self._view.selectedIndexes()
        for index in selected:
            grtype = index.data(Model.GroupTypeRole)
            groups = index.data(Model.GroupsRole)
            if not groups:
                continue
            for meshfile, meshname in self._model.meshes:
                for group in groups:
                    selected_meshes.append((meshfile, meshname, group, grtype))

        self._meshView().setSelected(selected_meshes)

    @Q.pyqtSlot(Q.QPoint)
    def _onViewContextMenuRequested(self, pos):
        """
        Called when the list view's context menu is called.

        Arguments:
            pos (Q.QPoint):
        """
        index = self._view.indexAt(pos)
        if index.data(Model.PathRole) is not None:
            menu = Q.QMenu()
            menu.addAction(self._ops[self.ShowGroups])
            menu.addAction(self._ops[self.HideGroups])
            menu.addAction(self._ops[self.FitSelection])
            menu.addAction(self._ops[self.WhatsThisFromContextMenu])
            menu.exec_(self._view.mapToGlobal(pos))


class Model(Q.QObject):
    """Model to store groups dictionary."""

    PathRole = Q.Qt.UserRole + 1
    CategoryRole = Q.Qt.UserRole + 2
    GroupTypeRole = Q.Qt.UserRole + 3
    GroupsRole = Q.Qt.UserRole + 4
    KeywordsRole = Q.Qt.UserRole + 5
    ColorRole = Q.Qt.UserRole + 6
    VisibilityRole = Q.Qt.UserRole + 7
    PrettyPathRole = Q.Qt.UserRole + 8

    def __init__(self, parent=None):
        """Create model."""
        super().__init__(parent)

        self.model = Q.QStandardItemModel(self)
        self.proxy = Q.QSortFilterProxyModel(self)
        self.proxy.setSourceModel(self.model)
        self.proxy.setFilterRole(self.CategoryRole)
        self.meshes = []
        self.current_index = 0
        self.show_categories = False
        self.title = {}

    def init(self, **kwargs):
        """Initialize model."""
        self.meshes = []
        self.current_index = 0
        self.show_categories = kwargs.get('is_analysis', False)

        # get command title
        self.title = extract_title(**kwargs)

        # get meshes
        for mesh in available_meshes(**kwargs):
            meshfile, meshname = get_cmd_mesh(mesh)
            if (meshfile, meshname) not in self.meshes:
                self.meshes.append((meshfile, meshname))

        # get groups dictionary
        for path, group_type, groups, keywords in available_groups(**kwargs):
            item = UsageItem(path, group_type, groups, keywords, self.show_categories)
            self.model.appendRow(item)

    @property
    def command_title(self):
        """Get translated command name."""
        return decorate_command_name(**self.title)

    @property
    def chunk_size(self):
        """Get chunk size."""
        return behavior().summary_chunk

    @property
    def index(self):
        """Get current index."""
        return self.current_index

    @property
    def count(self):
        """Get current number of rows."""
        return self.proxy.rowCount()

    @property
    def nb_pages(self):
        """Get current number of pages."""
        from math import ceil
        return int(ceil(self.count * 1.0 / self.chunk_size))

    @property
    def has_previous(self):
        """Check if there is previous page to show."""
        return self.index > 0

    @property
    def has_next(self):
        """Check if there is next page to show."""
        return (self.index + 1) * self.chunk_size < self.count

    @property
    def nb_previous(self):
        """Get size of previous chunk."""
        return self.chunk_size if self.has_previous else 0

    @property
    def nb_next(self):
        """Get size of next chunk."""
        return min(self.chunk_size, max(0, self.count - (self.index+1)*self.chunk_size))

    @property
    def current_range(self):
        """Get currently shown range."""
        return (self.index*self.chunk_size+1, min((self.index+1)*self.chunk_size, self.count)) \
            if self.count else (0, 0)

    @property
    def categories(self):
        """Get available categories."""
        categories = [self.model.item(i).data(self.CategoryRole) \
                          for i in range(self.model.rowCount())]
        return [category for category in CATA.get_categories() if category in categories]

    def previous(self):
        """Switch to previous page."""
        self.current_index = max(self.index-1, 0)
        return self.current()

    def next(self):
        """Switch to next page."""
        self.current_index = min(self.index+1, self.nb_pages-1)
        return self.current()

    def current(self): # pragma pylint: disable=too-many-locals
        """Get current chunk of data."""
        model = Q.QStandardItemModel(self)
        lower = self.index * self.chunk_size
        upper = (self.index+1) * self.chunk_size
        current_category = None
        wo_filter = not self.proxy.filterRegExp().pattern()
        nb_colors = 0

        for i in range(lower, upper):
            if i < self.proxy.rowCount():
                model_index = self.proxy.index(i, 0)
                path = model_index.data(self.PathRole)
                pretty_path = model_index.data(self.PrettyPathRole)
                group_type = model_index.data(self.GroupTypeRole)
                groups = model_index.data(self.GroupsRole)
                visibility = model_index.data(self.VisibilityRole)
                keywords = model_index.data(self.KeywordsRole)
                category = model_index.data(self.CategoryRole)

                if self.show_categories and wo_filter and category != current_category:
                    current_category = category
                    pixmap = load_icon('as_ico_category.png')
                    group_item = Q.QStandardItem(pixmap, current_category)
                    group_item.setToolTip(current_category)
                    group_item.setFlags(Q.Qt.NoItemFlags)
                    font = group_item.font()
                    font.setItalic(True)
                    group_item.setFont(font)
                    group_item.setForeground(Q.Qt.blue)
                    model.appendRow(group_item)

                    if i > 0 and behavior().summary_elide_category:
                        prev_index = self.proxy.index(i-1, 0)
                        prev_category = prev_index.data(self.CategoryRole)
                        if prev_category == current_category:
                            title = translate("GroupPanel", "... more usages in this category")
                            fake_item = Q.QStandardItem(title)
                            fake_item.setFlags(Q.Qt.NoItemFlags)
                            font = group_item.font()
                            font.setItalic(True)
                            fake_item.setFont(font)
                            fake_item.setForeground(Q.Qt.darkGray)
                            model.appendRow(fake_item)

                copy_item = UsageItem(path, group_type, groups, keywords, self.show_categories)
                copy_item.setData(visibility, self.VisibilityRole)
                copy_item.setFlags(Q.Qt.ItemIsEnabled | Q.Qt.ItemIsSelectable)

                whatsthis = '<h3>{}</h3>{}'.format(translate('GroupPanel', 'Usage'), pretty_path)
                if groups:
                    whatsthis += '<br/><h3>{}</h3>'.format(translate('GroupPanel', 'Groups'))
                    whatsthis += ', '.join(groups)
                if keywords:
                    whatsthis += '<br/><h3>{}</h3>'.format(translate('GroupPanel', 'Keywords'))
                    whatsthis += _stringify_value(keywords, pretty=True)
                copy_item.setWhatsThis(whatsthis)
                copy_item.setToolTip(whatsthis)

                model.appendRow(copy_item)

                if group_type is not None:
                    nb_colors += 1

                if self.show_categories and wo_filter:
                    if i == upper-1 and i < self.proxy.rowCount()-1 and \
                            behavior().summary_elide_category:
                        next_index = self.proxy.index(i+1, 0)
                        next_category = next_index.data(self.CategoryRole)
                        if next_category == category:
                            title = translate("GroupPanel", "... more usages in this category")
                            fake_item = Q.QStandardItem(title)
                            fake_item.setFlags(Q.Qt.NoItemFlags)
                            font = group_item.font()
                            font.setItalic(True)
                            fake_item.setFont(font)
                            fake_item.setForeground(Q.Qt.darkGray)
                            model.appendRow(fake_item)

        # Assign colors to the rows
        color_index = 0
        for i in range(model.rowCount()):
            index = model.index(i, 0)

            # Skip items that represent categories
            # (they have icons already)
            if index.data(Q.Qt.DecorationRole) is not None:
                continue

            # Skip items for TOUT=OUI
            # (they will have white icons)
            if index.data(self.GroupTypeRole) is not None:
                color = Q.QColor.fromHsv(int(360/nb_colors*(color_index%nb_colors)), 245, 245, 255)
                model.setData(index, color, self.ColorRole)
                color_index += 1

        return model

    def filter(self, filter_string):
        """Set filter."""
        self.current_index = 0
        self.proxy.setFilterRegExp(filter_string)
        return self.current()

    def setVisible(self, path, visible):
        """Set path's visibility."""
        for i in range(self.model.rowCount()):
            item = self.model.item(i)
            if item.text() == path:
                item.setData(visible, self.VisibilityRole)
                break


class ResizableListView(Q.QListView):
    """Customized list view which reimplements resizeEvent to adjust column width."""

    FIXED_CELL_HEIGHT = 32
    FIXED_CELL_WIDTH = 300

    usageVisibilityToggled = Q.pyqtSignal(Q.QModelIndex, bool)

    def setModel(self, model):
        """
        Arguments:
            model (Q.QStandardItemModel):
        """
        super(ResizableListView, self).setModel(model)
        for row in range(model.rowCount()):
            self.updateItemIcon(model.index(row, 0))

    def updateGridSize(self):
        """Update grid size."""
        old_grid_size = self.gridSize()
        new_grid_size = old_grid_size
        size = self.size()
        margin = 0
        if behavior().summary_use_resizable_list and self.model() is not None and size.height() > 0:
            max_width = max([self.sizeHintForIndex(self.model().index(i, 0)).width() \
                                 for i in range(self.model().rowCount())] + [0])
            nb_rows = (size.height()-margin) / self.FIXED_CELL_HEIGHT
            nb_cols = self.model().rowCount() / nb_rows
            if nb_cols*nb_rows != self.model().rowCount():
                nb_cols += 1
            if nb_cols > 0:
                width = min(max(self.FIXED_CELL_WIDTH, size.width()/nb_cols), max_width)
                if width * nb_cols > size.width() and nb_rows > 1:
                    # need scroll bar
                    nb_rows = nb_rows-1
                    nb_cols = self.model().rowCount() / nb_rows
                    if nb_cols*nb_rows != self.model().rowCount():
                        nb_cols += 1
                    width = min(max(self.FIXED_CELL_WIDTH, size.width()/nb_cols), max_width)
                new_grid_size = Q.QSize(width, self.FIXED_CELL_HEIGHT)
        if old_grid_size != new_grid_size:
            self.setUpdatesEnabled(False)
            self.setGridSize(new_grid_size)
            self.setUpdatesEnabled(True)

    def resizeEvent(self, event):
        """Reimplemented from *QListView*."""
        super().resizeEvent(event)
        self.updateGridSize()

    def mousePressEvent(self, event):
        """
        Arguments:
            event (Q.QMouseEvent):
        """
        index = self.indexAt(event.pos())
        item_rect = self.visualRect(index)
        eye_rect = _eyeRect()
        eye_rect.translate(item_rect.topLeft())
        eye_rect.translate(self.style().pixelMetric(Q.QStyle.PM_FocusFrameHMargin) + 1,
                           self.style().pixelMetric(Q.QStyle.PM_FocusFrameHMargin) + 1)
        eye_rect.adjust(-2, -2, 2, 2)

        if eye_rect.contains(event.pos()) \
        and event.type() == Q.QMouseEvent.MouseButtonPress:
            # Toggle value for VisibilityRole
            visibility = not index.data(Model.VisibilityRole)
            self.model().setData(index, visibility, Model.VisibilityRole)
            self.model().parent().setVisible(index.data(Q.Qt.DisplayRole), visibility)

            # Update icon
            self.updateItemIcon(index)
            self.update(index)

            # Inform subscribers about visibility change
            self.usageVisibilityToggled.emit(index, visibility)

        else:
            super(ResizableListView, self).mousePressEvent(event)

    def updateItemIcon(self, index):
        """
        Arguments:
            index (Q.QModelIndex):
        """
        if index.flags() == Q.Qt.NoItemFlags:
            return

        # Prepare to draw icon
        pixmap = Q.QPixmap(_iconSize())
        rect = Q.QRect(Q.QPoint(0, 0), _iconSize())
        painter = Q.QPainter()
        painter.begin(pixmap)

        # Load color assigned to the item
        color = index.data(Model.ColorRole)

        # For a normal usage, render colorful icon with Show/Hide control
        if color:
            pixmap.fill(color)
            eye_icon_name = 'as_ico_eye_off.png' if index.data(Model.VisibilityRole) \
                else 'as_ico_eye_on.png'
            eye_rect = _eyeRect()
            eye_pixmap = load_pixmap(eye_icon_name, size=(eye_rect.width(), eye_rect.height()))
            painter.drawPixmap(eye_rect, eye_pixmap)

        # For a TOUT=OUI usage, render white icon the word 'Everywhere'
        else:
            pixmap.fill(Q.QColor(Q.Qt.white))
            painter.setPen(Q.QPen(Q.QColor(Q.Qt.darkGray), 1, Q.Qt.DotLine))
            painter.drawRect(rect.adjusted(0, 0, -1, -1))
            font = painter.font()
            font.setBold(True)
            painter.setFont(font)
            painter.drawText(rect, Q.Qt.AlignCenter, translate('GroupPanel', 'Everywhere'))

        painter.end()
        self.model().setData(index, Q.QIcon(pixmap), Q.Qt.DecorationRole)


def available_meshes(**kwargs):
    """
    Get available meshes.
    """
    result = []
    if 'command' in kwargs:
        result = avail_meshes_in_cmd(kwargs.get('command'))
    elif 'storage' in kwargs:
        result = avail_meshes(kwargs.get('storage'))
    return result


def extract_title(**kwargs):
    """
    Extract command title data.
    """
    result = {}
    if 'command' in kwargs:
        command = kwargs.get('command')
        result['name'] = command.name if not is_noname(command) \
            else translate("AsterStudy", "[noname]")
        result['title'] = command.title
    elif 'title' in kwargs:
        name = kwargs.get('name', '_')
        if name == '_':
            name = translate("AsterStudy", "[noname]")
        result['name'] = name
        result['title'] = kwargs.get('title')
    return result


def decorate_command_name(**kwargs):
    """Get decorated command name."""
    name = kwargs.get('name', '')
    title = translate_command(kwargs.get('title', ''))
    return '{} ({})'.format(bold(name), italic(title))


def available_groups(**kwargs):
    """
    Get available usages for given `command` or `storage`.

    Result is a list of tuples, each tuple containing four items:
        - path to the usage
        - type of the groups (see ``MeshGroupType``)
        - names of groups mentioned in the usage
        - related keywords

    The list is sorted by paths.

    Returns:
        list
    """
    result = []

    if 'command' in kwargs:
        command = kwargs.get('command')
        is_analysis = kwargs.get('is_analysis', False)
        if is_analysis:
            for k, (v1, v2, v3) in avail_groups(command.storage_nocopy, command.title).items():
                result.append((k, v1, v2, v3))
            for k, v3 in tout_usage(command.storage_nocopy, command.title).items():
                result.append((k, None, None, v3))
        else:
            for k, (v1, v2, v3) in avail_groups_in_cmd(command).items():
                result.append((k, v1, v2, v3))
            for k, v3 in tout_usage_in_cmd(command).items():
                result.append((k, None, None, v3))

    elif 'storage' in kwargs:
        storage = kwargs.get('storage')
        title = kwargs.get('title')
        for k, (v1, v2, v3) in avail_groups_in_storage(storage, title).items():
            result.append((k, v1, v2, v3))
        for k, v3 in tout_usage_in_storage(storage, title).items():
            result.append((k, None, None, v3))

    result.sort(key=lambda x: _key(x[0]))
    return result


def _key(path):
    """Provides a sortable representation of a group's path."""
    key = []
    for part in path.split('.'):
        if part.isdigit():
            key.append(int(part))
        else:
            key.append(part)
    return key


class UsageItem(Q.QStandardItem):
    """
    Item representing a single usage.
    """
    def __init__(self, path, group_type, groups, keywords, show_categories):
        """
        Arguments:
            path (str): Path to command.
            group_type (int): Group type (see ``MeshGroupType``).
            groups (list[str]): Names of groups mentioned in the usage.
            keywords (dict[str,Any]): Related keywords from the usage.
            show_categories (bool): Show command title in item's text or not.
        """
        super().__init__()
        self.setData(path, Model.PathRole)
        self.setData(group_type, Model.GroupTypeRole)
        self.setData(groups, Model.GroupsRole)
        self.setData(keywords, Model.KeywordsRole)
        self.setData(True, Model.VisibilityRole)
        self.show_categories = show_categories

    def data(self, role=None, *args, **kwargs):  # pragma pylint: disable=keyword-arg-before-vararg
        """
        For ``Qt.DisplayRole``, returns usage's path (optionally prefixed by command name)
        and list of related keywords with their values.

        For ``Model.CategoryRole``, returns name of the command's category.
        """
        if role in (Q.Qt.DisplayRole, Model.PrettyPathRole):
            path = self.data(Model.PathRole)
            new_path = []

            path_ids = path.split('.')

            # Trim leading .
            path_ids.pop(0) # trim leading .

            # Render command title, if needed
            title = path_ids.pop(0)
            if self.show_categories:
                # business translation for command title
                new_path.append(translate_command(title))

            # Render all other components
            for item in path_ids:
                if item.isdigit():
                    new_path.append(item) # treat index in sequence
                elif item in ("GROUP_MA", "GROUP_NO"):
                    # There are special cases not taken into account here
                    #    i.e. GROUP_MA not into a factor keyword
                    #    or GROUP_MA_1 / GROUP_MA_2 case
                    break
                else:
                    # business translation for keyword
                    new_path.append(translate_command(title, item))

            result = ' / '.join(new_path)

            # Render related keywords
            if role != Model.PrettyPathRole:
                keywords = self.data(Model.KeywordsRole)
                if keywords:
                    result += '; ' + _stringify_value(keywords)

            return result

        if role == Model.CategoryRole:
            path = self.data(Model.PathRole)
            title = path.split('.')[1]
            return CATA.get_command_category(title)

        return super().data(role, *args, **kwargs)


def _stringify_value(value, pretty=False):
    """
    Helper function for rendering values of related keywords in ``UsageItem.data()``.
    Supports recursive walking through list, tuples and dicts.
    For a ``Command``, renders its name.
    For a ``str``, renders the value in quotation marks.
    For all other types, just calls ``str(value)``.

    Returns:
        str
    """
    if isinstance(value, dict):
        if pretty:
            return ', '.join(['<b>{}</b>={}'.format(k, _stringify_value(v, pretty))
                              for (k, v) in value.items()])
        return ', '.join(['{}={}'.format(k, _stringify_value(v, pretty))
                          for (k, v) in value.items()])
    if isinstance(value, tuple):
        if len(value) == 1:
            return '(' + _stringify_value(value[0], pretty) + ',)'
        return '(' + ','.join((_stringify_value(i, pretty) for i in value)) + ')'
    if isinstance(value, list):
        return '[' + ','.join((_stringify_value(i, pretty) for i in value)) + ']'
    if isinstance(value, Command):
        return '<em>{}</em>'.format(value.name) if pretty else value.name
    if isinstance(value, str):
        return repr(str(value))
    return repr(value)


def _iconSize():
    """
    Calculates appropriate size for icon, based on metrics for text 'Everywhere'.

    Returns:
        Q.QSize
    """
    if not hasattr(_iconSize, 'width') \
    or not hasattr(_iconSize, 'height'):
        everywhere_text = translate('GroupPanel', 'Everywhere')
        font = Q.QApplication.font()
        font.setBold(True)
        rect = Q.QFontMetrics(font).boundingRect(everywhere_text)
        rect.adjust(-20, -5, 20, 5)
        _iconSize.width = rect.width()
        _iconSize.height = rect.height()
    return Q.QSize(_iconSize.width, _iconSize.height)


def _eyeRect():
    """
    Calculates size of rectangle that should contain eye icon,
    relative to top left corner of the colorful icon from ``_iconSize()``.

    Returns:
        Q.QRect
    """
    icon_height = _iconSize().height() - 4
    return Q.QRect(5, 2, icon_height, icon_height)
