# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Command text editor
-------------------

The module implements a panel to edit command in text mode.

"""


from PyQt5 import Qt as Q

from . import Context
from .controller import WidgetController
from .editionwidget import EditionWidget
from .widgets import TextEditor
from ..common import enable_autocopy, load_pixmap, translate

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name


class CmdTextEditor(EditionWidget, WidgetController):
    """Command text editor widget."""

    def __init__(self, command, astergui, parent=None, **kwargs):
        """
        Create editor.

        Arguments:
            command (Command): Command to edit.
            astergui (AsterGui): AsterGui instance.
            parent (Optional[QWidget]): Parent widget. Defaults to
                *None*.
            **kwargs: Keyword arguments.
        """
        super().__init__(parent=parent,
                         name=translate("CmdTextEditor", "Edit command"),
                         astergui=astergui, **kwargs)

        self.command = command
        self.prev_text = command.text

        title = translate("CmdTextEditor", "Edit command")
        self.setWindowTitle(title)
        self.setPixmap(load_pixmap("as_pic_edit_command.png"))

        self.editor = TextEditor(self)
        self.editor.setText(self.prev_text)
        self.editor.textChanged.connect(self.updateButtonStatus)
        self.setFocusProxy(self.editor)
        if astergui is not None:
            astergui.preferencesChanged.connect(self.editor.updateSettings)
            self.editor.updateSettings(astergui.preferencesMgr())

        v_layout = Q.QVBoxLayout(self)
        v_layout.setContentsMargins(0, 0, 0, 0)
        v_layout.setSpacing(5)
        v_layout.addWidget(self.editor)

    def isButtonEnabled(self, button):
        """
        Redefined from *EditionWidget* class.
        """
        if button in (Q.QDialogButtonBox.Ok, Q.QDialogButtonBox.Apply):
            return self.hasModifications() and self.command.check_text(self.editor.text())
        return True

    def hasModifications(self):
        return self.editor.text() != self.prev_text

    def applyChanges(self):
        """
        Redefined from *EditionWidget* class.
        """
        with enable_autocopy(self.astergui().study().activeCase):
            try:
                text = self.editor.text()
                self.command.text = text
                self.prev_text = text
                msg = translate("CmdTextEditor", "Edit command")
                self.astergui().study().commit(msg)
                self.astergui().update(autoSelect=self.command,
                                       context=Context.DataSettings)
            except Exception: # pragma pylint: disable=broad-except
                self.astergui().study().revert()

    def setReadOnly(self, on):
        """
        Redefined from *EditionWidget* class.
        """
        super().setReadOnly(on)
        self.editor.setReadOnly(on)

    def controllerStart(self):
        """Reimplemented from WidgetController."""
        super().controllerStart()
        self.astergui().workSpace().setMeshViewEnabled(False)

    def controllerStop(self):
        """Reimplemented from WidgetController."""
        self.astergui().workSpace().setMeshViewEnabled(True)
        super().controllerStop()
