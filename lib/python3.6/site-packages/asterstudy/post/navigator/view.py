# -*- coding: utf-8 -*-

# Copyright 2019 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
Results Navigator TreeView
--------------------------

Implementation of ResultsNavigatorTree for AsterStudy application.

Defines view of the contents of loaded result files.

"""

from functools import partial
from PyQt5 import Qt as Q

from ...common import translate
from ..result_data import ConceptField
from ..representation import (ColorRep, WarpRep,
                              ContourRep, VectorRep, ModesRep)

from ..config import (WARP_READY_FIELDS, VECTOR_READY_FIELDS,
                      FIELDS_WITH_MAG, REPRESENTATIONS)


class ResultsNavigatorTree(Q.QTreeView):
    """
    Overloaded QTreeView class providing customized selection and context menu
    for the navigation tree items in Results tab of AsterStudy.
    """

    def __init__(self, *args):
        """Create navigator view asociated with the results tab."""
        Q.QTreeView.__init__(self, *args)
        self.setFont(self.parent().font())

        self.setSelectionMode(Q.QTreeView.SingleSelection)
        self.setAllColumnsShowFocus(True)

        # Capture double clicking tree items for default view
        self.doubleClicked.connect(self.load)

    # pragma pylint: disable=invalid-name
    def setModel(self, model):
        """
        Set model for the tree view.
        """
        Q.QTreeView.setModel(self, model)
        self.model().view = self

        self.setItemDelegate(BoldDelegate(self))
        self.customize()

    def customize(self):
        """
        Called by setModel and by model's clear method, insure
        that the customizations are reinforces at all times
        """
        self.setColumnWidth(0, 150)
        # self.setColumnWidth(1, 200)

        self.expandToDepth(1)
        self.setIndentation(10)

        self.setSortingEnabled(True)
        self.setHeaderHidden(False)

        self.model().setHorizontalHeaderLabels(
            ['Concept/field name', 'Information'])

        self.setMinimumWidth(450)
        self.setSizePolicy(Q.QSizePolicy.MinimumExpanding,
                           Q.QSizePolicy.Expanding)

        self.setHorizontalScrollBarPolicy(Q.Qt.ScrollBarAlwaysOff)
        self.header().setSectionResizeMode(Q.QHeaderView.Fixed)
        self.setAlternatingRowColors(True)

    def selection(self):
        """
        Returns the selection object (concept or field)
        """
        selection = self.selectedIndexes()

        if selection:
            selection = selection[0]
        else:
            # This is added to allow right click on the PV view
            return self.model().results.shown.field

        root = self.model().data(selection.parent(), Q.Qt.DisplayRole)
        base = self.model().data(selection, Q.Qt.DisplayRole)

        if not root:
            # This is a concept node
            return self.model().results.current.lookup(base)

        # This is a field within a concept
        return self.model().results.current.lookup(root).lookup(base)

    # pragma pylint: disable=invalid-name,too-many-locals
    # pragma pylint: disable=too-many-branches,too-many-statements
    def contextMenuEvent(self, source):
        """
        Overloaded method used to fill the context menu depending on the
        current selection.

        source = "Representation" if the right click originates from the
                 PV rendered view widget or its children. Otherwise, it
                 originates indeed from the navigator tree
        """
        results = self.model().results
        if isinstance(source, str):
            if source == "Representation":
                selected = results.shown.field
        else:
            selected = self.selection()

        if not isinstance(selected, ConceptField):
            return

        # Previous representation : field and options
        sfield = results.shown.field
        sopts = results.shown.opts

        menu = Q.QMenu(self)
        menu.setFont(self.font())

        current_time = results.ren_view.ViewTime
        if selected.name in ['DEPL']:
            factor = 0
            if isinstance(results.shown, (WarpRep, ModesRep)):
                factor = results.shown.opts['ScaleFactor']

            msg = "Animate &Mode ({:g} Hz)".format(current_time)
            if isinstance(results.shown, (ModesRep)):
                msg = "Exit mode animation"

            # Animate modes
            action = menu.addAction(translate("Navigator Tree", msg))
            if isinstance(results.shown, (ModesRep)):
                action.triggered.connect(partial(results.represent, selected,
                                                 WarpRep, ScaleFactor=factor))
            else:
                action.triggered.connect(partial(results.represent, selected,
                                                 ModesRep, ScaleFactor=factor))

        if selected.name in WARP_READY_FIELDS:
            # A displacement field is selected
            # - Warp with amplification
            sub_menu = Q.QMenu(
                translate(
                    "Navigator Tree",
                    "&Warp with amplification"),
                self)
            sub_menu.setFont(self.font())
            # menu.setIcon(rc.icons.get("object_assign"))
            sub_menu.menuAction().triggered.connect(partial(results.represent,
                                                            selected, WarpRep))

            vals = [0.0, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0,
                    10.0, 20., 50., 100., 200., 500., 1000., -1.]

            first_entry = 'Disabled'
            if isinstance(results.shown, (WarpRep, ModesRep)):
                set_bold(sub_menu.menuAction())
                first_entry = 'Disable'

            sel_index = 0  # By default, no warp is selected
            if sfield == selected:
                if isinstance(results.shown, (WarpRep, ModesRep)):
                    if 'ScaleFactor' in sopts:
                        if sopts['ScaleFactor'] in vals:
                            sel_index = vals.index(sopts['ScaleFactor'])
                        else:
                            sel_index = len(vals) - 1
                            vals[-1] = sopts['ScaleFactor']

            # Recover selection from previous mode animation
            if selected.name in ['DEPL']:
                if isinstance(results.shown, ModesRep):
                    if sopts['ScaleFactor'] in vals:
                        sel_index = vals.index(sopts['ScaleFactor'])
                    else:
                        sel_index = len(vals) - 1
                        vals[-1] = sopts['ScaleFactor']

            warp_list = [first_entry] + ["%.4gX" %
                                         (f) for f in vals[1:-1]] + ['Auto']
            if vals[-1] != -1.:
                warp_list[-1] = 'Auto [%.4gX]' % (vals[-1])

            default_class = WarpRep
            if isinstance(results.shown, (WarpRep, ModesRep)):
                default_class = results.shown.__class__

            for i, w in enumerate(warp_list):
                forced = True
                def_class = ColorRep
                args = {}
                if i > 0:
                    forced = False
                    def_class = default_class
                    args = {'ScaleFactorAuto': False,
                            'ScaleFactor': vals[i]}
                    if vals[i] < 0:
                        args['ScaleFactorAuto'] = True
                        args.pop('ScaleFactor', None)

                if i == 1:
                    sub_menu.addSeparator()

                action = sub_menu.addAction(w)
                action.triggered.connect(partial(
                    results.represent, selected, def_class,
                    forced=forced, **args))

                if i == len(warp_list) - 2:
                    sub_menu.addSeparator()

                if i == sel_index:
                    set_bold(action)

            menu.addMenu(sub_menu)
            menu.addSeparator()

        # <Color by> actions (field coloring)
        sub_menu = Q.QMenu(translate("Navigator Tree", "&Color by"), self)
        sub_menu.setFont(self.font())
        # menu.setIcon(rc.icons.get("object_assign"))
        comps = selected.info['components']
        field = selected.name
        comps = (['Magnitude'] + comps if field in FIELDS_WITH_MAG
                 else comps)

        cfield = None
        if 'ColorField' in sopts:
            cfield = sopts['ColorField']
            cfield = cfield if cfield != sfield else None
        if cfield is None and sfield == selected:
            set_bold(sub_menu.menuAction())

        repclass = ColorRep
        if results.shown.field == selected:
            repclass = results.shown.__class__

        sel_index = -1
        if cfield is None and sfield == selected:
            if 'Component' in sopts:
                if sopts['Component'] in comps:
                    sel_index = comps.index(sopts['Component'])
        for i, comp in enumerate(comps):
            action = sub_menu.addAction(comp)
            action.triggered.connect(partial(
                results.represent, selected, repclass,
                Component=comp, ColorField=selected))
            if i == sel_index:
                set_bold(action)

        menu.addMenu(sub_menu)

        # <Color by another field> actions (for deformed coloring)
        # Unavailable for 3d shell quadratic meshes (unstable)
        # unavailable if group filtering is activated
        if selected.name in WARP_READY_FIELDS\
           and isinstance(results.shown, WarpRep)\
           and not selected.concept.result.shell3d_quad\
           and not results.shown.opts['GroupsFilter']:
            # Only available if a warp is already on display...
            if sfield == selected:

                concepts = selected.concept.result.concepts
                sub_menu = Q.QMenu(
                    translate(
                        "Navigator Tree",
                        "Color by &another field"),
                    self)
                sub_menu.setFont(self.font())

                cfield, ccomp = (None, None)
                if 'ColorField' in sopts:
                    cfield = sopts['ColorField']
                    ccomp = sopts['Component']
                    # Avoid setting anything bold in this menu if the warp
                    # is colored by displacement
                    cfield = cfield if cfield != sfield else None

                if cfield is not None:
                    set_bold(sub_menu.menuAction())

                cntr = 0  # Counts the number of effectively available choices
                for concept in concepts:
                    sub_menu_2 = Q.QMenu(concept.name, self)
                    if cfield in concept.fields:
                        set_bold(sub_menu_2.menuAction())

                    empty = True
                    for field in concept.fields:
                        if field == selected:
                            continue

                        empty = False
                        # Field label is too long, use ASTER naming...
                        # sub_menu_3 =  Q.QMenu(field.info['label'], self)
                        sub_menu_3 = Q.QMenu(field.name, self)
                        if cfield == field:
                            set_bold(sub_menu_3.menuAction())

                        comps = field.info['components']
                        comps = (['Magnitude'] + comps
                                 if field.name in FIELDS_WITH_MAG else comps)
                        for comp in comps:
                            cntr += 1
                            action = sub_menu_3.addAction(comp)
                            action.triggered.connect(partial(
                                results.represent, selected, WarpRep,
                                ColorField=field, Component=comp))
                            if ccomp == comp and cfield == field:
                                set_bold(action)

                        sub_menu_2.addMenu(sub_menu_3)
                    if not empty:
                        sub_menu.addMenu(sub_menu_2)
                if cntr > 0:
                    menu.addMenu(sub_menu)

        # <Iso-surfaces> actions
        if sfield == selected:

            sub_menu = Q.QMenu(
                translate(
                    "Navigator Tree",
                    "&Iso-surfaces"),
                self)
            sub_menu.setFont(self.font())
            # menu.setIcon(rc.icons.get("object_assign"))

            first_entry = 'Disabled'
            if isinstance(results.shown, ContourRep):
                set_bold(sub_menu.menuAction())
                first_entry = 'Disable'

            vals = [0, 2, 4, 8, 12, 16, 20, 40]
            sel_index = 0
            if sfield == selected and isinstance(results.shown, ContourRep):
                def_class = ColorRep if i == 0 else ContourRep
                if i == 1:
                    sub_menu.addSeparator()

                if 'NbContours' in sopts:
                    if sopts['NbContours'] in vals:
                        sel_index = vals.index(sopts['NbContours'])

            ccomp = sopts['Component']
            cfield = selected if not 'ColorField' in sopts else sopts[
                'ColorField']
            for i, val in enumerate(vals):
                opstr = '{:2}'.format(val) if val else first_entry
                action = sub_menu.addAction(opstr)
                if val == 0:
                    action.triggered.connect(partial(
                        results.represent, cfield, ColorRep,
                        Component=ccomp, forced=True))
                    sub_menu.addSeparator()
                else:
                    action.triggered.connect(partial(
                        results.represent, cfield, ContourRep,
                        NbContours=val, Component=ccomp))
                if i == sel_index:
                    set_bold(action)

            menu.addMenu(sub_menu)

        # <Vector representation> actions
        if selected.name in VECTOR_READY_FIELDS:

            sub_menu = Q.QMenu(translate("Navigator Tree",
                                         "&Vector representation"), self)
            sub_menu.setFont(self.font())

            sel_index = 0
            opts = ['Disabled', 'Enable']
            if isinstance(results.shown, VectorRep)\
                    and sfield == selected:
                set_bold(sub_menu.menuAction())
                sel_index = 1
                opts = ['Disable', 'Enabled']

            ccomp = sopts['Component']
            cfield = selected if not 'ColorField' in sopts else sopts[
                'ColorField']
            for i, opstr in enumerate(opts):
                if i == 0:
                    action = sub_menu.addAction(opstr)
                    action.triggered.connect(partial(
                        results.represent, cfield, ColorRep,
                        forced=True, Component=ccomp))
                    sub_menu.addSeparator()
                else:
                    action = sub_menu.addAction(opstr)
                    action.triggered.connect(partial(
                        results.represent, cfield, VectorRep,
                        Component=ccomp))
                if i == sel_index:
                    set_bold(action)
            menu.addMenu(sub_menu)

        # <Show as> actions (graphic repesentation of mesh support)
        sub_menu = Q.QMenu(translate("Navigator Tree", "&Show as"), self)
        sub_menu.setFont(self.font())
        # menu.setIcon(rc.icons.get("object_assign"))
        sel_index = -1
        if sfield == selected:
            if 'Representation' in sopts:
                if sopts['Representation'] in REPRESENTATIONS:
                    sel_index = REPRESENTATIONS.index(sopts['Representation'])

            for i, rep in enumerate(REPRESENTATIONS):
                action = sub_menu.addAction(translate("Navigator Tree", rep))
                # giving the shown class forces a partial update
                action.triggered.connect(partial(
                    results.represent, selected, results.shown.__class__,
                    Representation=rep))
                if i == sel_index:
                    set_bold(action)

            menu.addSeparator()
            menu.addMenu(sub_menu)

        # <Transparency> actions (change in opacity)
        sub_menu = Q.QMenu(translate("Navigator Tree", "&Transparency"), self)
        sub_menu.setFont(self.font())
        # menu.setIcon(rc.icons.get("object_assign"))
        vals = [0.1 * i for i in range(1, 11)]
        sel_index = 9  # By default, 100% opacity is selected
        if sfield == selected:
            if 'Opacity' in sopts:
                if sopts['Opacity'] in vals:
                    sel_index = vals.index(sopts['Opacity'])

            for i, opt in enumerate(vals):
                opstr = '{:3}%'.format(int(opt * 100))
                action = sub_menu.addAction(opstr)
                # Specifying the shown class insures a partial update is done
                action.triggered.connect(partial(
                    results.represent, selected, results.shown.__class__,
                    Opacity=opt))
                if i == sel_index:
                    set_bold(action)

            menu.addMenu(sub_menu)

        if selected.concept.result.shell3d_quad is not None\
                and sfield == selected:
            # Handle quadratic 3D shells
            action = menu.addAction(translate("Navigator Tree",
                                              "Handle quadratic 3D shells (linearize)"))
            action.triggered.connect(lambda: toggle_shell3d(results))
            if selected.concept.result.shell3d_quad == 1:
                set_bold(action)

            menu.addSeparator()
            menu.addAction(action)

        menu.exec_(Q.QCursor.pos())

    @Q.pyqtSlot(Q.QModelIndex)
    def load(self, index):
        """
        Slot connected to by the double clicking signal
        """
        concept_name = index.model().data(index.parent())
        if concept_name == 'Other':
            concept_name = '<root>'

        if concept_name:
            # Then the double click was on a field item since the concept
            # has no parent in this navigator tree layout !

            # Move the index to the left column in order to find the field name
            r_index = index.parent().child(index.row(), 0)
            field_name = index.model().data(r_index)

            results = self.model().results
            shown = results.shown

            doreload = True
            if shown:
                # Currently bieng viewed, is it the same as the one requested
                doreload = ((concept_name != shown.field.concept.name)
                            or (field_name != shown.field.name))

            if doreload:
                concept = results.current.lookup(concept_name)
                field = concept.lookup(field_name)

                index.model().layoutAboutToBeChanged.emit()
                results.represent(field)
                index.model().layoutChanged.emit()


def toggle_shell3d(results):
    """
    Toggles the 3D shell flag in the current result file then
    reloads the representation
    """
    results.current.toggle_shell3d()
    results.redraw()


def set_bold(action):
    """
    Decorates a given action's display in bold font
    """
    font = action.font()
    font.setBold(True)
    action.setFont(font)


class BoldDelegate(Q.QStyledItemDelegate):
    """
    Item delegate for the navigation tree allowing to handle
    setting bold effect to represented fields.
    """

    def paint(self, painter, option, index):
        """
        On paint callback, check if the item needs to be bold
        """
        # Results main widget
        results = index.model().results
        # Currently (shown) representation
        if results.shown and results.current:
            shown = results.shown
            boldconcepts = [shown.field.concept]
            boldfields = [shown.field]
            if 'ColorField' in shown.opts:
                boldconcepts.append(shown.opts['ColorField'].concept)
                boldfields.append(shown.opts['ColorField'])

            bold = False

            # Present index data
            root = index.model().data(index)  # Root node : Concept OR field name
            root_concept = results.current.lookup(root)

            if root_concept:
                bold = (root_concept in boldconcepts)
            else:
                par = index.model().data(index.parent())
                concept = results.current.lookup(par)
                if concept:
                    field = concept.lookup(root)
                    bold = (field in boldfields)

            if bold:
                option.font.setWeight(Q.QFont.Bold)

        Q.QStyledItemDelegate.paint(self, painter, option, index)
