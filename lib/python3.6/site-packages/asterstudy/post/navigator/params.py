# -*- coding: utf-8 -*-

# Copyright 2019 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
RepresentationParams : Representation parameters dialog.

Initialized with a representation, they allow the user to interactively
modify and adjust the representation parameters.
"""

from functools import partial
from PyQt5 import Qt as Q

from ..config import (FIELDS_WITH_MAG, REPRESENTATIONS, DISPLAY_PROPS_DEFAULTS)
from ..utils import nb_points_cells, dbg_print
from .categorical_colorbar import CategoricalColorbarForm
from .group_filter import GroupsFilterForm

# pragma pylint: disable=too-many-instance-attributes,broad-except


class RepresentationParams(Q.QWidget):
    """
    RepresentationParams implementation.
    """

    # Basis representation for the parameter modification dialog
    rep = vlmain = apply_btn = nbp_lbl = nbc_lbl = toolbox = conts = None

    fields = {}
    pages = {}
    page_layouts = {}

    opts = {}
    opt_groups = {}
    opt_validators = {}
    opt_units = {}

    check_outputs = {}

    all_valid = Q.pyqtSignal(bool)
    """
    Signal: emitted when a change in options validity is detected

    Arguments:
        valid (bool): Are all the option values valid or not?
    """

    applied = Q.pyqtSignal()
    """
    Signal: emitted when apply was clicked
    """

    apply_pending = False

    def __init__(self, rep=None, parent=None):
        """
        Create/intialize the representation parameters widget on the
        sidebar of the post-processor page.

        Arguments:
            parent (Optional[QWidget]): Parent widget. Defaults to
                *None*.
            rep: representation for which the parameters are to be
                 modified
        """
        Q.QWidget.__init__(self, parent)

        self.setSizePolicy(Q.QSizePolicy.Expanding,
                           Q.QSizePolicy.MinimumExpanding)

        font = Q.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.setFont(font)

        self.vlmain = Q.QVBoxLayout(self)
        self.vlmain.setSpacing(0)

        self.set_representation(rep)

    def set_representation(self, rep):
        """
        Sets the representation associated to the present parameters
        """
        if rep != self.rep:
            self.rep = rep
            self.reset_params()
        else:
            self.update_params()

    def setup(self):
        """
        Sets up the QToolBox and its pages (without contents yet)
        """

        toolbox = Q.QToolBox(self)
        toolbox.setSizePolicy(Q.QSizePolicy.Expanding,
                              Q.QSizePolicy.Expanding)

        toolbox.setAutoFillBackground(False)
        toolbox.setBackgroundRole(Q.QPalette.NoRole)

        self.pages = {}
        pnames = sorted(self.opt_groups.keys())

        # We will actually parse those pages backwards as to start
        # by the Representation page and finish by the Animation
        for pname in pnames[::-1]:

            # Skip empty groups (ex. Colorbar for modal representation)
            if not self.opt_groups[pname]:
                continue

            page = Q.QWidget(toolbox)

            # Some styling...
            page.setSizePolicy(Q.QSizePolicy.Expanding,
                               Q.QSizePolicy.Expanding)

            page.setAutoFillBackground(False)
            page.setBackgroundRole(Q.QPalette.NoRole)

            # default font
            font = Q.QFont()
            font.setFamily("Arial")
            font.setPointSize(10)
            page.setFont(font)

            _vlayout = Q.QVBoxLayout(page)
            _vlayout.setSpacing(0)

            toolbox.addItem(page, pname)

            # Save the page for easier acces laterwards
            self.pages[pname] = page
            self.page_layouts[pname] = _vlayout

        self.vlmain.addWidget(toolbox)

        bottomhl = Q.QHBoxLayout()
        bottomhl.setContentsMargins(0, 20, 0, 0)
        bottomhl.layoutSpacing = 10

        font = Q.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)

        # Add the nb points and nb cells text labels
        self.nbp_lbl = Q.QLabel(self)
        bottomhl.addWidget(self.nbp_lbl)

        self.nbc_lbl = Q.QLabel(self)
        bottomhl.addWidget(self.nbc_lbl)

        for lbl in [self.nbp_lbl, self.nbc_lbl]:
            lbl.setFont(font)

        # Add a spacer
        button_spacer = Q.QSpacerItem(10, 10,
                                      Q.QSizePolicy.Expanding, Q.QSizePolicy.Minimum)
        bottomhl.addItem(button_spacer)

        # Add the apply button
        self.apply_btn = Q.QPushButton(self)
        self.apply_btn.setText('Apply')
        self.apply_btn.clicked.connect(self.apply)

        # self.all_valid.disconnect()
        self.all_valid.connect(self.apply_btn.setEnabled)

        bottomhl.addWidget(self.apply_btn)
        self.vlmain.addLayout(bottomhl)

        # Reset the toolbox index (perhaps keep the latest ?)
        toolbox.setCurrentIndex(0)

        # toolbox is saved as to allow renaming the first page later-on
        self.toolbox = toolbox

    # pragma pylint: disable=too-many-locals,comparison-with-callable
    def reset_params(self):
        """
        Completely reset the parameters (when representation
        changes for example)
        """
        self.conts = {}
        self.fields = {}
        self.pages = {}
        self.page_layouts = {}

        if self.vlmain:
            for i in reversed(list(range(self.vlmain.count()))):
                self.vlmain.takeAt(i)

        for widget in self.findChildren(Q.QWidget):
            widget.deleteLater()

        self.get_options()
        self.setup()

        # Add the fields in the toolbox pages
        for pname in self.pages:
            page, playout = self.pages[pname], self.page_layouts[pname]
            popts = self.opt_groups[pname]

            add_vspacer = True
            for opt in popts:
                unit = self.opt_units[opt]
                validator = self.opt_validators[opt]
                value = self.rep.opts[opt]

                if not validator.valfunc == custom_validator:
                    # Readily available field types
                    cont = Q.QWidget(page)
                    cont.setSizePolicy(Q.QSizePolicy.Expanding,
                                       Q.QSizePolicy.Fixed)
                    cont.setMinimumHeight(45)
                    cont.setMaximumHeight(45)
                    cont_lo = Q.QHBoxLayout(cont)

                    label = Q.QLabel(page)
                    label.setText('<b>{}</b>'.format(opt))
                    label.setMinimumWidth(150)
                    label.setMaximumWidth(150)
                    cont_lo.addWidget(label)

                    apply_func = self.apply
                    check_func = partial(self.check_single_option, opt, True)

                    # Field is represented either as a ComboBox or a LineEdit
                    # pragma pylint: disable=comparison-with-callable
                    if validator.valfunc == item_list_validator:
                        field = Q.QComboBox(page)
                        field.addItems([str(p) for p in validator.params])
                        field.setCurrentText(str(value))
                        if opt != 'ColorBarType':
                            field.currentIndexChanged.connect(apply_func)
                        else:
                            field.currentIndexChanged.connect(check_func)
                    elif validator.valfunc == boolean_validator:
                        field = Q.QCheckBox(page)
                        field.setChecked(value)
                        field.stateChanged.connect(check_func)
                    else:
                        field = Q.QLineEdit(page)
                        if validator.scale:
                            value = validator.scale * value

                        if validator.valfunc in [float_validator,
                                                 float_pos_validator, float_range_validator]:
                            field.setText('{:g}'.format(value))
                        else:
                            field.setText(str(value))
                        field.textChanged.connect(check_func)

                    field.setToolTip(validator.tip())
                    field.setSizePolicy(Q.QSizePolicy.Expanding,
                                        Q.QSizePolicy.Minimum)
                    cont_lo.addWidget(field)

                    unit_label = Q.QLabel(page)
                    unit_label.setText(unit)
                    unit_label.setMinimumWidth(40)
                    unit_label.setMaximumWidth(40)
                    cont_lo.addWidget(unit_label)

                else:
                    # Custom class handling a custom stateChange signal
                    field = validator.params[0](value=value, parent=self)
                    field.stateChanged.connect(
                        partial(self.check_single_option, opt))
                    cont = field
                    add_vspacer = False

                self.conts[opt] = cont
                self.fields[opt] = field
                playout.addWidget(cont)

            if add_vspacer:
                vspacer = Q.QSpacerItem(10, 10, Q.QSizePolicy.Minimum,
                                        Q.QSizePolicy.MinimumExpanding)
                playout.addItem(vspacer)

        self.check_all_options()
        self.apply_btn.setEnabled(False)

        self.toolbox.setItemText(0, self.rep.name)
        self.apply_conditions()

        nbp, nbc = nb_points_cells(self.rep.source)
        self.nbp_lbl.setText('Points:  {}'.format(nbp))
        self.nbc_lbl.setText('     Cells:  {}'.format(nbc))

    def apply_conditions(self):
        """
        Applies controller conditions based on the current options:

        For example, if ColorBarAuto is True, then the min and max
        are disabled for modifications.

        Note that only the initial state is relevant because once
        the auto checkbox is unchecked, the representation is
        redrawn which resets these conditions.

        """
        current_opts = self.values()
        if 'ColorBarType' in current_opts:
            cb_type = current_opts['ColorBarType']
            cb_auto = True
            if cb_type == 'Categorical':
                self.conts['ColorBarAuto'].setVisible(False)
                self.conts['ColorBarMin'].setVisible(False)
                self.conts['ColorBarMax'].setVisible(False)
                self.conts['ColorBarCategorical'].setVisible(True)
            else:
                self.conts['ColorBarAuto'].setVisible(True)
                self.conts['ColorBarMin'].setVisible(True)
                self.conts['ColorBarMax'].setVisible(True)
                self.conts['ColorBarCategorical'].setVisible(False)
                cb_auto = ('Automatic' in current_opts['ColorBarAuto'])
                if cb_auto:
                    self.fields['ColorBarMin'].setEnabled(False)
                    self.fields['ColorBarMax'].setEnabled(False)
                else:
                    self.fields['ColorBarMin'].setEnabled(True)
                    self.fields['ColorBarMax'].setEnabled(True)

        if 'ScaleFactorAuto' in current_opts:
            if current_opts['ScaleFactorAuto']:
                self.fields['ScaleFactor'].setEnabled(False)
            else:
                self.fields['ScaleFactor'].setEnabled(True)

        if 'Slice' in current_opts:
            if current_opts['Slice'] == 'None':
                self.conts['SlicePosition'].setVisible(False)
            else:
                self.conts['SlicePosition'].setVisible(True)

        if 'GroupsFilter' in current_opts:
            if current_opts['GroupsFilter']:
                self.conts['GroupsFilterOptions'].setEnabled(True)
            else:
                self.conts['GroupsFilterOptions'].setEnabled(False)

    def update_params(self):
        """
        Updates the values of the parameters from the representation
        options
        """
        if not self.rep:
            return

        prev_opts = self.opts
        self.get_options()
        if self.opts != prev_opts:
            self.reset_params()
        else:
            for opt in self.opts:
                value = self.rep.opts[opt]
                field = self.fields[opt]
                validator = self.opt_validators[opt]

                field.blockSignals(True)

                if validator.valfunc == item_list_validator:
                    field.setCurrentText(str(value))
                elif validator.valfunc == boolean_validator:
                    field.setChecked(value)
                elif validator.valfunc == custom_validator:
                    field.set_value(value)
                else:
                    if validator.scale:
                        value = validator.scale * value
                    field.setText(str(value))

                field.blockSignals(False)

            self.check_all_options()
            self.apply_btn.setEnabled(False)
            self.apply_conditions()

    def values(self):
        """
        Retrieves all parameter values
        """
        opts = {}
        for opt in self.fields:
            field = self.fields[opt]
            validator = self.opt_validators[opt]

            if validator.valfunc == item_list_validator:
                value = validator.params[field.currentIndex()]
            elif validator.valfunc == boolean_validator:
                value = field.isChecked()
            elif validator.valfunc == custom_validator:
                value = field.value()
            else:
                strvalue = field.text()
                out = validator.apply(strvalue)
                if out[0]:
                    value = out[1]
                else:
                    dbg_print(
                        'Validation error upon retrieving value for field %s' %
                        (opt))
                    value = 0
            opts[opt] = value
        return opts

    # pragma pylint: disable=too-many-branches
    def get_options(self):
        """
        Reads all available representation options and fills the gaps
        if not all information about how to exactly present the paramaters
        are specified.
        """
        if not self.rep:
            return
        opts = list(self.rep.opts.keys())
        opt_groups = self.rep.opt_groups if hasattr(
            self.rep, 'opt_groups') else {}
        opt_groups_rev = {}

        # Pre-defined groups
        for page in ['Representation', 'Display', 'Color bar',
                     'Mesh groups filter', 'Animation']:
            if not page in opt_groups:
                opt_groups[page] = []

        # Information read from the representation class
        for page in opt_groups:
            for opt in opt_groups[page]:
                opt_groups_rev[opt] = page

        # Fill options, missing from the class opt_groups, to one of the
        # pre-defined groups
        for opt in opts:
            if not opt in opt_groups_rev:
                if opt in list(DISPLAY_PROPS_DEFAULTS[0].keys()):
                    group = 'Display'
                elif opt in ['Title', 'Unit', 'ColorBarType', 'ColorBarAuto',
                             'ColorBarMin', 'ColorBarMax']:
                    group = 'Color bar'
                elif opt in ['FrameRate', 'NbPeriods']:
                    group = 'Animation'
                elif opt in ['GroupsFilter', 'GroupsFilterOptions']:
                    group = 'Mesh groups filter'
                else:
                    group = 'Representation'
                opt_groups_rev[opt] = group
                opt_groups[group].append(opt)

        # Remove options from opt_groups which are not effectively found in the
        # rep.opts
        for page in opt_groups:
            for opt in opt_groups[page]:
                if not opt in opts:
                    opt_groups[page].remove(opt)

        # Complete validators information
        opt_validators = self.rep.opt_validators if hasattr(
            self.rep, 'opt_validators') else {}
        for opt in opts:
            if not opt in opt_validators:
                if opt in ['ScaleFactor', 'MaxArrowSize',
                           'LineWidth', 'PointSize']:
                    opt_validators[opt] = Validator(float_pos_validator)
                elif opt in ['Opacity']:
                    opt_validators[opt] = Validator(
                        [float_range_validator, (0., 1.0)], scale=100.)
                elif opt in ['ScaleFactorAuto']:
                    opt_validators[opt] = Validator(boolean_validator)
                elif opt in ['ColorBarMin', 'ColorBarMax']:
                    opt_validators[opt] = Validator(float_validator)
                elif opt in ['ColorBarCategorical']:
                    opt_validators[opt] = Validator(
                        [custom_validator, [CategoricalColorbarForm]])
                elif opt in ['GroupsFilter']:
                    opt_validators[opt] = Validator(boolean_validator)
                elif opt in ['GroupsFilterOptions']:
                    opt_validators[opt] = Validator(
                        [custom_validator, [GroupsFilterForm]])
                elif opt in ['FrameRate', 'NbContours', 'ScalarBarNbVals', 'NbPeriods']:
                    opt_validators[opt] = Validator(int_pos_validator)
                elif opt in ['Component']:
                    field = self.rep.field
                    if 'ColorField' in opts:
                        if self.rep.opts['ColorField'] != field:
                            opt_validators[opt] = None
                            continue
                    comps = ['Magnitude'] if field.name in FIELDS_WITH_MAG else []
                    comps += field.info['components']
                    opt_validators[opt] = Validator(
                        [item_list_validator, comps])
                elif opt in ['Slice']:
                    opt_validators[opt] = Validator(
                        [item_list_validator,
                         ['None', 'Normal to x-axis', 'Normal to y-axis', 'Normal to z-axis']])
                elif opt in ['SlicePosition']:
                    opt_validators[opt] = Validator(
                        [float_range_validator, (0., 1.0)], scale=100.)
                elif opt in ['ColorBarType']:
                    cb_options = ['Continuous', 'Categorical']
                    opt_validators[opt] = Validator(
                        [item_list_validator, cb_options])
                elif opt in ['ColorBarAuto']:
                    cb_auto_options = [
                        'Automatic: current step',
                        'Automatic: all steps',
                        'Custom']
                    opt_validators[opt] = Validator(
                        [item_list_validator, cb_auto_options])
                elif opt in ['ColorField']:
                    opt_validators[opt] = None  # This allows hiding the entry
                elif opt in ['Representation']:
                    opt_validators[opt] = Validator(
                        [item_list_validator, REPRESENTATIONS])
                else:
                    opt_validators[opt] = Validator(text_validator)
            else:
                if not isinstance(opt_validators[opt], Validator):
                    val = opt_validators[opt]
                    if isinstance(val, dict):
                        opt_validators[opt] = Validator(**val)
                    else:
                        opt_validators[opt] = Validator(val)

        # Complete units information
        opt_units = self.rep.opt_units if hasattr(
            self.rep, 'opt_units') else {}
        for opt in opts:
            if not opt in opt_units:
                if opt in ['Opacity', 'SlicePosition']:
                    opt_units[opt] = r'%'
                elif opt in ['FrameRate']:
                    opt_units[opt] = 'fps'
                elif opt in ['ScaleFactor']:
                    opt_units[opt] = 'X'
                elif opt in ['LineWidth', 'PointSize']:
                    opt_units[opt] = 'px'
                else:
                    opt_units[opt] = ""

        # Options with an empty validator are not to be presented
        # in the editor toolbox
        to_remove = []
        for opt in opt_validators:
            if not opt_validators[opt]:
                to_remove.append(opt)

        for opt in to_remove:
            opt_validators.pop(opt, None)
            opt_units.pop(opt, None)
            opts.remove(opt)
            for group in opt_groups:
                if opt in opt_groups[group]:
                    opt_groups[group].remove(opt)

        self.opts = opts
        self.opt_groups = opt_groups
        self.opt_validators = opt_validators
        self.opt_units = opt_units

        # print "#"*50
        # print "opts", self.opts
        # print "opt_groups", self.opt_groups
        # print "opt_validators", self.opt_validators
        # print "opt_units", self.opt_units
        # print "#"*50

    def check_all_options(self):
        """
        Checks whether all provided options are valid
        """
        self.check_outputs = {}
        for opt in self.opts:
            self.check_single_option(opt, emit=False)

        if False not in list(self.check_outputs.values()):
            self.all_valid.emit(True)
            return True

        self.all_valid.emit(False)
        return False

    # pragma pylint: disable=comparison-with-callable
    def check_single_option(self, opt, emit=True):
        """
        Checks if the value for a given option is valid
        """
        field = self.fields[opt]
        validator = self.opt_validators[opt]
        if validator.valfunc in [item_list_validator, boolean_validator]:
            self.check_outputs[opt] = True
        elif validator.valfunc == custom_validator:
            self.check_outputs[opt] = field.check()
        else:
            strvalue = field.text()
            out = validator.apply(strvalue)
            self.check_outputs[opt] = out[0]
            if out[0]:
                field.setStyleSheet(
                    'border: 1px solid green; font-size: 12px;')
            else:
                field.setStyleSheet('border: 1px solid red; font-size: 12px;')

        if emit:
            if self.check_outputs[opt] is False:
                self.all_valid.emit(False)
            else:
                if False not in list(self.check_outputs.values()):
                    self.all_valid.emit(True)
                    if self.apply_pending:
                        self.applied.emit()
                        self.apply_pending = False
        self.apply_conditions()

    def apply(self):
        """
        Do a final check and then emit the applied signal to
        update the view
        """
        state = self.check_all_options()
        if state:
            self.applied.emit()
            self.apply_pending = False
        else:
            self.apply_pending = True


def text_validator(value):
    """Validates text strings"""
    try:
        val = str(value)
    except BaseException:
        return [False]
    return [True, val]


def item_list_validator(value, vlist):
    """Validates an item in a fixed list"""
    if value in vlist:
        return [True, vlist.index(value)]
    return [False]


def float_validator(value):
    """Validates a float"""
    try:
        val = float(value)
    except BaseException:
        return [False]
    return [True, val]


def float_pos_validator(value):
    """Validates a positive or zero float"""
    out = float_validator(value)
    if not out[0]:
        return out
    val = out[1]
    if val < -1e-15:
        return [False]
    return [True, val]


def float_range_validator(value, range):
    """Validates a float in a given range (bounds included)"""
    out = float_validator(value)
    if not out[0]:
        return out
    val = out[1]
    if val < range[0] - 1e-15 or val > range[1] + 1e-15:
        return [False]
    return [True, val]


def int_validator(value):
    """Validates an integer value"""
    out = float_validator(value)
    if not out[0]:
        return out
    val1 = out[1]
    val2 = int(val1)
    if val1 == val2:
        return [True, val2]
    return [False]


def int_pos_validator(value):
    """Validates a positive integer value"""
    out = int_validator(value)
    if not out[0]:
        return out
    val = out[1]
    if val > 0:
        return [True, val]
    return [False]


def boolean_validator(value):
    """Validates a boolean convertible value"""
    try:
        vam = bool(value)
    except BaseException:
        return [False]
    return [True, vam]


def custom_validator(value, def_class):
    """Custom validator based on a specific class"""
    return def_class.check(value)


class Validator():
    """
    Class encapsulating a validating function and extra params.

    Offers:
    - applying the validation function (accounting for scale)
    - giving a user friendly validation tip
    """
    valfunc = params = scale = None

    def __init__(self, valdef=text_validator, scale=None):
        if isinstance(valdef, (list, tuple)):
            self.valfunc = valdef[0]
            if len(valdef) > 1:
                self.params = valdef[1]
        else:
            self.valfunc = valdef

        self.scale = scale

        # If the validator definition is not valid, revert to textValidation
        if not hasattr(self.valfunc, '__call__'):
            self.valfunc = text_validator
            self.params = None
            self.scale = None

    def apply(self, value):
        """
        Applies the validation function
        """
        # if not len(str(value)):
        #     return [False]

        if self.valfunc not in (item_list_validator, text_validator):
            if self.scale:
                out = float_validator(value)
                if not out[0]:
                    return [False]
                value = out[1] / self.scale

        if self.params:
            return self.valfunc(value, self.params)
        return self.valfunc(value)

    # pragma pylint: disable=comparison-with-callable
    def tip(self):
        """
        Return a simple message with a tip regarding the validation criterion
        """
        msg = ''
        if self.valfunc == item_list_validator:
            msg = 'choose among the available options'
        elif self.valfunc == text_validator:
            msg = 'enter a valid string'
        elif self.valfunc == float_validator:
            msg = 'enter any valid (real) number'
        elif self.valfunc == float_pos_validator:
            msg = 'enter a positive (real) number'
        elif self.valfunc == int_validator:
            msg = 'enter a valid integer'
        elif self.valfunc == int_pos_validator:
            msg = 'enter a positive integer'
        elif self.valfunc == float_range_validator:
            scale = self.scale if self.scale else 1.0
            msg = 'enter a number between {:g} and {:g}'.format(
                self.params[0] * scale, self.params[1] * scale)

        msg = 'Please {}'.format(msg) if msg else ''
        return msg


# def __main__():
#     import sys
#     class FIELD():
#         name = 'DEPL'
#         info = {'components' : ['DX', 'DY', 'DZ']}
#     class REP():
#         opts = {'NbContours': 12, 'Option 2': 25, 'Opacity': 0.2, 'Component': 'DX'}
#         opt_groups = {'Representation': ['NbContours']}
#         opt_units = {'Option 1': 'xxxxx', 'Option 2': None}
#         opt_validators = {'Option 1': {'valdef': float_validator, 'scale': 10.},
#                           'Option 2': (item_list_validator, [25, 35, 45])}
#         field = FIELD()
#         name = 'Colored Representation'

#     app = Q.QApplication(sys.argv)
#     w = RepresentationParams(REP())
#     r = REP()
#     r.opt_units['Option 2']='yyy'
#     w.set_representation(r)
#     w.resize(450, 450)
#     w.setWindowTitle('Testing params representation')
#     w.show()

#     sys.exit(app.exec_())


# if __name__ == "__main__":
#     __main__()
