# -*- coding: utf-8 -*-

# Copyright 2019 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""
CategoricalColorbar table definition which allows the user to
interactively define the boundaries of a constant-per-range
colorbar in the asterstudy post-processor
"""

from PyQt5 import Qt as Q

from ...gui import get_icon
from ..plotter.table import (CustomTable, GenericTableModel,
                             TableParams, ok_validator, float_validator)


def random_color():
    """
    Generate a random color in hex format
    """
    import random
    random_number = random.randint(0, 16777215)
    hex_number = str(hex(random_number))
    hex_number = '#' + hex_number[2:]
    return hex_number


def hex_to_rgb(value):
    """
    Convert a hex color to rgb
    """
    value = value.lstrip('#')
    vlen = len(value)
    return tuple(int(value[i:i + vlen // 3], 16) /
                 255. for i in range(0, vlen, vlen // 3))


def rgb_to_hex(red, green, blue):
    """
    Convert an rgb color to gex
    """
    conv = lambda x: int(max(0., min(x * 255., 255)))
    return "#{0:02x}{1:02x}{2:02x}".format(
        conv(red), conv(green), conv(blue))


class ColorbarTable(CustomTable):
    """
    ColorbarTable implementation for customizing categorical colorbars
    """

    def __init__(self, *args):
        """
        Initialization of the colorbar table
        """
        CustomTable.__init__(self, *args)
        self.setVerticalScrollBarPolicy(Q.Qt.ScrollBarAlwaysOff)

    # pragma pylint: disable=invalid-name
    def contextMenuEvent(self, _, extraActions=None):
        """
        Customized context menu event
        """
        import_action = Q.QAction('Import from file (json)', self)
        import_action.triggered.connect(self.import_json)

        export_action = Q.QAction('Export to file (json)', self)
        export_action.triggered.connect(self.export_json)

        extra = [import_action, export_action]

        CustomTable.contextMenuEvent(self, _, extraActions=extra)

    @Q.pyqtSlot()
    def import_json(self):
        """
        Import a json file into the table
        """
        import json
        ext, dotext = 'json', '.json'
        fpath, _ = Q.QFileDialog.getOpenFileName(
            caption='Import categorical colorbar from %s file' % (ext),
            filter='*%s' % (dotext))

        if not fpath:
            return

        color_array = json.load(open(fpath))
        self.model().read_array(color_array[0])

        self.model().itemsChanged.emit()

    @Q.pyqtSlot()
    def export_json(self):
        """
        Export the table contents to a json file
        """
        import os
        import json
        osp = os.path

        out = self.model().color_array()
        ext, dotext = 'json', '.json'

        docont = True
        fpath = ""
        while docont:
            fpath, _ = Q.QFileDialog.getSaveFileName(
                caption='Export categorical colorbar to %s file' % (ext),
                directory=fpath, filter='*%s' % (dotext))

            docont = False
            if fpath:
                if dotext != osp.splitext(fpath)[-1]:
                    fpath = fpath + dotext
                    docont = osp.isfile(fpath)

        if fpath:
            with open(fpath, 'w') as json_file:
                json.dump(out, json_file, indent=2)

    @Q.pyqtSlot()
    # pragma pylint: disable=invalid-name
    def doubleClickTable(self):
        """
        Slot called when a table cell is double clicked
        """
        if not self.selectedIndexes():
            return

        index = self.selectedIndexes()[0]
        row, col = index.row(), index.column()
        col_header = self.model().params.headers[col]

        if col_header == '_Color' and row < self.model().rowCount() - 1:
            value = self.model().basis[row][col]
            color = Q.QColorDialog.getColor(Q.QColor(value))
            if Q.QColor.isValid(color):
                self.model().setData(index, color.name())

        elif col_header == '__Insert':
            self.insertRow(add=1)

        elif col_header == '__Remove':
            if self.model().rowCount() > 1:
                self.removeRows()


class ColorbarModel(GenericTableModel):
    """ColorbarModel implementation"""

    def __init__(self, params, basis, parent=None):
        """Create Generic Table Model."""
        GenericTableModel.__init__(self, params, basis, parent)

    def data(self, index, role):

        row = index.row()
        column = index.column()
        col_header = self.params.headers[column]

        if role == Q.Qt.DecorationRole:
            out = None
            if col_header == '_Color' and row < self.rowCount() - 1:
                out = GenericTableModel.data(self, index, role)
            elif col_header == '__Insert':
                out = get_icon("CB Insert")
            elif col_header == '__Remove':
                out = get_icon("CB Remove")
            elif col_header == 'Threshold' and row > 0:
                out = get_icon("CB Sep")
            return out

        if role == Q.Qt.DisplayRole:
            if col_header != 'Threshold' and row == 0:
                return ''

        return GenericTableModel.data(self, index, role)

    # pragma pylint: disable=invalid-name
    def insertRows(self, position, rows, parent=Q.QModelIndex()):
        """Inserts count rows into the model before the given row."""
        self.beginInsertRows(parent, position, position + rows - 1)

        refpos = position if position < self.rowCount() else self.rowCount() - 1

        for _ in range(rows):
            entry = self.basis[refpos] + []
            entry[0] = random_color()

            val2 = self.basis[refpos][1]
            val1 = val2 if refpos == 0 else self.basis[refpos - 1][1]
            if position == self.rowCount():
                entry[1] = val2 + (val2 - val1)
            elif position == 0:
                entry[1] = 0.5 * val1
            else:
                entry[1] = 0.5 * (val2 + val1)

            entry[2] = 'Range {:d}'.format(position)
            self.basis.insert(position, entry)

        self.endInsertRows()

        for i in range(len(self.basis)):
            name = self.basis[i][2]
            if name[:6] == 'Range ':
                self.basis[i][2] = 'Range {:d}'.format(i)

        # Workaround for scrolling down upon insertion of rows at the
        # end of the table
        if position == 0:
            self.view.scrollToBottom()
        else:
            self.view.scrollTo(self.index(position, 0),
                               Q.QAbstractItemView.EnsureVisible)

        self.itemsChanged.emit()
        return True

    def color_array(self):
        """
        Creates a python dictionnary with information on the color array
        """
        rgb_points = []
        annotations = []

        centered = True
        name = 'Colorbar'

        vals = list(self.values())
        gap = (vals[-1][1] - vals[0][1]) / (len(vals) * 1.e10)
        for i in range(len(vals) - 1):
            # Entry is a list containing color, value, annotation
            # ---------------------------------------------------------
            # Note that the "fake" columns __Insert and __Remove are
            # not returned by the model.values() method!
            hex_color, val1, _ = vals[i]
            _, val2, annot = vals[i + 1]

            rgb_color = hex_to_rgb(hex_color)

            # Each color extends to the next value in the table
            # minus a customized visually relevant gap (~precision)
            this_gap = gap + 0. if i != len(vals) - 2 else 0.
            rgb_points.append(val1)
            rgb_points.extend(rgb_color)
            rgb_points.append(val2 - this_gap)
            rgb_points.extend(rgb_color)

            # Annotations
            position = 0.5 * (val1 + val2) if centered else val2 - this_gap
            annotations.extend((str(position), str(annot)))

        out = [{
            "ColorSpace": "RGB",
            "Name": name,
            "RGBPoints": rgb_points,
            "Annotations": annotations}]
        return out

    def read_array(self, array):
        """
        Converts a colorbar array into a basis then resets the
        model based on this information.

        Does the opposite function of that of method color_array
        """
        nbrows = int(len(array["Annotations"]) / 2) + 1
        basis = [[]] * nbrows
        rgb = array["RGBPoints"]
        annots = [''] + [array["Annotations"][2 * i + 1]
                         for i in range(nbrows - 1)]
        for i in range(nbrows):
            if i < nbrows - 1:
                color_inds = (8 * i + 1, 8 * i + 2, 8 * i + 3)
                rgb_color = tuple([rgb[cind] for cind in color_inds])
                hexcolor = rgb_to_hex(*rgb_color)

                threshold = rgb[8 * i]
            else:
                hexcolor = random_color()
                threshold = rgb[8 * (i - 1) + 4]
            annot = annots[i]

            basis[i] = [hexcolor, threshold, annot, '', '']

        self.clear()
        self.basis = basis
        self.layoutChanged.emit()


class CategoricalColorbarForm(Q.QWidget):
    """
    User entry form (widget) encapsulating the categorical entry table
    """

    stateChanged = Q.pyqtSignal()

    def __init__(self, value=None, parent=None):
        super(CategoricalColorbarForm, self).__init__(parent)

        self.setSizePolicy(Q.QSizePolicy.Expanding,
                           Q.QSizePolicy.Expanding)
        layout = Q.QVBoxLayout(self)

        self.table = ColorbarTable(self)

        params = TableParams()
        params.headers = (
            '_Color',
            'Threshold',
            'Annotation Text',
            '__Insert',
            '__Remove')

        okv, flv = ok_validator, float_validator
        params.validators = [okv, flv, okv, okv, okv]
        params.column_widths = [25, 125, 1.0, 25, 25]

        basis = [['#0000ff', 0., '', '', ''],
                 ['#ff0000', 1., 'Range 1', '', ''], ]

        model = ColorbarModel(params, basis)
        self.table.setModel(model)

        model.itemsChanged.connect(self.stateChanged.emit)

        layout.addWidget(self.table)
        self.set_value(value)

    def set_value(self, value):
        """
        Mandatory CustomValidator function, read or updates the
        colorbar table values
        """
        if value:
            model = self.table.model()
            model.read_array(value)

    def value(self):
        """
        Mandatory CustomValidator function that returns the values
        in the table (then passed to rep.opts)
        """
        return self.table.model().color_array()[0]

    def check(self):
        """
        Mandatory CustomValidator function that returns whether the
        user input is valid.
        """
        if self.table.model().rowCount() > 1:
            return True
        return False

    # pragma pylint: disable=invalid-name
    def resizeEvent(self, event):
        """
        Qt generic callback to handle resize events
        """
        super(CategoricalColorbarForm, self).resizeEvent(event)
        self.table.setColumnDimensions()


# def __main__():
#     import sys

#     app = Q.QApplication(sys.argv)

#     # w = Q.QMainWindow()

#     v = CustomTable()
#     v.resize(450, 450)

#     params = TableParams()
#     params.headers = ('_Color', 'Threshold', 'Annotation Text', '__Insert', '__Remove')
#     params.validators = [ok_validator, float_validator, ok_validator]
#     params.column_widths = [25, 150, 200, 25, 25]
#     basis = [['#0000ff', 0., 'Lower', '', ''],
#              ['#ff0000', 1., 'Upper', '', ''],]

#     m = GenericTableModel(params, basis)
#     v.setModel(m)


#     v.setWindowTitle('Testing colorbar parameter modification widget')
#     v.show()

#     sys.exit(app.exec_())


# if __name__ == "__main__":
#     __main__()
