# -*- coding: utf-8 -*-

# Copyright 2016-2018 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""Generator of the calculation assistant wizard."""


import json
from abc import abstractmethod
from collections import OrderedDict

from ..common import check_version, format_code

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name

# pragma pylint: disable=pointless-statement,expression-not-assigned


class Writer:
    """Writer."""

    INDENT = ' ' * 4
    EOL = '\n'

    def __init__(self):
        """Create writer."""
        self.level = 0
        self.data = []

    def indent(self):
        """Increase indentation level."""
        self.level += 1

    def unindent(self):
        """Decrease indentation level."""
        self.level = max(0, self.level - 1)

    def reset(self):
        """Reset indentation level."""
        self.level = 0

    def __lshift__(self, line):
        """
        Support native Python '<<' operator protocol: write line to the output.

        Arguments:
            line (str): Line to write.
        """
        data = ''
        if line.strip():
            data += self.INDENT * self.level
        data += line.strip()
        data += self.EOL
        self._write(data)
        return self

    def get(self):
        """
        Get output.

        Returns:
            str: Current output.
        """
        return ''.join(self.data)

    def _write(self, data):
        """Append data to output."""
        self.data.append(data)


class Widget:
    """Generator for generic widget."""

    INDENT = '>> '

    def __init__(self, data, parent=None):
        """
        Create generator.

        Arguments:
            data (dict): Widget data.
            parent (Optional[generator.Widget]): Parent generator. Defaults to *None*.
        """
        self.parent = parent
        self.children = []
        self.title = data.pop('title', None)
        self.tooltip = data.pop('description', None)

    @property
    def name(self): # pragma pylint: disable=no-self-use
        """str: Attribute that holds widget's dump name."""
        return 'widget'

    @property
    def parent_name(self):
        """str: Attribute that holds parent's dump name."""
        return self.parent.name if self.parent is not None else 'None'

    @property
    def wizard_name(self):
        """str: Attribute that holds wizard's dump name."""
        parent = self
        while parent.parent is not None:
            parent = parent.parent
        return parent.name

    @property
    def wizard_class(self):
        """str: Attribute that holds wizard's class name."""
        parent = self
        while parent.parent is not None:
            parent = parent.parent
        return parent.class_name # pragma pylint: disable=no-member

    @property
    def depth(self):
        """int: Attribute that holds widget's depth (wizard has depth 0)."""
        items = [self.parent]
        while items[-1] is not None:
            items.append(items[-1].parent)
        return len(items) - 1

    @property
    def cls_depth(self):
        """int: Attribute that holds number of parents of this class."""
        items = [self]
        while items[-1] is not None:
            items.append(items[-1].parent)
        same_items = [i for i in items if i.__class__.__name__ == self.__class__.__name__]
        return len(same_items) - 1

    def add_child(self, child):
        """
        Add child item.

        Arguments:
            child (object): Child generator.
        """
        self.children.append(child)
        self.register(child)

    def register(self, parameter):
        """
        Register given parameter.

        Arguments:
            parameter (str): Parameter uid.

        Raises:
            ImportError: If parameter is duplicated.
        """
        if self.parent is not None:
            self.parent.register(parameter)

    @abstractmethod
    def dump_self(self, writer):
        """
        Dump this item.

        Abstract method; has to be implemented in successors.

        Arguments:
            writer (object): Writer.
        """
        raise NotImplementedError("Method should be implemented in successors")

    def dump_basic(self, writer):
        """
        Dump basic properties.

        Arguments:
            writer (object): Writer.
        """
        cls = self.wizard_class
        name = self.name
        object_name = self.title or name
        if self.tooltip:
            writer << 'tooltip = {func}("{cls}", "{tip}")'.format(func='translate', cls=cls,
                                                                  tip=self.tooltip)
            writer << '{name}.setToolTip(tooltip)'.format(name=name)
        if name:
            writer << '{name}.setObjectName("{oname}")'\
                .format(name=name, oname=object_name)

    def dump(self, writer):
        """
        Dump item with sub-objects.

        Arguments:
            writer (object): Writer.
        """
        self.dump_self(writer)
        for child in self.children:
            child.dump(writer)

    def check_attribute_bad(self, name, value):
        """
        Raise exception if given attribute is not specified.

        Attributes:
            name (str): Attribute name.
            value (any): Attribute value.

        Raises:
            ImportError: If attribute is empty or null.
        """
        if not value:
            cls = self.__class__.__name__
            raise ImportError('mandatory attribute "{}" is not specified for {}'.format(name, cls))


class Wizard(Widget):
    """Wizard generator."""

    def __init__(self, data):
        """
        Create wizard generator.

        Arguments:
            data (dict): Wizard data.
        """
        super().__init__(data)
        self.check_attribute_bad('title', self.title)
        self.uids = []
        self.version = data.pop('format', None)
        self.class_name = data.pop('class', 'Wizard')

        pages = data.pop('pages', [])
        self.check_attribute_bad('pages', pages)
        for page in pages:
            self.add_page(page)

    def add_page(self, data):
        """
        Add page.

        Arguments:
            data (dict): Page data.
        """
        self.add_child(Page(data, self))

    @property
    def name(self):
        """Reimplemented from generator.Widget."""
        return 'self'

    def dump_self(self, writer):
        """Reimplemented from generator.Widget."""
        writer.reset()
        writer << '# -*- coding: utf-8 -*-'
        writer << ''
        writer << '"""{}"""'.format(self.tooltip or "No description")
        writer << ''
        writer << 'from asterstudy.assistant import widgets as AW'
        writer << 'from asterstudy.common import translate'

        cls = self.wizard_class
        name = self.name
        writer << ''
        writer << 'def create_wizard(parent):'
        writer.indent()
        writer << '"""Factory function."""'
        writer << 'return {}(parent)'.format(cls)
        writer.reset()
        writer << ''
        writer << ''
        writer << 'class {}(AW.Wizard):'.format(cls)
        writer.indent()
        writer << '"""Wizard dialog."""'
        writer << ''
        writer << 'def __init__(self, parent=None):'
        writer.indent()
        writer << '"""Create wizard."""'
        writer << 'super().__init__(parent)'
        writer << ''
        # !! it is better to set different title for differeny assistants
        writer << 'title = {func}("{cls}", "{title}")'.format(func='translate', cls=cls,
                                                              title=self.title)
        writer << '{name}.setWindowTitle(title)'.format(name=name)
        writer << '{name}.setModal(True)'.format(name=name)
        self.dump_basic(writer)

    def register(self, parameter):
        """
        Register and check given parameter.

        Arguments:
            parameter (str): Parameter uid.
        """
        if hasattr(parameter, 'uid'):
            uid = parameter.uid
            if uid in self.uids:
                raise ImportError('duplicated parameter: {}'.format(uid))
            self.uids.append(uid)


class Group(Widget):
    """Group generator."""

    ALLOW_EMPTY = False

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Group data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)

        parameters = data.pop('parameters', [])
        if not self.ALLOW_EMPTY:
            self.check_attribute_bad('parameters', parameters)

        for parameter in parameters:
            if 'parameters' in parameter:
                self.add_group(parameter)
            else:
                self.add_parameter(parameter)

    def add_group(self, data):
        """
        Add sub-group.

        Arguments:
            data (dict): Sub-group data.
        """
        self.add_child(Group(data, self))

    def add_parameter(self, data):
        """
        Add parameter.

        Arguments:
            data (dict): Parameter data.
        """
        self.add_child(Control.factory(data, self))

    @property
    def name(self):
        """Reimplemented from generator.Widget."""
        return 'sub' * self.cls_depth + 'group'

    def dump_self(self, writer):
        """Reimplemented from generator.Widget."""
        cls = self.wizard_class
        name = self.name
        pname = self.parent_name
        title = self.title or 'untitled'
        indent = (self.depth - 1) * self.INDENT
        writer << ''
        writer << '# {indent}Group: {title}'.format(indent=indent, title=title)

        params = []
        if self.title:
            writer << 'title = {func}("{cls}", "{title}")'.format(func='translate', cls=cls,
                                                                  title=self.title)
            params.append('title')
        writer << '{name} = AW.Group({attrs})'.format(name=name,
                                                      attrs=', '.join(params))
        self.dump_basic(writer)
        writer << '{parent}.addWidget({name})'.format(parent=pname, name=name)


class Page(Group):
    """Wizard page generator."""

    @property
    def name(self):
        """Reimplemented from generator.Widget."""
        return 'page'

    def dump_self(self, writer):
        """Reimplemented from generator.Widget."""
        cls = self.wizard_class
        name = self.name
        pname = self.parent_name
        title = self.parent.title
        sub_title = self.title
        writer << ''
        writer << '# Page: {}'.format(self.title)
        # !! it is better to set separate own title for each page
        writer << 'title = {func}("{cls}", "{title}")'.format(func='translate', cls=cls,
                                                              title=title)
        # !! it is better to set page's description as a sub-title
        writer << 'sub_title = {func}("{cls}", "{title}")'.format(func='translate', cls=cls,
                                                                  title=sub_title)
        writer << '{name} = AW.WizardPage(title, sub_title=sub_title)'.\
                       format(name=name)
        self.dump_basic(writer)
        writer << '{parent}.addPage({name})'.format(parent=pname, name=name)


class Control(Widget):
    """Generic control widget generator."""

    TYPE = 'Control'
    EXCLUDE = []

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Control data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)
        self.uid = data.pop('name', None)
        self.check_attribute_bad('name', self.uid)
        for exclude in self.EXCLUDE:
            data.pop(exclude, None)
        self.attributes = data

    def dump_self(self, writer):
        """Reimplemented from generator.Widget."""
        cls = self.wizard_class
        name = self.name
        pname = self.parent_name
        wname = self.wizard_name
        typ = self.TYPE

        writer << ''

        params = []
        if self.title:
            writer << 'title = {func}("{cls}", "{title}")'.format(func='translate', cls=cls,
                                                                  title=self.title)
            params.append('title')
        attrs = ', '.join(['{}={}'.format(i, value2str(j)) \
                               for i, j in self.attributes.items()])
        if attrs:
            params.append(attrs)

        writer << '{name} = AW.{typ}({attrs})'.format(name=name, typ=typ,
                                                      attrs=', '.join(params))

        self.dump_special(writer)
        self.dump_basic(writer)
        writer << '{parent}.addWidget({name})'.format(parent=pname, name=name)
        writer << '{wizard}.register("{uid}", {name})'.format(wizard=wname,
                                                              uid=self.uid,
                                                              name=name)

    def dump_special(self, writer):
        """
        Dump special attributes.

        Default implementation does nothing; this method can be reimplemented
        in successors.

        Arguments:
            writer (object): Writer.
        """

    @staticmethod
    def factory(data, parent):
        """
        Create widget generator of appropriate type.

        Arguments:
            data (dict): Control data.
            parent (generator.Widget): Parent generator.

        Returns:
            generator.Control: Widget generator.
        """
        class_ = None
        typ = data.get('typ', 'string')
        if typ in ('text',):
            class_ = Text
        elif typ in ('choice',):
            class_ = Choices
        elif typ in ('bool',):
            class_ = Switch
        elif typ in ('file',):
            class_ = FileSelector
        elif typ in ('mesh',):
            class_ = MeshSelector
        elif typ in ('group_ma',):
            class_ = GroupElSelector
        elif typ in ('group_no',):
            class_ = GroupNoSelector
        elif typ in ('int', 'float', 'string'):
            if data.get('into'):
                class_ = Selector
            else:
                class_ = Editor
        elif typ in ('table',):
            class_ = Table
        elif typ in ('list',):
            class_ = List
        elif typ in ('matrix',):
            class_ = Matrix
        elif typ in ('hidden',):
            class_ = HiddenParam
        else:
            raise ImportError('unsupported control type: {}'.format(typ))
        return class_(data, parent)


class HiddenParam(Control):
    """Hidden parameter."""

    TYPE = 'Hidden'

    def dump(self, _):
        """
        Dump item with sub-objects: does nothing.
        """


class Text(Control):
    """Readonly text area control generator."""

    TYPE = 'Text'

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Table data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)

        text = self.attributes.get("text")
        self.check_attribute_bad("text", text)

        if isinstance(text, (list, tuple)):
            text = "\\n".join(text)
            self.attributes['text'] = text


class Editor(Control):
    """Line edit control generator."""

    TYPE = 'LineEdit'


class Selector(Control):
    """Selector control generator."""

    TYPE = 'ComboBox'


class Switch(Control):
    """Switch control generator."""

    TYPE = 'CheckBox'
    EXCLUDE = ['typ']


class FileSelector(Control):
    """File selector control generator."""

    TYPE = 'FileSelector'
    EXCLUDE = ['typ']


class MeshSelector(Control):
    """Mesh selector control generator."""

    TYPE = 'MeshSelector'
    EXCLUDE = ['typ', 'mode', 'filters']


class AbstractGroupSelector(Control):
    """Abstract group selector"""

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Table data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)
        self.check_attribute_bad("mesh", self.attributes.get("mesh"))

class GroupElSelector(AbstractGroupSelector):
    """Selector of single group of elements."""

    TYPE = 'GroupElSelector'
    EXCLUDE = ['typ']

class GroupNoSelector(AbstractGroupSelector):
    """Selector of single group of nodes."""

    TYPE = 'GroupNoSelector'
    EXCLUDE = ['typ']


class Table(Control):
    """Table control generator."""

    TYPE = 'TableWidget'

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Table data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)
        self.columns = data.pop('columns', [])
        self.check_attribute_bad('columns', self.columns)
        data.pop('typ', None) # not needed in dump

    def dump_special(self, writer):
        """Reimplemented from generator.Control."""
        cls = self.wizard_class
        name = self.name
        for column in self.columns:
            cname = column.pop('name', None)
            if not cname:
                raise ImportError('unnamed table column')
            title = column.pop('title', cname)
            params = []
            writer << 'column_title = {func}("{cls}", "{title}")'.format(func='translate',
                                                                         cls=cls, title=title)
            params.append('"{}"'.format(cname))
            params.append('column_title')
            attrs = ', '.join(['{}={}'.format(i, value2str(j)) \
                                   for i, j in column.items()])
            if attrs:
                params.append(attrs)

            writer << '{name}.addColumn({attrs})'.\
                format(name=name, attrs=', '.join(params))

class List(Control):
    """List control generator."""

    TYPE = 'ListWidget'

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): List data.
            parent (Widget): Parent generator.
        """
        super(List, self).__init__(data, parent)
        self.parameter = data.pop('parameter', '0')
        data.pop('typ', None) # not needed in dump

class Matrix(Control):
    """List control generator."""

    TYPE = 'MatrixWidget'

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Table data.
            parent (Widget): Parent generator.
        """
        super(Matrix, self).__init__(data, parent)
        self.columns = data.pop('columns', [])
        self.check_attribute_bad('columns', self.columns)
        data.pop('typ', None) # not needed in dump

    def dump_special(self, writer):
        """Reimplemented from *Control*."""
        cls = self.wizard_class
        name = self.name
        for column in self.columns:
            cname = column.pop('name', None)
            if not cname:
                raise ImportError('unnamed table column')
            title = column.pop('title', cname)
            params = []
            writer << 'column_title = {func}("{cls}", "{title}")'.format(func='translate',
                                                                         cls=cls, title=title)
            params.append('"{}"'.format(cname))
            params.append('column_title')
            attrs = ', '.join(['{}={}'.format(i, value2str(j)) \
                                   for i, j in column.items()])
            if attrs:
                params.append(attrs)

            writer << '{name}.addColumn({attrs})'.\
                format(name=name, attrs=', '.join(params))

class Choices(Control):
    """Choices selector generator."""

    TYPE = 'Choices'

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Choices data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)

        self.choices = data.pop('choices', [])
        self.check_attribute_bad('choices', self.choices)
        data.pop('typ', None) # not needed in dump

        for choice in self.choices:
            self.check_attribute_bad('choice', choice)
            self.add_child(Choice(choice, self))

    @property
    def name(self):
        """Reimplemented from generator.Control."""
        return 'sub' * (self.depth - 2) + 'choices'


class Choice(Group):
    """Choice generator."""

    ALLOW_EMPTY = True

    def __init__(self, data, parent):
        """
        Create generator.

        Arguments:
            data (dict): Choice data.
            parent (generator.Widget): Parent generator.
        """
        super().__init__(data, parent)
        self.uid = data.pop('name', None)
        self.check_attribute_bad('name', self.uid)

    @property
    def name(self):
        """Reimplemented from generator.Group."""
        return 'sub' * self.cls_depth + 'choice'

    def dump_self(self, writer):
        """Reimplemented from generator.Group."""
        cls = self.wizard_class
        name = self.name
        pname = self.parent_name
        title = self.title

        indent = (self.depth - 1) * self.INDENT
        writer << ''
        writer << '# {indent}Choice: {title}'.format(indent=indent, title=title)

        params = []
        params.append('"{}"'.format(self.uid))
        if self.title:
            writer << 'choice_title = {func}("{cls}", "{title}")'.format(func='translate',
                                                                         cls=cls, title=title)
            params.append('choice_title')

        if self.children:
            writer << '{name} = {pname}.addChoice({attrs})'.format(name=name,
                                                                   pname=pname,
                                                                   attrs=', '.join(params))
        else:
            writer << '{pname}.addChoice({attrs})'.format(pname=pname,
                                                          attrs=', '.join(params))


def generate_wizard(data):
    """
    Generate wizard from given data.

    Arguments:
        data (dict): Wizard's data.

    Returns:
        str: Generated wizard's code.

    Raises:
        ImportError: If data is invalid or of unsupported version.
    """
    version = data.get("format")
    if not version:
        raise ImportError("Format is too old and not supported")
    if check_version(version, "2.0", "lt"):
        raise ImportError("Format {} is not supported".format(version))

    wizard = Wizard(data)
    writer = Writer()
    wizard.dump(writer)
    return format_code(writer.get(), style='google', COLUMN_LIMIT=200)


def generate_wizard_from_string(declaration):
    """
    Generate wizard from given declaration.

    Declaration should be provided in valid JSON format.

    Arguments:
        declaration (str): Wizard's declaration.

    Returns:
        str: Generated wizard's code.

    Raises:
        ValueError: If declaration is of invalid format.
        ImportError: If declaration is of unsupported version.
    """
    data = json.loads(declaration, object_pairs_hook=OrderedDict)
    return generate_wizard(data)


def generate_wizard_from_file(file_name):
    """
    Generate wizard from given declaration file.

    Arguments:
        file_name (str): Wizard's declaration file name.

    Returns:
        str: Generated wizard's code.

    Raises:
        IOError: If file does not exists or inaccessible.
        ValueError: If file contains declaration of invalid format.
        ImportError: If file contains declaration of unsupported version.
    """
    with open(file_name) as dfile:
        return generate_wizard_from_string(dfile.read())


def value2str(value):
    """
    Stringify given value.

    Arguments:
        value (any): Value.

    Returns:
        str: Stringified representation of given value.
    """
    if isinstance(value, str):
        return '"{}"'.format(value)
    if isinstance(value, list):
        return '[' + ', '.join([value2str(i) for i in value]) + ']'
    if isinstance(value, tuple):
        return '(' + ', '.join([value2str(i) for i in value]) + ')'
    if isinstance(value, dict):
        return '{' + ', '.join(['{}: {}'.format(value2str(i),
                                                value2str(j))\
                                    for i, j in value.items()]) + '}'
    return str(value)
