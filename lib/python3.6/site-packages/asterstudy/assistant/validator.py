# -*- coding: utf-8 -*-

# Copyright 2016-2018 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""Validator for calculation assistant declaration file."""

import json

from collections import OrderedDict

from ..common import CFG

def _schema():
    """Get access to schema validation module."""
    if getattr(_schema, "_jsonschema", None) is None:
        try:
            import jsonschema
        except ImportError:
            jsonschema = None
        _schema.jsonschema = jsonschema
    return _schema.jsonschema

class BadValidator(ImportError):
    """Exception: bad or not found validation module."""

class NoShema(IOError):
    """Exception: cannot read schema file."""

class BadShema(ValueError):
    """Exception: bad schema (not conform to JSON format)."""

class InvalidShema(ValueError):
    """Exception: invalid schema (not accepted by validation module)."""

class BadFile(ValueError):
    """Exception: cannot read declaration file."""

class NotUniqueParameterName(ValueError):
    """Exception: non-unique parameter name."""

class NotSupportedValue(ValueError):
    """Exception: unsupported value."""

class Validator:
    """Validator for assistant declaration file."""

    SCHEMA = CFG.rcfile('assistant_schema.json')

    def validate(self, declaration_file):
        """
        Validate given declaration file.

        Arguments:
            declaration_file(str): Path to declaration file.
        """
        # check that jsonschema package is available
        if not _schema():
            raise BadValidator("Validator (jsonschema) is not available")

        # check schema validity
        try:
            with open(self.SCHEMA) as fschema:
                schema = json.load(fschema)
        except IOError:
            raise NoShema("Cannot open schema file")
        except ValueError:
            raise BadShema("Bad schema file")
        try:
            _schema().Draft7Validator.check_schema(schema)
        except _schema().exceptions.SchemaError:
            raise InvalidShema("Invalid schema")

        # load desclaration file
        try:
            with open(declaration_file) as fdecl:
                declaration = json.load(fdecl, object_pairs_hook=OrderedDict)
        except IOError:
            raise IOError("Cannot open declaration file: {}".format(declaration_file))
        except ValueError:
            raise BadFile("Bad declaration file")

        # validate schema
        _schema().validate(declaration, schema)

        pnames = set()
        parameters = _find_kw(declaration, 'parameters')
        for path, parameter in parameters.items():
            # check that parameter name is unique within wizard
            _check_name(parameter.get('name'), pnames, path)
            # check that attributes don't contradict to each other
            _check_attrs(parameter, path)
            # additional checks for table...
            if parameter.get('typ') in ('table',):
                columns = _find_kw(parameter, 'columns', path)
                cnames = set()
                for sub_path, column in columns.items():
                    # check that column name is unique within table
                    _check_name(column.get('name'), cnames, sub_path)
                    # check that column's input type is supported
                    _check_table_column(column.get('typ'), sub_path)

        choices = _find_kw(declaration, 'choices')
        for path, choice in choices.items():
            # check that choice name is unique within wizard
            _check_name(choice.get('name'), pnames, path)

def _find_kw(obj, keyword, path=''):
    result = OrderedDict()
    if isinstance(obj, dict):
        if keyword in obj:
            value = obj[keyword]
            if isinstance(value, (list, tuple)):
                for idx, item in enumerate(value):
                    result[path + '/' + keyword + '[{}]'.format(idx)] = value[idx]
            else:
                result[path + '/' + keyword] = obj[keyword]
        for k in obj:
            result.update(_find_kw(obj[k], keyword, path + '/' + k))
    elif isinstance(obj, (list, tuple)):
        for idx, item in enumerate(obj):
            result.update(_find_kw(item, keyword, path + '[{}]'.format(idx)))
    return result

def _check_name(name, names, path):
    if name in names:
        raise NotUniqueParameterName(
            "Name '{}' is not unique for '{}'.".format(name, path))
    names.add(name)

def _check_attrs(parameter, path):
    if parameter.get('typ', 'string') in ('int', 'float'):
        # 'val_min'/'val_max' can't be used with 'into'
        if 'into' in parameter and ('val_min' in parameter or 'val_max' in parameter):
            raise NotSupportedValue(
                "Attribute 'into' cannot be used with 'val_min'/'val_max' for '{}'".format(path))
        # 'default' >= 'val_min'
        if 'default' in parameter and 'val_min' in parameter:
            if parameter.get('default') < parameter.get('val_min'):
                raise NotSupportedValue(
                    "Attribute 'default' is smaller than 'val_min' for '{}'".format(path))
        # 'default' <= 'val_max'
        if 'default' in parameter and 'val_max' in parameter:
            if parameter.get('default') > parameter.get('val_max'):
                raise NotSupportedValue(
                    "Attribute 'default' is larger than 'val_max' for '{}'".format(path))
    if parameter.get('typ', 'string') in ('string',):
        # 'len_min'/'len_max'/'length'/'regex' can't be used with 'into'
        if 'into' in parameter and ('len_min' in parameter or 'len_max' in parameter or \
                                        'length' in parameter or 'regex' in parameter):
            raise NotSupportedValue(
                "Attribute 'into' cannot be used with "
                "'len_min'/'len_max/length/regex' for '{}'".format(path))

def _check_table_column(typ, path):
    supported = ('int', 'float', 'string', 'group_ma', 'group_no', 'groups_ma', 'groups_no')
    if typ not in supported:
        raise NotSupportedValue("Type '{}' is not within {} for '{}'.".format(typ, supported, path))
