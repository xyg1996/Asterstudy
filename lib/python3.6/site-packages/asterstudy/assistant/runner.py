# -*- coding: utf-8 -*-

# Copyright 2016 EDF R&D
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you may download a copy of license
# from https://www.gnu.org/licenses/gpl-3.0.

"""Runner of the calculation assistant wizard."""


import os
import os.path as osp
import re
from configparser import ConfigParser, Error

from PyQt5 import Qt as Q

from ..common import connect, debug_message

# note: the following pragma is added to prevent pylint complaining
#       about functions that follow Qt naming conventions;
#       it should go after all global functions
# pragma pylint: disable=invalid-name


class Runner(Q.QObject):
    """Runner of calculation assistant."""

    def __init__(self, parent_widget=None, astergui=None):
        """
        Create runner.

        Arguments:
            parent_widget (Optional[QWidget]): Parent widget. Defaults to *None*.
            astergui (Optional[AsterGui]): AsterGui instance. Defaults to *None*.
        """
        super().__init__(parent_widget)
        self._astergui = astergui
        self._wizard = None
        self._wizard_data = None
        self._template_data = None
        self._stage_data = None
        self._data_files = {}

    def load_language(self, path):
        """
        Load resource files from given location.

        Arguments:
            path (str): A path to the directory with the translation files.
        """
        if self._astergui is not None:
            language = self._astergui.preferencesMgr().value('language')
            if not language:
                language = self._astergui.preferencesMgr().value('language/language')
            if language and path:
                for file_name in os.listdir(path):
                    file_path = osp.join(path, file_name)
                    if osp.isfile(file_path) and re.match('.*_{}.qm$'.format(language), file_name):
                        translator = Q.QTranslator(self)
                        if translator.load(file_path):
                            Q.QApplication.installTranslator(translator)

    @property
    def wizard(self):
        """QDialog: Attribute that holds wizard dialog."""
        return self._wizard

    @property
    def wizard_data(self):
        """str: Attribute that holds wizard code."""
        return self._wizard_data

    @wizard_data.setter
    def wizard_data(self, data):
        if self._wizard_data != data:
            self._stage_data = None
        self._wizard_data = data

    @property
    def template_data(self):
        """str: Attribute that holds template code."""
        return self._template_data

    @template_data.setter
    def template_data(self, data):
        if self._template_data != data:
            self._stage_data = None
        self._template_data = data

    @property
    def stage_data(self):
        """str: Attribute that holds resulting stage code."""
        return self._stage_data

    @property
    def data_files(self):
        """dict: Attribute that holds data files used in the stage."""
        return self._data_files

    def createWizard(self):
        """
        Create wizard for the calculation assistant.

        Returns:
            QDialog: Wizard dialog.

        Raises:
           ValueError: If wizard data was not set.
        """
        if not self.wizard_data:
            raise ValueError("Null wizard data")
        exec(self.wizard_data, globals()) # pragma pylint: disable=exec-used
        self._wizard = create_wizard(self.parent()) # pragma pylint: disable=undefined-variable
        connect(self.wizard.finished, self._wizardFinished)
        return self.wizard

    def runWizard(self):
        """
        Run the created wizard for the calculation assistant.

        Returns:
            int: Status of the wizard execution.

        Raises:
           ValueError: If wizard data was not set.
        """
        if not self.wizard:
            self.createWizard()
        return self.wizard.exec_()

    @Q.pyqtSlot(int)
    def _wizardFinished(self, result):
        """
        Called when wizard is accepted or rejected.

        Arguments:
            result: Status of the wizard execution.
        """
        if result == Q.QDialog.Accepted:
            text = self.template_data or ''
            values = self.wizard.value()
            debug_message(values)

            # step 1: pre-processing
            for name, value in values.items():
                if not isinstance(value, str):
                    continue
                pattern = re.compile('%' + str(name) + '=' + str(value) + '{(.*?)}%',
                                     re.MULTILINE | re.DOTALL)
                text = pattern.sub(r'\1', text)
                pattern = re.compile('%' + str(name) + '=[A-Za_z0-9_]+{(.*?)}%',
                                     re.MULTILINE | re.DOTALL)
                text = pattern.sub('', text)

            # step 2: replace values
            for name, value in values.items():
                if isinstance(value, dict) and len(value) == 1 and \
                        isinstance(next(iter(value.keys())), int):
                    # this seems to be a file
                    unit, file_name = value.popitem()
                    value = self._registerFile(unit, file_name)
                value = value2str(value)
                text = text.replace('%{}%'.format(name), value)
            self._stage_data = text

    def _registerFile(self, unit, file_name):
        """
        Register given file in the study.

        Arguments:
            unit (int): Default unit value.
            file_name (str): File path.

        Returns:
            int: Actual file unit.
        """
        while True:
            if unit not in self._data_files:
                if self._astergui is not None:
                    case = self._astergui.study().history.current_case
                    if case.nb_stages > 0:
                        new_unit = case.stages[-1].file2unit(file_name, unit)
                        if new_unit not in self._data_files:
                            unit = new_unit
                            break
                    else:
                        break
                else:
                    break
            unit = unit + 1
        self._data_files[unit] = file_name
        return unit


def from_config(path):
    """
    Read calculation wizard data from config file.

    Names of data files (declaration, wizard, template) are read
    from config file. If config file is not present or does not
    specify any of these data files, the default value is used.

    Arguments:
        path (str): Config file or a directory containing config file.

    Returns:
        (str, str, str): A tuple containing data from declaration file,
        wizard file and template file.
    """
    declaration, wizard, template = '', '', ''

    def _from_cfg_file(_cfg_file):
        _dfile = 'declaration.json'
        _wfile = 'wizard.py'
        _tfile = 'template.comm'
        try:
            _cfg = ConfigParser()
            _cfg.read(_cfg_file)
        except Error:
            pass
        else:
            if _cfg.has_option('General', 'Declaration'):
                _dfile = _cfg.get('General', 'Declaration')
            if _cfg.has_option('General', 'Wizard'):
                _wfile = _cfg.get('General', 'Wizard')
            if _cfg.has_option('General', 'Template'):
                _tfile = _cfg.get('General', 'Template')
        _dir_name = osp.dirname(_cfg_file)
        if not osp.isabs(_dfile):
            _dfile = osp.join(_dir_name, _dfile)
        if not osp.isabs(_wfile):
            _wfile = osp.join(_dir_name, _wfile)
        if not osp.isabs(_tfile):
            _tfile = osp.join(_dir_name, _tfile)
        return _dfile, _wfile, _tfile

    if osp.exists(path):
        if osp.isdir(path):
            if osp.exists(osp.join(path, 'wizard.conf')):
                dfile, wfile, tfile = \
                    _from_cfg_file(osp.join(path, 'wizard.conf'))
            else:
                dfile = osp.join(path, 'declaration.json')
                wfile = osp.join(path, 'wizard.py')
                tfile = osp.join(path, 'template.comm')
        else:
            dfile, wfile, tfile = _from_cfg_file(path)

        def _read_file(_path):
            _data = ''
            try:
                with open(_path) as _fobj:
                    _data = _fobj.read()
            except IOError:
                pass
            return str(_data)

        declaration = _read_file(dfile)
        wizard = _read_file(wfile)
        template = _read_file(tfile)

    return declaration, wizard, template


def value2str(value):
    """
    Convert given value to the form suitable for dump into the COMM file.

    Arguments:
        value (any): Value.

    Returns:
        str: Stringified representation of given value.
    """
    result = ''
    if isinstance(value, dict):
        values = []
        for key, item in value.items():
            values.append('{}={}'.format(key, value2str(item)))
        result = '_F({})'.format(', '.join(values))
    elif isinstance(value, (list, tuple)):
        values = []
        for item in value:
            values.append(value2str(item))
        if len(values) == 1:
            values.append('') # to have correct single-value tuple
        result = '({})'.format(', '.join(values))
    else:
        # below line should work in Python 3
        # result = '{!r}'.format(value)
        if isinstance(value, str):
            result = '"{}"'.format(str(value))
        else:
            result = str(value)
    return result
